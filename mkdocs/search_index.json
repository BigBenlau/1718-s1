{
    "docs": [
        {
            "location": "/index.html",
            "text": "CS2030 Programming Methodologies II\n\n\n10 September, 2017\n\n\nHere's the notes on \nLecture 5\n\n\n9 September, 2017\n\n\nAnother set of updates:\n\n\n\n\nReview Questions\n -  I will keep adding to this, do check it out, try to answer them, before verifying them in \njshell\n or small Java snippet.  Most important is to understand why.\n\n\nLab 1 Comments\n - Important lessons for you from your Lab 1.\n\n\nI added two articles on using setters and getters under \nReadings\n\n\n\n\n5 September, 2017\n\n\nA bunch of stuffs where updated on this site since 27 August.\n\n\n\n\nLab 2\n\n\nLecture 4 \nnotes\n, \nexecise\n, \nslides\n, \nvideo\n.\n\n\n\n\n27 August, 2017\n\n\nLecture 3\n and \nExercise 3\n are posted.  \n\n\n20 August, 2017\n\n\nLecture 2\n and \nExercise 2\n are posted.  \n\n\nYou should have received an email from the School of Computing about creating an account on \nsunfire\n.  If you have not done so, please do so ASAP at \nhttps://mysoc.nus.edu.sg/~newacct/\n.\n\n\n11 August, 2017\n\n\nMany of you are starting a new and exciting journey at NUS.  Congratulations, and welcome to NUS Computing!\n\n\nYou are looking at the main website for CS2030.  This is where you will get all of your module information (labs, lecture notes, etc).  \n\n\nThere are two other websites that we will use regularly over the course of the semester:\n\n\n\n\nPiazza\n, which we will use for Q&A, and\n\n\nIVLE\n, which we will use for \ngrade dissemination\n, \nclass roster\n, etc.\n\n\n\n\nHere are some things that you can read on this site, before the first class:\n\n\n\n\nAssumed prior knowledge\n: What we expect you to know before the class, from CS1010 or its equivalent;\n\n\nSome readings for 1\nst\n year students\n: Useful for senior students as well;\n\n\nAnd, if you feel up for it, \nthe notes for Lecture 1\n\n\n\n\nAlready have a question?  Ask us over at \nPiazza\n!",
            "title": "Home"
        },
        {
            "location": "/index.html#cs2030-programming-methodologies-ii",
            "text": "",
            "title": "CS2030 Programming Methodologies II"
        },
        {
            "location": "/index.html#10-september-2017",
            "text": "Here's the notes on  Lecture 5",
            "title": "10 September, 2017"
        },
        {
            "location": "/index.html#9-september-2017",
            "text": "Another set of updates:   Review Questions  -  I will keep adding to this, do check it out, try to answer them, before verifying them in  jshell  or small Java snippet.  Most important is to understand why.  Lab 1 Comments  - Important lessons for you from your Lab 1.  I added two articles on using setters and getters under  Readings",
            "title": "9 September, 2017"
        },
        {
            "location": "/index.html#5-september-2017",
            "text": "A bunch of stuffs where updated on this site since 27 August.   Lab 2  Lecture 4  notes ,  execise ,  slides ,  video .",
            "title": "5 September, 2017"
        },
        {
            "location": "/index.html#27-august-2017",
            "text": "Lecture 3  and  Exercise 3  are posted.",
            "title": "27 August, 2017"
        },
        {
            "location": "/index.html#20-august-2017",
            "text": "Lecture 2  and  Exercise 2  are posted.    You should have received an email from the School of Computing about creating an account on  sunfire .  If you have not done so, please do so ASAP at  https://mysoc.nus.edu.sg/~newacct/ .",
            "title": "20 August, 2017"
        },
        {
            "location": "/index.html#11-august-2017",
            "text": "Many of you are starting a new and exciting journey at NUS.  Congratulations, and welcome to NUS Computing!  You are looking at the main website for CS2030.  This is where you will get all of your module information (labs, lecture notes, etc).    There are two other websites that we will use regularly over the course of the semester:   Piazza , which we will use for Q&A, and  IVLE , which we will use for  grade dissemination ,  class roster , etc.   Here are some things that you can read on this site, before the first class:   Assumed prior knowledge : What we expect you to know before the class, from CS1010 or its equivalent;  Some readings for 1 st  year students : Useful for senior students as well;  And, if you feel up for it,  the notes for Lecture 1   Already have a question?  Ask us over at  Piazza !",
            "title": "11 August, 2017"
        },
        {
            "location": "/about/index.html",
            "text": "CS2030 Programming Methodology II\n\n\nAbout\n\n\nThis module is a follow up to CS1010.  It explores two modern programming paradigms, object-oriented programming and functional programming.  Through a series of integrated assignments, students will learn to develop medium-scale software programs in the order of thousands of lines of code and tens of classes using object-oriented design principles and advanced programming constructs available in the two paradigms.  Topics include objects and classes, composition, association, inheritance, interface, polymorphism, abstract classes, dynamic binding, lambda expression, effect-free programming, first class functions, closures, continuations, monad, etc.  \n\n\nWho/When/Where\n\n\n\n\nLecture:\n 10am - 12noon, every Monday\n\n\nVenue:\n LT19\n\n\nInstructor:\n \nOoi Wei Tsang\n (\nooiwt@comp.nus.edu.sg\n)\n\n\nTeaching Assistant:\n Kenneth Lu (\nlu.yang.kenneth@u.nus.edu\n)\n\n\nLab:\n Every Thursday (Week 3 - Week 13)\n\n\nMidterm Test:\n October 2, 2017, Monday, 10am\n\n\nFinal Assessment:\n November 29, 2017, Wednesday, 9am.\n\n\n\n\nWorkload\n\n\nBesides the 4-hour contact time for lecture and lab, students are expected to spend about 6 hours on average weekly on homework and on preparing the class.\n\n\nHistory\n\n\nCS2030 is a new module, required for all students in Bachelor of Computing (Computer Science) and Second Major in Computer Science students, cohort 17/18 onwards.  In 2017, the Department of Computer Science reorganized the two module series on data structures and algorithms (CS1020, CS2010) into (CS2030, CS2040).  CS2040 focuses on data structures and algorithms, while the advanced programming methodologies from CS1020 are moved into CS2030.  CS2030 will also covers some basics OO design that previously were covered in CS2103, and introduces students to functional programming, concurrent programming, event-based programming, and other paradigms that are increasingly important.\n\n\nLearning Outcomes\n\n\nAfter completing the module, students should:\n\n\n\n\nbe confident in reading and developing medium-scale programs (up to 10K lines of code)\n\n\nbe familiarize enough with common OO concepts to understand software code written in common OO language and understand documentation of software libraries in OO\n\n\nbe able to apply OO concepts to design and implement medium to large scale  programs, including\n\n\ndesign and implement a class\n\n\ndecompose a problem solution into classes and define members and methods for each class\n\n\nuse polymorphism effectively\n\n\nuse inheritance to design simple class hierarchies that allow code reuse\n\n\ntrace the control flow of a programs that use dynamic dispatch\n\n\nuse encapsulation mechanisms such as interfaces, private methods/members\n\n\n\n\n\n\nbe familiarize enough with common functional programming concepts and constructs, including lambda expression, effect-free programming, first class functions, infinite streams.\n\n\nbe able to apply functional programming concepts to design and implement , including:\n\n\nImplement basic algorithms in functions that are effect free.\n\n\nImplement useful functions that take/return another function\n\n\nWrite correct and effective code using lambda expressions and/or infinite streams\n\n\n\n\n\n\nbe able to compare and contrast imperative programming, OO programming, and function programming paradigms, and select the most natural paradigms for each situation\n\n\nbe aware of how the OOP and FP concepts are implemented in different ways in different programming languages\n\n\nbe confident enough to learn new programming languages that uses OOP and FP paradigm\n\n\nattain proficiency in Java 8 (and above)\n\n\nbe equipped with solid programming foundations for further studies in computer science\n\n\n\n\nTextbook\n\n\nThere is no textbook for this class.\n\n\nThere are many good books and online articles written about the topics covered in the module.  These will be listed under the \nReadings\n section.",
            "title": "About"
        },
        {
            "location": "/about/index.html#cs2030-programming-methodology-ii",
            "text": "",
            "title": "CS2030 Programming Methodology II"
        },
        {
            "location": "/about/index.html#about",
            "text": "This module is a follow up to CS1010.  It explores two modern programming paradigms, object-oriented programming and functional programming.  Through a series of integrated assignments, students will learn to develop medium-scale software programs in the order of thousands of lines of code and tens of classes using object-oriented design principles and advanced programming constructs available in the two paradigms.  Topics include objects and classes, composition, association, inheritance, interface, polymorphism, abstract classes, dynamic binding, lambda expression, effect-free programming, first class functions, closures, continuations, monad, etc.",
            "title": "About"
        },
        {
            "location": "/about/index.html#whowhenwhere",
            "text": "Lecture:  10am - 12noon, every Monday  Venue:  LT19  Instructor:   Ooi Wei Tsang  ( ooiwt@comp.nus.edu.sg )  Teaching Assistant:  Kenneth Lu ( lu.yang.kenneth@u.nus.edu )  Lab:  Every Thursday (Week 3 - Week 13)  Midterm Test:  October 2, 2017, Monday, 10am  Final Assessment:  November 29, 2017, Wednesday, 9am.",
            "title": "Who/When/Where"
        },
        {
            "location": "/about/index.html#workload",
            "text": "Besides the 4-hour contact time for lecture and lab, students are expected to spend about 6 hours on average weekly on homework and on preparing the class.",
            "title": "Workload"
        },
        {
            "location": "/about/index.html#history",
            "text": "CS2030 is a new module, required for all students in Bachelor of Computing (Computer Science) and Second Major in Computer Science students, cohort 17/18 onwards.  In 2017, the Department of Computer Science reorganized the two module series on data structures and algorithms (CS1020, CS2010) into (CS2030, CS2040).  CS2040 focuses on data structures and algorithms, while the advanced programming methodologies from CS1020 are moved into CS2030.  CS2030 will also covers some basics OO design that previously were covered in CS2103, and introduces students to functional programming, concurrent programming, event-based programming, and other paradigms that are increasingly important.",
            "title": "History"
        },
        {
            "location": "/about/index.html#learning-outcomes",
            "text": "After completing the module, students should:   be confident in reading and developing medium-scale programs (up to 10K lines of code)  be familiarize enough with common OO concepts to understand software code written in common OO language and understand documentation of software libraries in OO  be able to apply OO concepts to design and implement medium to large scale  programs, including  design and implement a class  decompose a problem solution into classes and define members and methods for each class  use polymorphism effectively  use inheritance to design simple class hierarchies that allow code reuse  trace the control flow of a programs that use dynamic dispatch  use encapsulation mechanisms such as interfaces, private methods/members    be familiarize enough with common functional programming concepts and constructs, including lambda expression, effect-free programming, first class functions, infinite streams.  be able to apply functional programming concepts to design and implement , including:  Implement basic algorithms in functions that are effect free.  Implement useful functions that take/return another function  Write correct and effective code using lambda expressions and/or infinite streams    be able to compare and contrast imperative programming, OO programming, and function programming paradigms, and select the most natural paradigms for each situation  be aware of how the OOP and FP concepts are implemented in different ways in different programming languages  be confident enough to learn new programming languages that uses OOP and FP paradigm  attain proficiency in Java 8 (and above)  be equipped with solid programming foundations for further studies in computer science",
            "title": "Learning Outcomes"
        },
        {
            "location": "/about/index.html#textbook",
            "text": "There is no textbook for this class.  There are many good books and online articles written about the topics covered in the module.  These will be listed under the  Readings  section.",
            "title": "Textbook"
        },
        {
            "location": "/schedule/index.html",
            "text": "Schedule and Learning Material\n\n\n\n\n\n\n\n\nWeek\n\n\nDate\n\n\nTopics\n\n\nResources\n\n\n\n\n\n\n\n\n\n\n\n\n1\n\n\n2017-08-14\n\n\nAbstraction and Encapsulation\n\n\nNotes\n . \nSlides\n . \nVideo\n\n\n\n\n\n\n\n\n2\n\n\n2017-08-21\n\n\nInheritance and Polymorphism\n\n\nNotes\n . \nSlides\n . \nVideo\n\n\n\n\n\n\n\n\n3\n\n\n2017-08-28\n\n\nInheritance, Continued\n\n\nNotes\n . \nSlides\n . \nVideo\n\n\n\n\n\n\n\n\n4\n\n\n2017-09-04\n\n\nMemory, Generics, and Exceptions\n\n\nNotes\n . \nSlides\n . \nVideo\n\n\n\n\n\n\n\n\n5\n\n\n2017-09-11\n\n\nExamples from Java Packages\n\n\n\n\n\n\n\n\n\n\n6\n\n\n2017-09-18\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n2017-09-25\n\n\nBreak\n\n\n\n\n\n\n\n\n\n\n7\n\n\n2017-10-02\n\n\nMidterm\n\n\n\n\n\n\n\n\n\n\n8\n\n\n2017-10-09\n\n\n\n\n\n\n\n\n\n\n\n\n9\n\n\n2017-10-16\n\n\n\n\n\n\n\n\n\n\n\n\n10\n\n\n2017-10-23\n\n\n\n\n\n\n\n\n\n\n\n\n11\n\n\n2017-10-30\n\n\n\n\n\n\n\n\n\n\n\n\n12\n\n\n2017-11-06\n\n\n\n\n\n\n\n\n\n\n\n\n13\n\n\n2017-11-13",
            "title": "Schedule"
        },
        {
            "location": "/schedule/index.html#schedule-and-learning-material",
            "text": "Week  Date  Topics  Resources       1  2017-08-14  Abstraction and Encapsulation  Notes  .  Slides  .  Video     2  2017-08-21  Inheritance and Polymorphism  Notes  .  Slides  .  Video     3  2017-08-28  Inheritance, Continued  Notes  .  Slides  .  Video     4  2017-09-04  Memory, Generics, and Exceptions  Notes  .  Slides  .  Video     5  2017-09-11  Examples from Java Packages      6  2017-09-18        2017-09-25  Break      7  2017-10-02  Midterm      8  2017-10-09       9  2017-10-16       10  2017-10-23       11  2017-10-30       12  2017-11-06       13  2017-11-13",
            "title": "Schedule and Learning Material"
        },
        {
            "location": "/prereqs/index.html",
            "text": "Assumed Prior Knowledge\n\n\nCS2030 has the prerequisite of CS1010 or its equivalent.  There are, however, several versions of CS1010, and some students are waived from doing CS1010 due to prior programming knowledge.  This document here outlines the prior knowledge that the instructors assume the students have before entering CS2030.\n\n\nBasic computational problem solving and programming skills\n\n\nHere are some learning outcomes that students should attained after taking CS1010.  Students should be familiar with:\n\n\n\n\nthe computational thinking process of formulating a problem and coming up with a solution,\n\n\nfundamental programming concepts, including variables, assignments, conditions, branches, loops, expressions, functions, recursions, and structures\n\n\nhow to program a given solution in a programming language\n\n\ndifferent classes of programming errors (logical errors, syntax errors, run-time errors)\n\n\ncommon debugging techniques and strategies\n\n\ngood programming practices (comments, naming convention, indentation, modular code)\n\n\nsimple data structures (e.g., arrays)\n\n\nwriting test cases to check correctness of own program\n\n\nhow a program is executed and represented in a computing device (at a high level)\n\n\nthe compilation process (at a high level)\n\n\nthe concept of reusability and the use of standard/3\nrd\n party software\n\n\nbubble sort, insertion sort, linear search, and binary search\n\n\n\n\nStudents who take CS2030 are assumed to have sufficient knowledge of the above.  If there are specific components that you are not familiar with, please pick up the notes from CS1010 and self-learn.\n\n\nUNIX command line\n\n\nWe will use the \nsunfire\n computing server for this module.  As such, you are expected to be comfortable with using CLI (command line interface) and the basic UNIX commands, in a text window without fancy windows and mouse, and the concept of \nssh\n-ing into a remote host and work remotely.\n\n\nIf you are not familiar with this concept, take a look at the \nslides from the CS1010/CS1020 workshop\n.\n\n\nSource code editors\n\n\nYou are expected to be familiar with one or more source code editors.  Note that source code editor is not the same as text editor (e.g., Notepad).  A source code editor automatically highlights syntax, indents the code, matches parenthesis, supports autocompletion and code folding, and integrates with the software development process (such as revision control).\n\n\nCS1010 started (or would have started) you off with \nvim\n.  Many good source code editors exists, such as \nAtom\n, \nVS Code\n, and of course \nemacs\n1\n!\n\n\nFor your career, you should pick one and master it.  If you want to learn \nvim\n, the command \nvimtutor\n is a good place to start.  There are also many tutorials, webcasts, games, etc, online to help you learn \nvim\n.  Just google.\n\n\nDeveloper's Friendly OS\n\n\nYour life through the computing modules would be much much better if you are using a developer's friendly operating system on your personal computer.  \n\n\n\n\n\n\nIf you uses Linux or macOS, you are all set.  For macOS users, \nbrew\n is highly recommended.\n\n\n\n\n\n\nIf you use Windows 10, you should definitely install the Ubuntu Bash Shell.  There are many excellent tutorials online (such as \nthis one\n).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nI can't mention \nvim\n without mentioning \nemacs\n\u00a0\n\u21a9",
            "title": "Prerequisites"
        },
        {
            "location": "/prereqs/index.html#assumed-prior-knowledge",
            "text": "CS2030 has the prerequisite of CS1010 or its equivalent.  There are, however, several versions of CS1010, and some students are waived from doing CS1010 due to prior programming knowledge.  This document here outlines the prior knowledge that the instructors assume the students have before entering CS2030.",
            "title": "Assumed Prior Knowledge"
        },
        {
            "location": "/prereqs/index.html#basic-computational-problem-solving-and-programming-skills",
            "text": "Here are some learning outcomes that students should attained after taking CS1010.  Students should be familiar with:   the computational thinking process of formulating a problem and coming up with a solution,  fundamental programming concepts, including variables, assignments, conditions, branches, loops, expressions, functions, recursions, and structures  how to program a given solution in a programming language  different classes of programming errors (logical errors, syntax errors, run-time errors)  common debugging techniques and strategies  good programming practices (comments, naming convention, indentation, modular code)  simple data structures (e.g., arrays)  writing test cases to check correctness of own program  how a program is executed and represented in a computing device (at a high level)  the compilation process (at a high level)  the concept of reusability and the use of standard/3 rd  party software  bubble sort, insertion sort, linear search, and binary search   Students who take CS2030 are assumed to have sufficient knowledge of the above.  If there are specific components that you are not familiar with, please pick up the notes from CS1010 and self-learn.",
            "title": "Basic computational problem solving and programming skills"
        },
        {
            "location": "/prereqs/index.html#unix-command-line",
            "text": "We will use the  sunfire  computing server for this module.  As such, you are expected to be comfortable with using CLI (command line interface) and the basic UNIX commands, in a text window without fancy windows and mouse, and the concept of  ssh -ing into a remote host and work remotely.  If you are not familiar with this concept, take a look at the  slides from the CS1010/CS1020 workshop .",
            "title": "UNIX command line"
        },
        {
            "location": "/prereqs/index.html#source-code-editors",
            "text": "You are expected to be familiar with one or more source code editors.  Note that source code editor is not the same as text editor (e.g., Notepad).  A source code editor automatically highlights syntax, indents the code, matches parenthesis, supports autocompletion and code folding, and integrates with the software development process (such as revision control).  CS1010 started (or would have started) you off with  vim .  Many good source code editors exists, such as  Atom ,  VS Code , and of course  emacs 1 !  For your career, you should pick one and master it.  If you want to learn  vim , the command  vimtutor  is a good place to start.  There are also many tutorials, webcasts, games, etc, online to help you learn  vim .  Just google.",
            "title": "Source code editors"
        },
        {
            "location": "/prereqs/index.html#developers-friendly-os",
            "text": "Your life through the computing modules would be much much better if you are using a developer's friendly operating system on your personal computer.      If you uses Linux or macOS, you are all set.  For macOS users,  brew  is highly recommended.    If you use Windows 10, you should definitely install the Ubuntu Bash Shell.  There are many excellent tutorials online (such as  this one ).        I can't mention  vim  without mentioning  emacs \u00a0 \u21a9",
            "title": "Developer's Friendly OS"
        },
        {
            "location": "/readings/index.html",
            "text": "Readings\n\n\nHere is a collection of readings related to CS2030 or otherwise.\n\n\nOn UNIX, Vim, and Emacs\n\n\n\n\n\n\nStackExchange: \nTime to Drop Emacs and Vim?\n\n\n\n\n\n\nBook: \nThe Art of UNIX Programming\n, online version, by Eric Steven Raymond, 2003. \n\n\n\n\n\n\nOn Programming Practices\n\n\n\n\nGoogle Java Style Guide\n\n\n\n\nOn OOP\n\n\n\n\n\n\nWhy extends in evil\n by Allen Holub. \n\"Good designers write most of their code in terms of interfaces, not concrete base classes.\"\n\n\n\n\n\n\nGoodbye, Object Oriented Programming\n by Charles Scalfani. \n\"One day, my code works and the next day it stops working. Here\u2019s the kicker. I didn\u2019t change my code.\n\"\n\n\n\n\n\n\nWhy getters and setters methods are evil\n, by Allen Holub. \"\nThough getter/setter methods are commonplace in Java, they are not particularly object oriented (OO). In fact, they can damage your code's maintainability. Moreover, the presence of numerous getter and setter methods is a red flag that the program isn't necessarily well designed from an OO perspective.\n\"\n\n\n\n\n\n\nGetters/Setters.  Evil.  Period\n, by Yegor Bygayenko.  \"\nThe gist of the following text is this: getters and setters is a terrible practice and those who use it can't be excused.\n\"\n\n\n\n\n\n\nFor 1\nst\n Year Students\n\n\n\n\n\n\nNotes to Computer Science Freshmen, From the Future\n: \nEarly into the AY12/13 academic year, Prof Tay Yong Chiang organized a supper for Computer Science freshmen at Tembusu College. The bunch of seniors who were gathered there put together a document for NUS computing freshmen. This is that document.\n\n\n\n\n\n\nHow Not to Go About a Programming Assignment, by Agustin Cernuda del Rio\n: \nComputer programming students invariably fall into more than one bad habit. It can be extremely difficult to eradicate them (and many lecturers and professional programmers keep succumbing to them time and again)..\n\n\n\n\n\n\nBest Teacher I Ever Had, by David Owen\n: \nMr. Whitson taught sixth-grade science. On the first day of class, he gave us a lecture about a creature called the cattywampus, ..\n\n\n\n\n\n\nAcademic Honesty\n: \nAll students share the responsibility for upholding the academic standards and reputation of the University. Academic honesty is a prerequisite condition in the pursuit and acquisition of knowledge..",
            "title": "Readings"
        },
        {
            "location": "/readings/index.html#readings",
            "text": "Here is a collection of readings related to CS2030 or otherwise.",
            "title": "Readings"
        },
        {
            "location": "/readings/index.html#on-unix-vim-and-emacs",
            "text": "StackExchange:  Time to Drop Emacs and Vim?    Book:  The Art of UNIX Programming , online version, by Eric Steven Raymond, 2003.",
            "title": "On UNIX, Vim, and Emacs"
        },
        {
            "location": "/readings/index.html#on-programming-practices",
            "text": "Google Java Style Guide",
            "title": "On Programming Practices"
        },
        {
            "location": "/readings/index.html#on-oop",
            "text": "Why extends in evil  by Allen Holub.  \"Good designers write most of their code in terms of interfaces, not concrete base classes.\"    Goodbye, Object Oriented Programming  by Charles Scalfani.  \"One day, my code works and the next day it stops working. Here\u2019s the kicker. I didn\u2019t change my code.\n\"    Why getters and setters methods are evil , by Allen Holub. \" Though getter/setter methods are commonplace in Java, they are not particularly object oriented (OO). In fact, they can damage your code's maintainability. Moreover, the presence of numerous getter and setter methods is a red flag that the program isn't necessarily well designed from an OO perspective. \"    Getters/Setters.  Evil.  Period , by Yegor Bygayenko.  \" The gist of the following text is this: getters and setters is a terrible practice and those who use it can't be excused. \"",
            "title": "On OOP"
        },
        {
            "location": "/readings/index.html#for-1st-year-students",
            "text": "Notes to Computer Science Freshmen, From the Future :  Early into the AY12/13 academic year, Prof Tay Yong Chiang organized a supper for Computer Science freshmen at Tembusu College. The bunch of seniors who were gathered there put together a document for NUS computing freshmen. This is that document.    How Not to Go About a Programming Assignment, by Agustin Cernuda del Rio :  Computer programming students invariably fall into more than one bad habit. It can be extremely difficult to eradicate them (and many lecturers and professional programmers keep succumbing to them time and again)..    Best Teacher I Ever Had, by David Owen :  Mr. Whitson taught sixth-grade science. On the first day of class, he gave us a lecture about a creature called the cattywampus, ..    Academic Honesty :  All students share the responsibility for upholding the academic standards and reputation of the University. Academic honesty is a prerequisite condition in the pursuit and acquisition of knowledge..",
            "title": "For 1st Year Students"
        },
        {
            "location": "/policies/index.html",
            "text": "Policies\n\n\nEmail Communication\n\n\n\n\n\n\nPlease use only your official NUS email for communication with the teaching staffs -- either the one with \n@u.nus.edu\n or \n@comp.nus.edu.sg\n.  \n\n\n\n\n\n\nPlease use email only for private matters.  Prefix your email subject with \n[CS2030]\n.\n\n\n\n\n\n\nPlease use \nPiazza\n for other matters related to the module.  If you email us privately and we feel that your questions/answers are useful to the rest of the class, we will publish it on Piazza, with anonymization when appropriate.\n\n\n\n\n\n\nLab Sessions\n\n\n\n\n\n\nWe do take attendance during the lab sessions, but it does not affect your grades if you do not attend the lab sessions as long as you still need to submit the graded lab exercises.  \n\n\n\n\n\n\nYou should stick to your allocated time slot for labs.  If there is a strong reason for your to attend another lab session, please inform your lab instructors.\n\n\n\n\n\n\nLate Submissions\n\n\n\n\n\n\nAll graded exercise must be submitted on time.  If you need an extension, please ask for one and provide a justification for approval.  \n\n\n\n\n\n\nFor late submission, there is a 1% penalty (of the assessment grade) for every minute after the deadline, capped at 80%.  For example, if a homework is deserved 40 marks, and it is submitted 20 minutes after the deadline, the student will get 32 marks instead (20% penalty).  If it is submitted 2 hours after the deadline, the student will get 8 marks (as it has hit the cap of 80% penalty).\n\n\n\n\n\n\nDiscussions and Plagiarism\n\n\n\n\n\n\nWe encourage discussions among students for lab assignments, but each student should be responsible for writing his/her own code and should give credits to others when appropriate.  \n\n\n\n\n\n\nNUS and School of Computing have a high standard on academic honesty and take any violation seriously.  In the context of computing modules, source code plagiarism -- copying code from another source and attributing it as one's own code -- is a series violation.   Please read the page \nPreventing Plagiarism\n from the school's website to familiarize yourself with the policy.\n\n\n\n\n\n\nI adopt a \"no mercy\" policy when it comes to disciplinary action on plagiarism.  Both parties, the student who copied, and the student who allowed others to copy, will be penalized equally.\n\n\n\n\n\n\nLecture Video\n\n\n\n\n\n\nScreencast will be recorded and posted online 2-3 days after the lecture. \nThis will be done on a 'best effort' basis and screencast will not be guaranteed to be available.  \n\n\n\n\n\n\nPosting of screencast is meant to help students who attended the lecture to recap the content, or to help those who are not able to attend the lecture due to unexpected circumstances.  It does not mean that you should skip lecture.\n\n\n\n\n\n\nModel Solutions and Slides\n\n\n\n\n\n\nSlides will be posted \nafter\n the class.  Note that slides are used as a \nvisual aid\n to assist me during lecture.  It is not meant as summary of lectures nor a replacement of lecture notes.\n\n\n\n\n\n\nIn a module like CS2030, there is often not a single correct answer.  Hence, there is no model solution for this module.  Sample solutions may be posted (both good and bad ones) for discussion.  I strongly encourage students to discuss your solution with me, instead of just comparing your solution with the sample solution.\n\n\n\n\n\n\nGrading\n\n\n\n\nStudents will received the grades they deserved irrespective of how the other students in the class performed (i.e., no bell curve)\n\n\n\n\nOpen Book Assessment\n\n\n\n\n\n\nAll assessment, including graded labs, midterm test, and final assessment, are open book assessment -- you can bring in your notes or other \nanalog\n reference materials.  Java documentation will be made available during labs.  Relevant Java APIs will be provided during midterm tests and final assessments.\n\n\n\n\n\n\nThere is \nnothing to memorize\n for this class.",
            "title": "Policies"
        },
        {
            "location": "/policies/index.html#policies",
            "text": "",
            "title": "Policies"
        },
        {
            "location": "/policies/index.html#email-communication",
            "text": "Please use only your official NUS email for communication with the teaching staffs -- either the one with  @u.nus.edu  or  @comp.nus.edu.sg .      Please use email only for private matters.  Prefix your email subject with  [CS2030] .    Please use  Piazza  for other matters related to the module.  If you email us privately and we feel that your questions/answers are useful to the rest of the class, we will publish it on Piazza, with anonymization when appropriate.",
            "title": "Email Communication"
        },
        {
            "location": "/policies/index.html#lab-sessions",
            "text": "We do take attendance during the lab sessions, but it does not affect your grades if you do not attend the lab sessions as long as you still need to submit the graded lab exercises.      You should stick to your allocated time slot for labs.  If there is a strong reason for your to attend another lab session, please inform your lab instructors.",
            "title": "Lab Sessions"
        },
        {
            "location": "/policies/index.html#late-submissions",
            "text": "All graded exercise must be submitted on time.  If you need an extension, please ask for one and provide a justification for approval.      For late submission, there is a 1% penalty (of the assessment grade) for every minute after the deadline, capped at 80%.  For example, if a homework is deserved 40 marks, and it is submitted 20 minutes after the deadline, the student will get 32 marks instead (20% penalty).  If it is submitted 2 hours after the deadline, the student will get 8 marks (as it has hit the cap of 80% penalty).",
            "title": "Late Submissions"
        },
        {
            "location": "/policies/index.html#discussions-and-plagiarism",
            "text": "We encourage discussions among students for lab assignments, but each student should be responsible for writing his/her own code and should give credits to others when appropriate.      NUS and School of Computing have a high standard on academic honesty and take any violation seriously.  In the context of computing modules, source code plagiarism -- copying code from another source and attributing it as one's own code -- is a series violation.   Please read the page  Preventing Plagiarism  from the school's website to familiarize yourself with the policy.    I adopt a \"no mercy\" policy when it comes to disciplinary action on plagiarism.  Both parties, the student who copied, and the student who allowed others to copy, will be penalized equally.",
            "title": "Discussions and Plagiarism"
        },
        {
            "location": "/policies/index.html#lecture-video",
            "text": "Screencast will be recorded and posted online 2-3 days after the lecture. \nThis will be done on a 'best effort' basis and screencast will not be guaranteed to be available.      Posting of screencast is meant to help students who attended the lecture to recap the content, or to help those who are not able to attend the lecture due to unexpected circumstances.  It does not mean that you should skip lecture.",
            "title": "Lecture Video"
        },
        {
            "location": "/policies/index.html#model-solutions-and-slides",
            "text": "Slides will be posted  after  the class.  Note that slides are used as a  visual aid  to assist me during lecture.  It is not meant as summary of lectures nor a replacement of lecture notes.    In a module like CS2030, there is often not a single correct answer.  Hence, there is no model solution for this module.  Sample solutions may be posted (both good and bad ones) for discussion.  I strongly encourage students to discuss your solution with me, instead of just comparing your solution with the sample solution.",
            "title": "Model Solutions and Slides"
        },
        {
            "location": "/policies/index.html#grading",
            "text": "Students will received the grades they deserved irrespective of how the other students in the class performed (i.e., no bell curve)",
            "title": "Grading"
        },
        {
            "location": "/policies/index.html#open-book-assessment",
            "text": "All assessment, including graded labs, midterm test, and final assessment, are open book assessment -- you can bring in your notes or other  analog  reference materials.  Java documentation will be made available during labs.  Relevant Java APIs will be provided during midterm tests and final assessments.    There is  nothing to memorize  for this class.",
            "title": "Open Book Assessment"
        },
        {
            "location": "/reviews/index.html",
            "text": "Review Questions\n\n\n\n\n\n\nCan, or not? \n\n\n1\n2\n3\n4\n5\n6\nint\n \ni\n;\n\n\ndouble\n \nd\n;\n\n\ni\n \n=\n \nd\n;\n\n\nd\n \n=\n \ni\n;\n\n\ni\n \n=\n \n(\nint\n)\n \nd\n;\n\n\nd\n \n=\n \n(\ndouble\n)\n \ni\n;\n\n\n\n\n\n\n\n\n\n\n\nCan, or not? \n\n\n1\n2\n3\n4\n5\n6\nint\n \ni\n;\n\n\nboolean\n \nb\n;\n\n\ni\n \n=\n \nb\n;\n\n\nb\n \n=\n \ni\n;\n\n\ni\n \n=\n \n(\nint\n)\n \nb\n;\n\n\nb\n \n=\n \n(\nboolean\n)\n \ni\n;\n\n\n\n\n\n\n\n\n\n\n\nCan, or not? \n\n\n1\n2\n3\n4\n5\n6\n7\n8\nclass\n \nA\n \n{\n\n\n}\n\n\n\nclass\n \nB\n \nextends\n \nA\n \n{\n\n\n}\n\n\n\nA\n \na\n \n=\n \nnew\n \nB\n();\n\n\nB\n \nb\n \n=\n \nnew\n \nA\n();\n\n\n\n\n\n\n\n\n\n\n\nCan, or not? \n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\nclass\n \nA\n \n{\n\n\n}\n\n\n\nclass\n \nB\n \nextends\n \nA\n \n{\n\n\n}\n\n\n\nA\n \na\n \n=\n \nnew\n \nA\n();\n\n\nB\n \nb\n \n=\n \nnew\n \nB\n();\n\n\nb\n \n=\n \n(\nB\n)\na\n;\n\n\na\n \n=\n \n(\nA\n)\nb\n;\n\n\n\n\n\n\n\n\n\n\n\nCan, or not? \n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\ninterface\n \nI\n \n{\n\n\n}\n\n\n\nclass\n \nA\n \nimplements\n \nI\n \n{\n\n\n}\n\n\n\nI\n \ni1\n \n=\n \nnew\n \nI\n();\n\n\nI\n \ni2\n \n=\n \nnew\n \nA\n();\n\n\nA\n \na1\n \n=\n \ni2\n;\n\n\nA\n \na2\n \n=\n \n(\nA\n)\ni2\n;\n\n\n\n\n\n\n\n\n\n\n\nCan, or not? \n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\ninterface\n \nI\n \n{\n\n\n}\n\n\n\ninterface\n \nJ\n \nextends\n \nI\n \n{\n\n\n}\n\n\n\nclass\n \nA\n \nimplements\n \nJ\n \n{\n\n\n}\n\n\n\nA\n \na\n \n=\n \nnew\n \nA\n();\n\n\nI\n \ni\n \n=\n \na\n;\n\n\nJ\n \nj\n \n=\n \na\n;\n\n\ni\n \n=\n \nj\n;\n\n\nj\n \n=\n \ni\n;\n\n\nj\n \n=\n \n(\nJ\n)\ni\n;\n\n\na\n \n=\n \ni\n;\n\n\na\n \n=\n \nj\n;\n\n\na\n \n=\n \n(\nA\n)\ni\n;\n\n\na\n \n=\n \n(\nA\n)\nj\n;\n\n\n\n\n\n\n\n\n\n\n\nCan, or not? \n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\ninterface\n \nI\n \n{\n\n\n}\n\n\n\ninterface\n \nJ\n \n{\n\n\n}\n\n\n\nclass\n \nA\n \nimplements\n \nI\n,\n \nJ\n \n{\n\n\n}\n\n\n\nA\n \na\n \n=\n \nnew\n \nA\n();\n\n\nI\n \ni\n \n=\n \na\n;\n\n\nJ\n \nj\n \n=\n \na\n;\n\n\ni\n \n=\n \nj\n;\n\n\nj\n \n=\n \ni\n;\n\n\nj\n \n=\n \n(\nJ\n)\ni\n;\n\n\nI\n \n=\n \n(\nI\n)\nj\n;\n\n\na\n \n=\n \ni\n;\n\n\na\n \n=\n \nj\n;\n\n\na\n \n=\n \n(\nA\n)\ni\n;\n\n\na\n \n=\n \n(\nA\n)\nj\n;\n\n\n\n\n\n\n\n\n\n\n\nCan, or not? \n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\nclass\n \nA\n \n{\n\n\n}\n\n\n\nclass\n \nB\n \nextends\n \nA\n \n{\n\n\n}\n\n\n\nclass\n \nC\n \nextends\n \nA\n \n{\n\n\n}\n\n\n\nB\n \nb\n \n=\n \nnew\n \nB\n();\n\n\nA\n \na\n \n=\n \nb\n;\n\n\nC\n \nc\n \n=\n \nb\n;\n\n\nA\n \na\n \n=\n \n(\nA\n)\nb\n;\n\n\nC\n \nc\n \n=\n \n(\nC\n)\nb\n;\n\n\n\n\n\n\n\n\n\n\n\nCan, or not? If can, print what?\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\nclass\n \nA\n \n{\n\n  \nvoid\n \nf\n()\n \n{\n \nSystem\n.\nout\n.\nprintln\n(\n\"A f\"\n);\n \n}\n\n\n}\n\n\n\nclass\n \nB\n \nextends\n \nA\n \n{\n\n\n}\n\n\n\nB\n \nb\n \n=\n \nnew\n \nB\n();\n\n\nb\n.\nf\n();\n\n\nA\n \na\n \n=\n \nb\n;\n\n\na\n.\nf\n();\n\n\n\n\n\n\n\n\n\n\n\nCan, or not? If can, print what?\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\nclass\n \nA\n \n{\n\n  \nvoid\n \nf\n()\n \n{\n \n    \nSystem\n.\nout\n.\nprintln\n(\n\"A f\"\n);\n \n  \n}\n\n\n}\n\n\n\nclass\n \nB\n \nextends\n \nA\n \n{\n\n  \nvoid\n \nf\n()\n \n{\n \n    \nSystem\n.\nout\n.\nprintln\n(\n\"B f\"\n);\n \n  \n}\n\n\n}\n\n\n\nB\n \nb\n \n=\n \nnew\n \nB\n();\n\n\nb\n.\nf\n();\n\n\nA\n \na\n \n=\n \nb\n;\n\n\na\n.\nf\n();\n\n\na\n \n=\n \nnew\n \nA\n();\n\n\na\n.\nf\n();\n\n\n\n\n\n\n\n\n\n\n\nCan, or not? If can, print what?\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\nclass\n \nA\n \n{\n\n  \nvoid\n \nf\n()\n \n{\n \n    \nSystem\n.\nout\n.\nprintln\n(\n\"A f\"\n);\n \n  \n}\n\n\n}\n\n\n\nclass\n \nB\n \nextends\n \nA\n \n{\n\n  \nvoid\n \nf\n()\n \n{\n \n    \nsuper\n.\nf\n();\n \n    \nSystem\n.\nout\n.\nprintln\n(\n\"B f\"\n);\n\n  \n}\n\n\n}\n\n\n\nB\n \nb\n \n=\n \nnew\n \nB\n();\n\n\nb\n.\nf\n();\n\n\nA\n \na\n \n=\n \nb\n;\n\n\na\n.\nf\n();\n\n\n\n\n\n\n\n\n\n\n\nCan, or not? If can, print what?\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\nclass\n \nA\n \n{\n\n  \nvoid\n \nf\n()\n \n{\n \n    \nSystem\n.\nout\n.\nprintln\n(\n\"A f\"\n);\n \n  \n}\n\n\n}\n\n\n\nclass\n \nB\n \nextends\n \nA\n \n{\n\n  \nvoid\n \nf\n()\n \n{\n \n    \nthis\n.\nf\n();\n \n    \nSystem\n.\nout\n.\nprintln\n(\n\"B f\"\n);\n \n  \n}\n\n\n}\n\n\n\nB\n \nb\n \n=\n \nnew\n \nB\n();\n\n\nb\n.\nf\n();\n\n\nA\n \na\n \n=\n \nb\n;\n\n\na\n.\nf\n();\n\n\n\n\n\n\n\n\n\n\n\nCan, or not? If can, print what?\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\nclass\n \nA\n \n{\n\n  \nvoid\n \nf\n()\n \n{\n \n    \nSystem\n.\nout\n.\nprintln\n(\n\"A f\"\n);\n \n  \n}\n\n\n}\n\n\n\nclass\n \nB\n \nextends\n \nA\n \n{\n\n  \nint\n \nf\n()\n \n{\n \n    \nSystem\n.\nout\n.\nprintln\n(\n\"B f\"\n);\n \n    \nreturn\n \n0\n;\n\n  \n}\n\n\n}\n\n\n\nB\n \nb\n \n=\n \nnew\n \nB\n();\n\n\nb\n.\nf\n();\n\n\nA\n \na\n \n=\n \nb\n;\n\n\na\n.\nf\n();\n\n\n\n\n\n\n\n\n\n\n\nCan, or not? If can, print what?\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\nclass\n \nA\n \n{\n\n  \nvoid\n \nf\n()\n \n{\n \n    \nSystem\n.\nout\n.\nprintln\n(\n\"A f\"\n);\n \n  \n}\n\n\n}\n\n\n\nclass\n \nB\n \nextends\n \nA\n \n{\n\n  \nvoid\n \nf\n(\nint\n \nx\n)\n \n{\n \n    \nSystem\n.\nout\n.\nprintln\n(\n\"B f\"\n);\n \n    \nreturn\n \nx\n;\n\n  \n}\n\n\n}\n\n\n\nB\n \nb\n \n=\n \nnew\n \nB\n();\n\n\nb\n.\nf\n();\n\n\nb\n.\nf\n(\n0\n);\n\n\nA\n \na\n \n=\n \nb\n;\n\n\na\n.\nf\n();\n\n\na\n.\nf\n(\n0\n);\n\n\n\n\n\n\n\n\n\n\n\nCan, or not?  If can, what will be printed?\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\nclass\n \nA\n \n{\n\n  \npublic\n \nvoid\n \nf\n()\n \n{\n \n    \nSystem\n.\nout\n.\nprintln\n(\n\"A f\"\n);\n \n  \n}\n\n\n}\n\n\n\nclass\n \nB\n \nextends\n \nA\n \n{\n\n  \nvoid\n \nf\n()\n \n{\n \n    \nSystem\n.\nout\n.\nprintln\n(\n\"B f\"\n);\n \n  \n}\n\n\n}\n\n\n\nB\n \nb\n \n=\n \nnew\n \nB\n();\n\n\nA\n \na\n \n=\n \nb\n;\n\n\na\n.\nf\n();\n\n\nb\n.\nf\n();\n\n\n\n\n\n\n\n\n\n\n\nCan, or not?  If can, what will be printed?\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\nclass\n \nA\n \n{\n\n  \nprivate\n \nvoid\n \nf\n()\n \n{\n \n    \nSystem\n.\nout\n.\nprintln\n(\n\"A f\"\n);\n \n  \n}\n\n\n}\n\n\n\nclass\n \nB\n \nextends\n \nA\n \n{\n\n  \nvoid\n \nf\n()\n \n{\n \n    \nSystem\n.\nout\n.\nprintln\n(\n\"B f\"\n);\n \n  \n}\n\n\n}\n\n\n\nB\n \nb\n \n=\n \nnew\n \nB\n();\n\n\nA\n \na\n \n=\n \nb\n;\n\n\na\n.\nf\n();\n\n\nb\n.\nf\n();\n\n\n\n\n\n\n\n\n\n\n\nCan, or not?  If can, what will be printed?\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\nclass\n \nA\n \n{\n\n  \nprivate\n \nvoid\n \nf\n()\n \n{\n \n    \nSystem\n.\nout\n.\nprintln\n(\n\"A f\"\n);\n \n  \n}\n\n\n}\n\n\n\nclass\n \nB\n \nextends\n \nA\n \n{\n\n  \nvoid\n \nf\n()\n \n{\n \n    \nSystem\n.\nout\n.\nprintln\n(\n\"B f\"\n);\n \n  \n}\n\n\n}\n\n\n\nB\n \nb\n \n=\n \nnew\n \nB\n();\n\n\nA\n \na\n \n=\n \nb\n;\n\n\na\n.\nf\n();\n\n\nb\n.\nf\n();\n\n\n\n\n\n\n\n\n\n\n\nCan, or not?  If can, what will be printed?\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\nclass\n \nA\n \n{\n\n  \nstatic\n \nvoid\n \nf\n()\n \n{\n \n    \nSystem\n.\nout\n.\nprintln\n(\n\"A f\"\n);\n \n  \n}\n\n\n}\n\n\n\nclass\n \nB\n \nextends\n \nA\n \n{\n\n  \nvoid\n \nf\n()\n \n{\n \n    \nSystem\n.\nout\n.\nprintln\n(\n\"B f\"\n);\n \n  \n}\n\n\n}\n\n\n\nB\n \nb\n \n=\n \nnew\n \nB\n();\n\n\nA\n \na\n \n=\n \nb\n;\n\n\na\n.\nf\n();\n\n\nb\n.\nf\n();\n\n\n\n\n\n\n\n\n\n\n\nCan, or not?  If can, what will be printed?\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\nclass\n \nA\n \n{\n\n  \nstatic\n \nvoid\n \nf\n()\n \n{\n \n    \nSystem\n.\nout\n.\nprintln\n(\n\"A f\"\n);\n \n  \n}\n\n\n}\n\n\n\nclass\n \nB\n \nextends\n \nA\n \n{\n\n  \nstatic\n \nvoid\n \nf\n()\n \n{\n \n    \nSystem\n.\nout\n.\nprintln\n(\n\"B f\"\n);\n \n  \n}\n\n\n}\n\n\n\nB\n \nb\n \n=\n \nnew\n \nB\n();\n\n\nA\n \na\n \n=\n \nb\n;\n\n\nA\n.\nf\n();\n\n\nB\n.\nf\n();\n\n\na\n.\nf\n();\n\n\nb\n.\nf\n();",
            "title": "Review Qs"
        },
        {
            "location": "/reviews/index.html#review-questions",
            "text": "Can, or not?   1\n2\n3\n4\n5\n6 int   i ;  double   d ;  i   =   d ;  d   =   i ;  i   =   ( int )   d ;  d   =   ( double )   i ;      Can, or not?   1\n2\n3\n4\n5\n6 int   i ;  boolean   b ;  i   =   b ;  b   =   i ;  i   =   ( int )   b ;  b   =   ( boolean )   i ;      Can, or not?   1\n2\n3\n4\n5\n6\n7\n8 class   A   {  }  class   B   extends   A   {  }  A   a   =   new   B ();  B   b   =   new   A ();      Can, or not?    1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10 class   A   {  }  class   B   extends   A   {  }  A   a   =   new   A ();  B   b   =   new   B ();  b   =   ( B ) a ;  a   =   ( A ) b ;      Can, or not?    1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10 interface   I   {  }  class   A   implements   I   {  }  I   i1   =   new   I ();  I   i2   =   new   A ();  A   a1   =   i2 ;  A   a2   =   ( A ) i2 ;      Can, or not?    1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19 interface   I   {  }  interface   J   extends   I   {  }  class   A   implements   J   {  }  A   a   =   new   A ();  I   i   =   a ;  J   j   =   a ;  i   =   j ;  j   =   i ;  j   =   ( J ) i ;  a   =   i ;  a   =   j ;  a   =   ( A ) i ;  a   =   ( A ) j ;      Can, or not?    1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20 interface   I   {  }  interface   J   {  }  class   A   implements   I ,   J   {  }  A   a   =   new   A ();  I   i   =   a ;  J   j   =   a ;  i   =   j ;  j   =   i ;  j   =   ( J ) i ;  I   =   ( I ) j ;  a   =   i ;  a   =   j ;  a   =   ( A ) i ;  a   =   ( A ) j ;      Can, or not?    1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14 class   A   {  }  class   B   extends   A   {  }  class   C   extends   A   {  }  B   b   =   new   B ();  A   a   =   b ;  C   c   =   b ;  A   a   =   ( A ) b ;  C   c   =   ( C ) b ;      Can, or not? If can, print what?   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11 class   A   { \n   void   f ()   {   System . out . println ( \"A f\" );   }  }  class   B   extends   A   {  }  B   b   =   new   B ();  b . f ();  A   a   =   b ;  a . f ();      Can, or not? If can, print what?   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18 class   A   { \n   void   f ()   {  \n     System . out . println ( \"A f\" );  \n   }  }  class   B   extends   A   { \n   void   f ()   {  \n     System . out . println ( \"B f\" );  \n   }  }  B   b   =   new   B ();  b . f ();  A   a   =   b ;  a . f ();  a   =   new   A ();  a . f ();      Can, or not? If can, print what?   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17 class   A   { \n   void   f ()   {  \n     System . out . println ( \"A f\" );  \n   }  }  class   B   extends   A   { \n   void   f ()   {  \n     super . f ();  \n     System . out . println ( \"B f\" ); \n   }  }  B   b   =   new   B ();  b . f ();  A   a   =   b ;  a . f ();      Can, or not? If can, print what?   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17 class   A   { \n   void   f ()   {  \n     System . out . println ( \"A f\" );  \n   }  }  class   B   extends   A   { \n   void   f ()   {  \n     this . f ();  \n     System . out . println ( \"B f\" );  \n   }  }  B   b   =   new   B ();  b . f ();  A   a   =   b ;  a . f ();      Can, or not? If can, print what?   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17 class   A   { \n   void   f ()   {  \n     System . out . println ( \"A f\" );  \n   }  }  class   B   extends   A   { \n   int   f ()   {  \n     System . out . println ( \"B f\" );  \n     return   0 ; \n   }  }  B   b   =   new   B ();  b . f ();  A   a   =   b ;  a . f ();      Can, or not? If can, print what?   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19 class   A   { \n   void   f ()   {  \n     System . out . println ( \"A f\" );  \n   }  }  class   B   extends   A   { \n   void   f ( int   x )   {  \n     System . out . println ( \"B f\" );  \n     return   x ; \n   }  }  B   b   =   new   B ();  b . f ();  b . f ( 0 );  A   a   =   b ;  a . f ();  a . f ( 0 );      Can, or not?  If can, what will be printed?   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16 class   A   { \n   public   void   f ()   {  \n     System . out . println ( \"A f\" );  \n   }  }  class   B   extends   A   { \n   void   f ()   {  \n     System . out . println ( \"B f\" );  \n   }  }  B   b   =   new   B ();  A   a   =   b ;  a . f ();  b . f ();      Can, or not?  If can, what will be printed?   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16 class   A   { \n   private   void   f ()   {  \n     System . out . println ( \"A f\" );  \n   }  }  class   B   extends   A   { \n   void   f ()   {  \n     System . out . println ( \"B f\" );  \n   }  }  B   b   =   new   B ();  A   a   =   b ;  a . f ();  b . f ();      Can, or not?  If can, what will be printed?   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16 class   A   { \n   private   void   f ()   {  \n     System . out . println ( \"A f\" );  \n   }  }  class   B   extends   A   { \n   void   f ()   {  \n     System . out . println ( \"B f\" );  \n   }  }  B   b   =   new   B ();  A   a   =   b ;  a . f ();  b . f ();      Can, or not?  If can, what will be printed?   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16 class   A   { \n   static   void   f ()   {  \n     System . out . println ( \"A f\" );  \n   }  }  class   B   extends   A   { \n   void   f ()   {  \n     System . out . println ( \"B f\" );  \n   }  }  B   b   =   new   B ();  A   a   =   b ;  a . f ();  b . f ();      Can, or not?  If can, what will be printed?   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18 class   A   { \n   static   void   f ()   {  \n     System . out . println ( \"A f\" );  \n   }  }  class   B   extends   A   { \n   static   void   f ()   {  \n     System . out . println ( \"B f\" );  \n   }  }  B   b   =   new   B ();  A   a   =   b ;  A . f ();  B . f ();  a . f ();  b . f ();",
            "title": "Review Questions"
        },
        {
            "location": "/style/index.html",
            "text": "CS2030 Java Style Guide\n\n\nWhy Coding Style is Important\n\n\nOne of the goals of CS2030 is to move you away from the mindset that you are writing code that you will discard after it is done (e.g., in CS1010 labs) and you are writing code that noone else will read except you.  CS2030 prepares you to work in a software engineering teams in many ways, and one of the ways is to enforce a consistent coding style.\n\n\nIf everyone on the team follows the same style, the intend of the programmer can become clear (e.g., is this a class or a field?), the code is more readable and less bug prone (e.g., the \nApple \ngoto fail\n bug\n).  Empirical studies support this:\n\n\n\n\nQuote\n\n\n\"It is not merely a matter of aesthetics that programs should be written in a particular style. Rather there is a psychological basis for writing programs in a conventional manner: programmers have strong expectations that other programmers will follow these discourse rules. If the rules are violated, then the utility afforded by the expectations that programmers have built up over time is effectively nullified. The results from the experiments with novice and advanced student programmers and with professional programmers described in this paper provide clear support for these claims.\"\n\n\nElliot Soloway and Kate Ehrlich. \"Empirical studies of programming knowledge.\" IEEE Transactions on Software Engineering 5 (1984): 595-609.\n\n\n\n\nMany major companies enforce coding styles, and some have published them.  For CS2030, we base our (simplified) coding style on \nGoogle's Java Coding Style\n.  You should bookmark the link because you need to come back to it again and again.\n\n\nCS2030 Coding Style\n\n\n\n\n\n\nNo tab\n    Use only whitespace.  \n\n\nFor \nvim\n users, you can add the following line in your \n~/.vimrc\n file:\n\n1\nset expandtab\n\n\n\n\nSo that when you press \n it is expanded to whitespace.\n\n\nMost other source code editors have similar configuration.  \n\n\n\n\n\n\nExactly one blank line after import statements and exactly one top-level (i.e., non-nested) class.\n\n\n\n\n\n\nEach top-level class resides in a source file of its own.\n\n\n\n\n\n\nWhen a class has overladed methods (e.g., multiple constructors or methods of the same name), they appear sequentially with no other code in between.\n\n\n\n\n\n\nBraces are always used (even if the body is empty or contains a single statement}\n\n\n\n\n\n\nUse \"Egyptian brackets\": \n\n\n\n\nOpening brace have no line break before; but has line break after\n\n\nClosing brace has a line break before; and has a line break after (except when there is \nelse\n or comma following a closing brace.\n\n\n\n\nExample:\n\n1\n2\n3\n   \nif\n \n(\nx\n \n==\n \n0\n)\n \n{\n\n     \nx\n++;\n\n   \n}\n \n\n\n\n\n\nis good.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n   \nif\n \n(\nx\n \n==\n \n0\n)\n \n{\n \nx\n++;\n \n}\n\n   \nif\n \n(\nx\n \n==\n \n0\n)\n \n   \n{\n\n     \nx\n++;\n\n   \n}\n\n   \nif\n \n(\nx\n \n==\n \n0\n)\n \n   \n{\n\n     \nx\n++;\n \n}\n\n\n\n\n\n\n\nare not good.\n\n\n\n\n\n\nBlock indentation is exactly two spaces.\n\n\n1\n2\n3\n4\n5\n6\nif\n \n(\nx\n \n==\n \n0\n)\n \n{\n \n  \nx\n++;\n\n  \nfor\n \n(\ni\n \n=\n \n0\n;\n \ni\n \n<\n \nx\n;\n \ni\n++)\n \n{\n\n    \nx\n \n+=\n \ni\n;\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nFor \nvim\n users, in \n~/.vimrc\n, add the following:\n\n1\n2\n3\n4\nset tabstop=2\nset shiftwidth=2\nset autoindent\nset smartindent\n\n\n\n\n\nTo help you with indentation.\n\n\nMost other source code editors have similar configuration.  \n\n\n\n\n\n\nEach statement is followed by a line break, no matter how short the statement is.\n\n\n1\n  \nx\n++;\n \ni\n++;\n\n\n\n\n\nis bad.\n\n1\n2\n  \nx\n++;\n \n  \ni\n++;\n\n\n\n\n\nis good.\n\n\n\n\n\n\nEach line is limited to 80 characters in length.  You can break a long\nline into multiple lines to enhance readability, this is called \nline wrapping\n.  When you do so, each continuation line is indented at least 4 spaces from the original line.\n\n\n1\nSystem\n.\nout\n.\nprintln\n(\n\"Daenerys of the House Targaryen, the First of Her Name, The Unburnt, Queen of the Andals, the Rhoynar and the First Men, Queen of Meereen, Khaleesi of the Great Grass Sea, Protector of the Realm, Lady Regnant of the Seven Kingdoms, Breaker of Chains and Mother of Dragon\"\n);\n\n\n\n\n\n\n\nis bad.\n\n\n1\n2\n3\n4\n5\nSystem\n.\nout\n.\nprintln\n(\n\"Daenerys of the House Targaryen, the First of\"\n \n+\n\n\n\" Her Name, The Unburnt, Queen of the Andals, the Rhoynar and the\"\n \n+\n\n\n\" First Men, Queen of Meereen, Khaleesi of the Great Grass Sea, P\"\n \n+\n\n\n\"rotector of the Realm, Lady Regnant of the Seven Kingdoms, Break\"\n \n+\n\n\n\"er of Chains and Mother of Dragon\"\n);\n\n\n\n\n\n\n\nis also bad.\n\n\n1\n2\n3\n4\n5\n6\nSystem\n.\nout\n.\nprintln\n(\n\"Daenerys of the House Targaryen,\"\n \n+\n \n    \n\"the First of Her Name, The Unburnt, Queen of the Andals,\"\n \n+\n\n    \n\"the Rhoynar and the First Men, Queen of Meereen,\"\n \n+\n\n    \n\"Khaleesi of the Great Grass Sea, Protector of the Realm,\"\n \n+\n\n    \n\"Lady Regnant of the Seven Kingdoms, Breaker of Chains and\"\n \n+\n\n    \n\"Mother of Dragon\"\n);\n\n\n\n\n\nis ok.\n\n\n\n\n\n\nThere should be a blank line between constructors, methods, nested classes and static initializers.  Blank lines can be used between fields to create logical groupings.\n\n\n\n\n\n\nWhite space should separate Java keywords from parenthesis and braces, and be added on both sides of binary operators (\n+\n, \n-\n, \n/\n, etc) as well as \n:\n in enhanced for.  Space should also appears before and after \n//\n comments\n\n\n1\n2\n3\n4\n5\n6\nif\n(\nx\n==\n0\n){\n \n  \nx\n++;\n//to make sure x is at least one.\n\n  \nfor\n(\ni\n=\n0\n;\ni\n<\nx\n;\ni\n++){\n\n    \nx\n+=\ni\n;\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nis bad.\n\n\n1\n2\n3\n4\n5\n6\nif\n \n(\nx\n \n==\n \n0\n)\n \n{\n \n  \nx\n++;\n \n// to make sure x is at least one.\n\n  \nfor\n \n(\ni\n \n=\n \n0\n;\n \ni\n \n<\n \nx\n;\n \ni\n++)\n \n{\n\n    \nx\n \n+=\n \ni\n;\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nis good.\n\n\n\n\n\n\nOne variable per declaration.  \n\n\n1\nint\n \nx\n,\n \ny\n;\n\n\n\n\n\n\n\nbad.\n\n\n1\n2\nint\n \nx\n;\n\n\nint\n \ny\n;\n\n\n\n\n\n\n\ngood!\n\n\n\n\n\n\nNo C-style array declaration\n\n\n1\nString\n \nargs\n[];\n\n\n\n\n\n\n\nnot good.\n\n\n1\nString\n[]\n \nargs\n;\n\n\n\n\n\n\n\ngood!\n\n\n\n\n\n\nSwitch statement always include a \ndefault\n case.\n\n\n\n\n\n\nOne annotation per line.  Always use \n@Override\n.\n\n\n1\n2\n3\n4\n@Override\n\n\npublic\n \nboolean\n \nequals\n(\nObject\n \no\n)\n \n{\n\n  \n:\n\n\n}\n\n\n\n\n\n\n\n\n\n\n\nIndent comments at the same level as the surrounding code.  For multiple comments, align \n*\n with the previous line.\n\n\n1\n2\n3\n4\n5\n6\n/*\n\n\n* Not a good style\n\n\n*/\n\n\n/*\n\n\n * Good style\n\n\n */\n\n\n\n\n\n\n\n\n\n\n\nClass modifier appears in the following order:\n\n\n1\npublic\n \nprotected\n \nprivate\n \nabstract\n \ndefault\n \nstatic\n \nfinal\n \ntransient\n \nvolatile\n \nsynchronized\n \nnative\n \nstrictfp\n\n\n\n\n\n\n\nExample:\n\n1\nstatic\n \npublic\n \nvoid\n \nmain\n(\nString\n[]\n \nargs\n)\n\n\n\n\n\nis bad.\n\n1\npublic\n \nstatic\n \nvoid\n \nmain\n(\nString\n[]\n \nargs\n)\n\n\n\n\n\nis good!\n\n\n\n\n\n\nClass names are writte in UpperCamelCase, method names and field names in lowerCamelCase, constant names in ALL_CAPS_SNAKE_CASE.  Type parameters in single capital letter.\n\n\n\n\n\n\nCaught exceptions should not be ignored.\n\n\n\n\n\n\nStatic fields and methods must be accessed with class name.",
            "title": "Coding Style"
        },
        {
            "location": "/style/index.html#cs2030-java-style-guide",
            "text": "",
            "title": "CS2030 Java Style Guide"
        },
        {
            "location": "/style/index.html#why-coding-style-is-important",
            "text": "One of the goals of CS2030 is to move you away from the mindset that you are writing code that you will discard after it is done (e.g., in CS1010 labs) and you are writing code that noone else will read except you.  CS2030 prepares you to work in a software engineering teams in many ways, and one of the ways is to enforce a consistent coding style.  If everyone on the team follows the same style, the intend of the programmer can become clear (e.g., is this a class or a field?), the code is more readable and less bug prone (e.g., the  Apple  goto fail  bug ).  Empirical studies support this:   Quote  \"It is not merely a matter of aesthetics that programs should be written in a particular style. Rather there is a psychological basis for writing programs in a conventional manner: programmers have strong expectations that other programmers will follow these discourse rules. If the rules are violated, then the utility afforded by the expectations that programmers have built up over time is effectively nullified. The results from the experiments with novice and advanced student programmers and with professional programmers described in this paper provide clear support for these claims.\"  Elliot Soloway and Kate Ehrlich. \"Empirical studies of programming knowledge.\" IEEE Transactions on Software Engineering 5 (1984): 595-609.   Many major companies enforce coding styles, and some have published them.  For CS2030, we base our (simplified) coding style on  Google's Java Coding Style .  You should bookmark the link because you need to come back to it again and again.",
            "title": "Why Coding Style is Important"
        },
        {
            "location": "/style/index.html#cs2030-coding-style",
            "text": "No tab\n    Use only whitespace.    For  vim  users, you can add the following line in your  ~/.vimrc  file: 1 set expandtab  \nSo that when you press   it is expanded to whitespace.  Most other source code editors have similar configuration.      Exactly one blank line after import statements and exactly one top-level (i.e., non-nested) class.    Each top-level class resides in a source file of its own.    When a class has overladed methods (e.g., multiple constructors or methods of the same name), they appear sequentially with no other code in between.    Braces are always used (even if the body is empty or contains a single statement}    Use \"Egyptian brackets\":    Opening brace have no line break before; but has line break after  Closing brace has a line break before; and has a line break after (except when there is  else  or comma following a closing brace.   Example: 1\n2\n3     if   ( x   ==   0 )   { \n      x ++; \n    }     is good.  1\n2\n3\n4\n5\n6\n7\n8     if   ( x   ==   0 )   {   x ++;   } \n    if   ( x   ==   0 )  \n    { \n      x ++; \n    } \n    if   ( x   ==   0 )  \n    { \n      x ++;   }    are not good.    Block indentation is exactly two spaces.  1\n2\n3\n4\n5\n6 if   ( x   ==   0 )   {  \n   x ++; \n   for   ( i   =   0 ;   i   <   x ;   i ++)   { \n     x   +=   i ; \n   }  }    For  vim  users, in  ~/.vimrc , add the following: 1\n2\n3\n4 set tabstop=2\nset shiftwidth=2\nset autoindent\nset smartindent   To help you with indentation.  Most other source code editors have similar configuration.      Each statement is followed by a line break, no matter how short the statement is.  1    x ++;   i ++;   \nis bad. 1\n2    x ++;  \n   i ++;   \nis good.    Each line is limited to 80 characters in length.  You can break a long\nline into multiple lines to enhance readability, this is called  line wrapping .  When you do so, each continuation line is indented at least 4 spaces from the original line.  1 System . out . println ( \"Daenerys of the House Targaryen, the First of Her Name, The Unburnt, Queen of the Andals, the Rhoynar and the First Men, Queen of Meereen, Khaleesi of the Great Grass Sea, Protector of the Realm, Lady Regnant of the Seven Kingdoms, Breaker of Chains and Mother of Dragon\" );    is bad.  1\n2\n3\n4\n5 System . out . println ( \"Daenerys of the House Targaryen, the First of\"   +  \" Her Name, The Unburnt, Queen of the Andals, the Rhoynar and the\"   +  \" First Men, Queen of Meereen, Khaleesi of the Great Grass Sea, P\"   +  \"rotector of the Realm, Lady Regnant of the Seven Kingdoms, Break\"   +  \"er of Chains and Mother of Dragon\" );    is also bad.  1\n2\n3\n4\n5\n6 System . out . println ( \"Daenerys of the House Targaryen,\"   +  \n     \"the First of Her Name, The Unburnt, Queen of the Andals,\"   + \n     \"the Rhoynar and the First Men, Queen of Meereen,\"   + \n     \"Khaleesi of the Great Grass Sea, Protector of the Realm,\"   + \n     \"Lady Regnant of the Seven Kingdoms, Breaker of Chains and\"   + \n     \"Mother of Dragon\" );   \nis ok.    There should be a blank line between constructors, methods, nested classes and static initializers.  Blank lines can be used between fields to create logical groupings.    White space should separate Java keywords from parenthesis and braces, and be added on both sides of binary operators ( + ,  - ,  / , etc) as well as  :  in enhanced for.  Space should also appears before and after  //  comments  1\n2\n3\n4\n5\n6 if ( x == 0 ){  \n   x ++; //to make sure x is at least one. \n   for ( i = 0 ; i < x ; i ++){ \n     x += i ; \n   }  }    is bad.  1\n2\n3\n4\n5\n6 if   ( x   ==   0 )   {  \n   x ++;   // to make sure x is at least one. \n   for   ( i   =   0 ;   i   <   x ;   i ++)   { \n     x   +=   i ; \n   }  }    is good.    One variable per declaration.    1 int   x ,   y ;    bad.  1\n2 int   x ;  int   y ;    good!    No C-style array declaration  1 String   args [];    not good.  1 String []   args ;    good!    Switch statement always include a  default  case.    One annotation per line.  Always use  @Override .  1\n2\n3\n4 @Override  public   boolean   equals ( Object   o )   { \n   :  }      Indent comments at the same level as the surrounding code.  For multiple comments, align  *  with the previous line.  1\n2\n3\n4\n5\n6 /*  * Not a good style  */  /*   * Good style   */      Class modifier appears in the following order:  1 public   protected   private   abstract   default   static   final   transient   volatile   synchronized   native   strictfp    Example: 1 static   public   void   main ( String []   args )   \nis bad. 1 public   static   void   main ( String []   args )   \nis good!    Class names are writte in UpperCamelCase, method names and field names in lowerCamelCase, constant names in ALL_CAPS_SNAKE_CASE.  Type parameters in single capital letter.    Caught exceptions should not be ignored.    Static fields and methods must be accessed with class name.",
            "title": "CS2030 Coding Style"
        },
        {
            "location": "/lec1/index.html",
            "text": "Lecture 1: Abstraction and Encapsulation\n\n\nLearning Objectives\n\n\nAfter this lecture, students should:\n\n\n\n\nrecap some fundamental programming concepts, including the execution model of a program, abstractions over code and data, primitive and composite data types.\n\n\nappreciate the importance of maintaining abstraction barrier in software development\n\n\nunderstand the differences between statically and dynamically typed languages\n\n\nunderstand the concepts of object-oriented programming, including encapsulation, data hiding, fields and methods, constructors, mutators/accessors, classes and objects, and their purposes of introducing them as a method of programming.\n\n\nknow the purpose and usage of Java keywords \nclass\n, \npublic\n, \nprivate\n, \nfinal\n, \nstatic\n, \nimport\n, \nnew\n\n\nbe able to build a mental model for how an object is represented in Java\n\n\n\n\nWhat Exactly is a \nProgram\n?\n\n\nA program is a set of instructions we issue to computers to manipulate data.  A programming language is a formal language that helps programmers specify precisely what are the instructions we issue to computers, using code that are often made up of keywords, symbols, and names.  Computers execute the instructions in their \nprocessing units\n, and store the instructions and data in their \nmemory\n1\n.  The processing units recognizes the instructions based on the specific patterns of bits and manipulate data as a sequence of bits.  A programming language, however, is written at a higher level of \nabstraction\n (i.e., at a higher conceptual level), so that as a programmer, we only need to write a few lines of code to give complex instructions to the computer.  A \ncompiler\n or \ninterpreter\n is responsible for translating these programs written in high level language to \nassembly code\n or \nmachine code\n, i.e., bit patterns that the processing units can understand.\n\n\nThere are thousands of programming languages in existence.  \nC\n is one of the languages that is a \nlow-level language\n -- i.e., it provides very thin layer of abstractions on top of machine code.  On the other hand, languages such as \nPython\n and \nJavaScript\n are high-level languages.  As an example, in C, you can directly manage memory allocation.  In JavaScript and Python, you cannot.\n\n\nAbstraction: Variable and Type\n\n\nOne of the important abstractions that is provided by a programming language is \nvariable\n.  Data are stored in some location in the computer memory.  But we should not be referring to the memory location all the time.  First, referring to something like \n0xFA49130E\n is not user-friendly; Second, the location may change.  A \nvariable\n is an abstraction that allows us to give a user friendly name to memory location.  We use the \nvariable name\n whenever we want to access the \nvalue\n in that location, and \npointer to the variable\n or \nreference to the variable\n whenever we want to refer to the address of the location.\n\n\nLet's think a bit more about how sequence of bits is abstracted as data in a programming language.  At the machine level, these bits are just, well, bits.  We give the bits a \nsemantic\n at the program level, e.g., we want to interpret the sequence of bits as numbers, letters, etc.  E.g., the number (integer, to be exact) \n65\n and the letter \nA\n all share the same sequence of bits \n0100 00011\n but are interpreted differently and possibly manipulated differently.  \n\n\nThe \ntype\n of a variable tells the compiler how to interpret the variable and how to manipulate the variable.  \n\n\nFor instance, supposed that in Python, if you have two variables \nx\n and \ny\n storing the values \n4\n and \n5\n respectively, if you \nprint x + y\n, you may get \n45\n if \nx\n and \ny\n are strings, or you may get \n9\n if \nx\n and \ny\n are integers, or you may get an error if \n4\n is an integer and \n5\n is a string.  \n\n\nIn the last instance above, you see that assigning types of variables helps to keep the program meaningful, as the operation \n+\n is not defined over an integer and a string in Python\n2\n.\n\n\nPython is a \ndynamically typed\n language.  The same variable can hold values of different types, and checking if the right type is used is done during the execution of the program.  Note that, the type is associated with the \nvalues\n, and the type of the variable changes depending on the value it holds.\n\n\nC, on the other hand, is a \nstatically typed\n language.  We need to \ndeclare\n every variable we use in the program and specify its type.  A variable can only hold values of the same type as the type of the variable, so we can't assign, for instance, a string to a variable of type \nint\n.  We check if the right type is used during the compilation of the program.\n\n\n1\n2\nint\n \nx\n \n=\n \n4\n;\n \n// ok\n\n\nint\n \ny\n \n=\n \n\"5\"\n;\n \n// error\n\n\n\n\n\n\n\nBy annotating each variable with its type, the C compiler also knows how much memory space is needed to store a variable.  \n\n\nAbstraction: Functions\n\n\nAnother important abstraction provided by a programming language is \nfunction\n (or \nprocedure\n).  This abstraction allows programmers to group a set of instructions and give it a name.  The named set of instructions may take one or more variables as input parameters, and return one or more values.   \n\n\nLike all other abstractions, defining functions allow us to think at a higher conceptual level.  By composing functions at increasingly higher level of abstractions, we can build programs with increasing level of complexity.\n\n\nDefining functions allow us to abstract away the implementation details from the caller.  Once a function is defined, we can change the way the function is implemented without affecting the code that calls the function, as long as the semantic and the \ninterface\n of the function remains the same.\n\n\nFunctions therefore is a critical mechanism for achieving \nseparation of concerns\n in a program.  We separate the concerns about how a particular function is implemented, from the concerns about how the function is used to perform a higher-level task.\n\n\nDefining functions also allow us to \nreuse\n code.  We do not have to repeatedly write the same chunk of code if we group the sequence of code into a function -- then we just need to call the function to invoke this sequence of code every time we need it.  If this chunk of code is properly written and debugged, then we can be pretty sure that everywhere the function is invoked, the code is correct\n3\n.\n\n\nC is a \nprocedural language\n.  A C program consists of functions, with the \nmain()\n function serves as the entry point to the program.  Since C is a statically type language, a C function has a return type, and each  function parameter (or \nargument\n) has a type as well.  (Note that this statement does not mean that C function must return a \nvalue\n.  If the function does not return a value, we define its return type as \nvoid\n.)\n\n\nRecall that the bits representing the instructions are also stored in the computer memory in a separate area from the data.  The group of instructions that belongs to the same function are stored together.  Just like we can refer to a variable using its memory address using its \nreference\n (or \npointer\n), we can refer to a function using the memory address of the entry point to the function.\n\n\nAbstraction: Composite Data type\n\n\nJust like functions allow programmers to group instructions, give it a name, and refer to it later, a \ncomposite data type\n allow programers to group \nprimitive types\n together, give it a name (a new type), and refer to it later.  This is another powerful abstraction in programming languages that help us to think at a higher conceptual level without worrying about the details.   Commonly used examples are mathematical objects such as complex numbers, 2D data points, multi-dimensional vectors, circles, etc, or everyday objects such as a person, a product, etc.\n\n\nDefining composite data type allows programmers to abstract away (and be separated from the concern of) how a complex data type is represented.\n\n\nFor instance, a circle on a 2D plane can be represented by the center (\nx\n, \ny\n) and its radius \nr\n, or it can be represented by the top left corner (\nx\n,\ny\n) and the width \nw\n of the bounding square.\n\n\nIn C, we build composite data type with \nstruct\n.  For example,\n\n\n1\n2\n3\n4\nstruct\n \ncircle\n \n{\n\n  \nfloat\n \nx\n,\n \ny\n;\n \n// (x,y) coordinate of the center.\n\n  \nfloat\n \nr\n;\n \n// radius\n\n\n}\n\n\n\n\n\n\n\nOnce we have the \nstruct\n defined, we are not completely shielded from its representation, until we write a set of functions that operates on the \ncircle\n composite type.  For instance,\n\n\n1\n2\n3\nfloat\n \ncircle_area\n(\ncircle\n \nc\n)\n \n{\n \n...\n \n};\n\n\nbool\n  \ncircle_contains_point\n(\ncircle\n \nc\n,\n \npoint\n \np\n)\n \n{\n \n...\n \n};\n\n  \n:\n\n\n\n\n\n\n\nImplementation of these functions obvious requires knowledge of how a circle is represented.  Once the set of functions that operates on and manipulate circles are available, we can use \ncircle\n type without worrying about the internal representation.  \n\n\nIf we decided to change the representation of a circle, then only the set of functions that operates on a circle type need to be changed, but not the code that uses circles to do other things.\n\n\nWe can imagine an \nabstraction barrier\n between the code that uses a composite data type along with its associated set of functions, and the code that define the data type along with the implementation of the functions.  Above the barrier, the concern is about using the composite data type to do useful things, while below the barrier, the concern is about how to represent and manipulate the composite data type.\n\n\nAbstraction: Class and Object (or, Encapsulation)\n\n\nWe can further bundle the composite data type and its associated functions together in another abstraction, called a \nclass\n.  A class is a data type with a group of functions associated with it.  We call the functions as \nmethods\n and the data in the class as \nfields\n (or \nmembers\n, or \nstates\n, or \nattributes\n4\n).   A well-designed class maintain the abstraction barrier, properly wrapped the barrier around the internal representation and implementation, and exposes just the right interface for others to use.\n\n\nJust like we can create variables of a given type, we can create \nobjects\n of a given class.  Objects are instances of a class, each allowing the same methods to be called, and each containing the same set of variables of the same types, but (possibly) storing different values.\n\n\nRecall that programs written in a procedural language such as a C consists of functions, with a \nmain()\n function as the entry point.  A program written in an \nobject-oriented language\n such as Java consists of classes, with one main class as the entry point.  One can view a running object-oriented (or OO) program as something that instantiates objects of different classes and orchestrates their interactions with each other by calling each others' methods.\n\n\nOne could argue that an object-oriented way of writing programs is much more natural, as it mirrors our world more closely.  If we look around us, we see objects all around us, and each object has a certain behavior and they allow certain actions.  We interact with the objects through their interfaces, and we rarely need to know the internals of the objects we used everyday (unless we try to repair it)\n5\n.  \n\n\nThis concept, of keeping the all the data and functions operating on the data related to a composite data type together within an abstraction barrier, is called \nencapsulation\n.\n\n\nBreaking the Abstraction Barrier\n\n\nIn the ideal case, the code above the abstraction barrier would just call the provided interface to use the composite data type.  There, however, may be cases where a programmer may intentionally or accidentally break the abstraction barrier.  \n\n\nConsider the case of implementing \ncircle\n as a C \nstruct\n.  Suppose someone wants to move the center of the circle \nc\n to a new position (\nx\n, \ny\n), instead of implementing a function \ncircle_move_to(c, x, y)\n (which would still keep the representation used under the barrier), the person wrote:\n\n\n1\n2\nc\n.\nx\n \n=\n \nx\n;\n\n\nc\n.\ny\n \n=\n \ny\n;\n\n\n\n\n\n\n\nThis code would still be correct, but the abstraction barrier is broken since we now make explicit assumption that there are two variables \nx\n and \ny\n inside the \ncircle\n data type that correspond to the center of the circle.  If one day, we want to represent a circle in a different way, then we have to carefully change all the code that read and write these variables \nx\n and \ny\n and update them.\n\n\n\n\nBreaking Python's Abstraction Barrier\n\n\nPython tries to prevent \naccidental\n access to internal representation by having a convention of prefixing the internal variables with \n_\n (one underscore) or \n__\n (two underscores).   This method, however, does not prevent a lazy programmer from directly accessing the variables and possibly planting a bug / error that will surface later.\n\n\n\n\nData Hiding\n\n\nMany OO languages allow programmers to explicitly specify if a field or a method can be accessed from outside the abstraction barrier.  Java, for instance, support \nprivate\n and \npublic\n access modifiers\n5\n.  A field or a method that is declared as \nprivate\n cannot be accessed from outside the class, and can only be accessed within the class.  On the other hand, as you can guess, a \npublic\n field or method can be accessed, modified, or invoked from outside the class.\n\n\nSuch mechanism to protect the abstraction barrier from being broken is called \ndata hiding\n or \ninformation hiding\n.  This protection is enforced in the \ncompiler\n during compile time.\n\n\nExample: The Circle class\n\n\nLet's put together the concepts of encapsulation, data hiding to define a \nCircle\n class in Java:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n/**\n\n\n * A Circle object encapsulates a circle on a 2D plane.  \n\n\n */\n\n\nclass\n \nCircle\n \n{\n\n  \nprivate\n \ndouble\n \nx\n;\n  \n// x-coordinate of the center\n\n  \nprivate\n \ndouble\n \ny\n;\n  \n// y-coordinate of the center\n\n  \nprivate\n \ndouble\n \nr\n;\n  \n// the length of the radius\n\n\n  \n/**\n\n\n   * Return the area of the circle.\n\n\n   */\n\n  \npublic\n \ndouble\n \ngetArea\n()\n \n{\n\n    \nreturn\n \n3.1415926\n*\nr\n*\nr\n;\n\n  \n}\n\n\n  \n/**\n\n\n   * Move the center of the circle to the new position (newX, newY)\n\n\n   */\n\n  \npublic\n \nvoid\n \nmoveTo\n(\ndouble\n \nnewX\n,\n \ndouble\n \nnewY\n)\n \n{\n\n    \nx\n \n=\n \nnewX\n;\n\n    \ny\n \n=\n \nnewY\n;\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nThe class above is still missing many essential components, and not a complete program.\n\n\nConstructors, Accessors, and Mutators\n\n\nWith data hiding, we completely isolate the internals representation of a class using an abstraction barrier.  With no way for the user of the class to modify the fields directly, it is common for a class to provide methods to initialize and modify these internal fields (such as the \nmoveTo()\n method above).  A method that initializes an object is called a \nconstructor\n, and a method that retrieves or modifies the properties of the object is called the \naccessor\n (or \ngetter\n) or \nmutator\n (or \nsetter\n).\n\n\nA constructor method is a special method within the class.  It cannot be called directly, but is invoked automatically when an object is instantiated.   In Java, a constructor method has the same name as the class and has no return type.  A constructor can take in arguments just like other functions.  The class \nCircle\n can have a constructor such as the following:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\nclass\n \nCircle\n \n{\n\n    \n:\n\n  \n/**\n\n\n   * Create a circle centered on (centerX, centerY) with given radius\n\n\n  */\n\n  \npublic\n \nCircle\n(\ndouble\n \ncenterX\n,\n \ndouble\n \ncenterY\n,\n \ndouble\n \nradius\n)\n \n{\n\n    \nx\n \n=\n \ncenterX\n;\n\n    \ny\n \n=\n \ncenterY\n;\n\n    \nr\n \n=\n \nradius\n;\n\n  \n}\n\n    \n:\n\n\n}\n\n\n\n\n\n\n\nThe use of accessor and mutator methods is a bit controversial.   Suppose that we provide an accessor method and a mutator method for every private field, then we are actually exposing the internal representation, therefore breaking the encapsulation.  For instance:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\nclass\n \nCircle\n \n{\n\n    \n:\n\n\n  \npublic\n \ndouble\n \ngetX\n()\n \n{\n\n    \nreturn\n \nx\n;\n\n  \n}\n\n\n  \npublic\n \nvoid\n \nsetX\n(\ndouble\n \nnewX\n)\n \n{\n\n    \nx\n \n=\n \nnewX\n;\n\n  \n}\n\n\n  \npublic\n \ndouble\n \ngetY\n()\n \n{\n\n    \nreturn\n \ny\n;\n\n  \n}\n\n\n  \npublic\n \nvoid\n \nsetY\n(\ndouble\n \nnewY\n)\n \n{\n\n    \ny\n \n=\n \nnewY\n:\n\n  \n}\n\n\n  \npublic\n \ndouble\n \ngetR\n()\n \n{\n\n    \nreturn\n \nr\n;\n\n  \n}\n\n\n  \npublic\n \nvoid\n \nsetR\n(\ndouble\n \nnewR\n)\n \n{\n\n    \nr\n \n=\n \nnewR\n;\n\n  \n}\n\n    \n:\n\n\n}\n\n\n\n\n\n\n\nThe examples above are pretty pointless.  If we need to know the internal and do something with it, we are doing it wrong.  The right approach is to implement a method within the class that do whatever we want the class to do.   For instance, suppose that we want to know the circumference of the circle, one approach would be:\n\n\n1\n   \ndouble\n \ncircumference\n \n=\n \n2\n*\nc\n.\ngetR\n()*\n3.1415926\n;\n\n\n\n\n\n\n\nwhere c is a \nCircle\n object.\n\n\nA better approach would be to add a new method \ngetCircumference()\n in the \nCircle\n class, and call this instead:\n\n1\n   \ndouble\n \ncircumference\n \n=\n \nc\n.\ngetCircumference\n();\n\n\n\n\n\n\nThe better approach involves writing more lines of code, but it keeps the encapsulation in tact.\n\n\n\n\nConstructor in Python and JavaScript\n\n\nIn Python, the constructor is the \n__init__\n method.   In JavaScript, the constructor is simply called \nconstructor\n.\n\n\n\n\nClass Fields and Methods\n\n\nLet's look at the implementation of \ngetArea()\n above.  We use the constant \n\\(\\pi\\)\n but hardcoded it as 3.1415926.  Hardcoding such a magic number is a \nno no\n in terms of coding style.  This constant can appear in more than one places, and if we hardcode such a number, and want to change the precision of it later, we would need to trace down and change every occurrence.  Not only this introduces more work, but likely to introduce bugs.  \n\n\nIn C, we define it as a macro constant \nM_PI\n.  But how should we do this in Java?  This is where the ideal that a program consists of only objects with internal states that communicate with each other feel a bit constraining.  The constant \n\\(\\pi\\)\n is universal, and not really belong to any object (the value of Pi is the same for every circle!).  If we start to define a method \nsqrt()\n that computes the square root of a given number, this is a general function that is not associated with any object as well.\n\n\nA solution to this is to associate these global values and functions with a \nclass\n instead of with an \nobject\n.  For instance. Java predefines a \nMath\n class\n6\n that is populated with constants \nPI\n and \nE\n (for Euler's number \n\\(e\\)\n), along with a long list of mathematical functions.  To associate a method or a field with a class in Java, we declare them with the \nstatic\n keyword.  We can additionally add a keyword \nfinal\n to indicate that the value of the field will not change\n7\n.\n\n\n1\n2\n3\n4\n5\n6\nclass\n \nMath\n \n{\n\n  \n:\n\n  \npublic\n \nstatic\n \nfinal\n \ndouble\n \nPI\n \n=\n \n3.141592653589793\n;\n\n  \n:\n\n  \n:\n\n\n}\n\n\n\n\n\n\n\nWe call these fields and methods that are associated with a class as \nclass fields\n and \nclass methods\n, and fields and methods that are associated with an object as \ninstance fields\n and \ninstance methods\n.\n\n\n\n\nClass Fields and Methods in Python\n\n\nNote that, in Python, any variable declared within a \nclass\n block is a class field:\n\n1\n2\n3\nclass\n \nCircle\n:\n\n  \nx\n \n=\n \n0\n\n  \ny\n \n=\n \n0\n\n\n\n\n\nIn the above example, \nx\n and \ny\n are class fields, not instance fields.\n\n\n\n\nMemory Model for Objects\n\n\nVariables and functions are stored in the memory of the computers as bits, usually in two separate regions.  Since an object encapsulates both variables and functions, where are they stored?  \n\n\nDifferent implementations might stored the objects differently, but here is one way that we will follow for this class:\n\n\n\n\nIn the figure above, there are two objects of the same class.  An objects is referred to through its references, which is a pointer to memory location where the instance fields for the object is stored, along with a pointer to a \nmethod table\n.  A method table stores a table of pointers to the methods, along with a table to the class fields.    \n\n\nExample: The Circle class\n\n\nNow, let revise our \nCircle\n class to improve the code and make it a little more complete:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\nimport\n \njava.lang.Math\n;\n\n\n\n/**\n\n\n * A Circle object encapsulates a circle on a 2D plane.  \n\n\n */\n\n\nclass\n \nCircle\n \n{\n\n  \nprivate\n \ndouble\n \nx\n;\n  \n// x-coordinate of the center\n\n  \nprivate\n \ndouble\n \ny\n;\n  \n// y-coordinate of the center\n\n  \nprivate\n \ndouble\n \nr\n;\n  \n// the length of the radius\n\n\n  \n/**\n\n\n   * Create a circle centered on (centerX, centerY) with given radius\n\n\n  */\n\n  \npublic\n \nCircle\n(\ndouble\n \ncenterX\n,\n \ndouble\n \ncenterY\n,\n \ndouble\n \nradius\n)\n \n{\n\n    \nx\n \n=\n \ncenterX\n;\n\n    \ny\n \n=\n \ncenterY\n;\n\n    \nr\n \n=\n \nradius\n;\n\n  \n}\n\n\n  \n/**\n\n\n   * Return the area of the circle.\n\n\n   */\n\n  \npublic\n \ndouble\n \ngetArea\n()\n \n{\n\n    \nreturn\n \nMath\n.\nPI\n*\nr\n*\nr\n;\n\n  \n}\n\n\n  \n/**\n\n\n   * Return the circumference of the circle.\n\n\n   */\n\n  \npublic\n \ndouble\n \ngetCircumference\n()\n \n{\n\n    \nreturn\n \nMath\n.\nPI\n*\n2\n*\nr\n;\n\n  \n}\n\n\n  \n/**\n\n\n   * Move the center of the circle to the new position (newX, newY)\n\n\n   */\n\n  \npublic\n \nvoid\n \nmoveTo\n(\ndouble\n \nnewX\n,\n \ndouble\n \nnewY\n)\n \n{\n\n    \nx\n \n=\n \nnewX\n;\n\n    \ny\n \n=\n \nnewY\n;\n\n  \n}\n\n\n  \n/**\n\n\n   * Return true if the given point (testX, testY) is within the circle.\n\n\n   */\n\n  \npublic\n \nboolean\n \ncontains\n(\ndouble\n \ntestX\n,\n \ndouble\n \ntestY\n)\n \n{\n\n    \nreturn\n \nfalse\n;\n\n    \n// TODO: left as an exercise  \n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nCreating and Interacting with \nCircle\n objects\n\n\nTo use the \nCircle\n class, we can either:\n\n\n\n\ncreate a \nmain()\n function, compile and link with the \nCircle\n class, and create an executable program, just like we usually do with a C program, OR\n\n\nuse a new bleeding-edge tool called \njshell\n, which is part of Java 9 (to be released September 2017), and its \nread-evaluate-print loop\n (REPL) to help us quickly try out various features of Java.\n\n\n\n\nWe will write a complete Java program with \nmain()\n within two weeks, but for now, we will use \njshell\n to demonstrate the various language features of Java\n7\n.\n\n\nThe demonstration below loads the \nCircle\n class written above (with the \ncontains\n method completed) from a file named \nCircle.java\n8\n, and creates two \nCircle\n objects, \nc1\n and \nc2\n.  We use the \nnew\n keyword to tell Java to create an object of type \nCircle\n here, passing in the center and the radius.\n\n\n\n\n\n\n\n\n\n\n\n\n\nOften, the instructions and data are stored in different regions of the memory.\u00a0\n\u21a9\n\n\n\n\n\n\nJavascript would happily convert \n4\n into a string for you, and return \n45\n.\u00a0\n\u21a9\n\n\n\n\n\n\nassuming the parameters are passed in correctly.\u00a0\n\u21a9\n\n\n\n\n\n\nComputer scientists just can't decide on what to call this!\u00a0\n\u21a9\n\n\n\n\n\n\nOthers include \nprotected\n and the \ndefault\n modifier, but let's not sweat about the details for now.\u00a0\n\u21a9\n\u21a9\n\n\n\n\n\n\nThe class \nMath\n is provided by the package \njava.lang\n in Java.  A package is simply a set of related classes (and interfaces, but I have not told you what is an interface yet).  To use this class, we need to add the line \nimport\n \njava.lang.Math\n in the beginning of our program.\u00a0\n\u21a9\n\n\n\n\n\n\nYou can download and install \njshell\n yourself, as part of \nJava Development Kit version 9 (JDK 9)\n\u00a0\n\u21a9\n\u21a9\n\n\n\n\n\n\nWe use the convention of one public class per file, name the file with the exact name of the class (including capitalization), and include the extension \n.java\n to the filename.\u00a0\n\u21a9",
            "title": "1. Abstraction & Encapsulation"
        },
        {
            "location": "/lec1/index.html#lecture-1-abstraction-and-encapsulation",
            "text": "",
            "title": "Lecture 1: Abstraction and Encapsulation"
        },
        {
            "location": "/lec1/index.html#learning-objectives",
            "text": "After this lecture, students should:   recap some fundamental programming concepts, including the execution model of a program, abstractions over code and data, primitive and composite data types.  appreciate the importance of maintaining abstraction barrier in software development  understand the differences between statically and dynamically typed languages  understand the concepts of object-oriented programming, including encapsulation, data hiding, fields and methods, constructors, mutators/accessors, classes and objects, and their purposes of introducing them as a method of programming.  know the purpose and usage of Java keywords  class ,  public ,  private ,  final ,  static ,  import ,  new  be able to build a mental model for how an object is represented in Java",
            "title": "Learning Objectives"
        },
        {
            "location": "/lec1/index.html#what-exactly-is-a-program",
            "text": "A program is a set of instructions we issue to computers to manipulate data.  A programming language is a formal language that helps programmers specify precisely what are the instructions we issue to computers, using code that are often made up of keywords, symbols, and names.  Computers execute the instructions in their  processing units , and store the instructions and data in their  memory 1 .  The processing units recognizes the instructions based on the specific patterns of bits and manipulate data as a sequence of bits.  A programming language, however, is written at a higher level of  abstraction  (i.e., at a higher conceptual level), so that as a programmer, we only need to write a few lines of code to give complex instructions to the computer.  A  compiler  or  interpreter  is responsible for translating these programs written in high level language to  assembly code  or  machine code , i.e., bit patterns that the processing units can understand.  There are thousands of programming languages in existence.   C  is one of the languages that is a  low-level language  -- i.e., it provides very thin layer of abstractions on top of machine code.  On the other hand, languages such as  Python  and  JavaScript  are high-level languages.  As an example, in C, you can directly manage memory allocation.  In JavaScript and Python, you cannot.",
            "title": "What Exactly is a Program?"
        },
        {
            "location": "/lec1/index.html#abstraction-variable-and-type",
            "text": "One of the important abstractions that is provided by a programming language is  variable .  Data are stored in some location in the computer memory.  But we should not be referring to the memory location all the time.  First, referring to something like  0xFA49130E  is not user-friendly; Second, the location may change.  A  variable  is an abstraction that allows us to give a user friendly name to memory location.  We use the  variable name  whenever we want to access the  value  in that location, and  pointer to the variable  or  reference to the variable  whenever we want to refer to the address of the location.  Let's think a bit more about how sequence of bits is abstracted as data in a programming language.  At the machine level, these bits are just, well, bits.  We give the bits a  semantic  at the program level, e.g., we want to interpret the sequence of bits as numbers, letters, etc.  E.g., the number (integer, to be exact)  65  and the letter  A  all share the same sequence of bits  0100 00011  but are interpreted differently and possibly manipulated differently.    The  type  of a variable tells the compiler how to interpret the variable and how to manipulate the variable.    For instance, supposed that in Python, if you have two variables  x  and  y  storing the values  4  and  5  respectively, if you  print x + y , you may get  45  if  x  and  y  are strings, or you may get  9  if  x  and  y  are integers, or you may get an error if  4  is an integer and  5  is a string.    In the last instance above, you see that assigning types of variables helps to keep the program meaningful, as the operation  +  is not defined over an integer and a string in Python 2 .  Python is a  dynamically typed  language.  The same variable can hold values of different types, and checking if the right type is used is done during the execution of the program.  Note that, the type is associated with the  values , and the type of the variable changes depending on the value it holds.  C, on the other hand, is a  statically typed  language.  We need to  declare  every variable we use in the program and specify its type.  A variable can only hold values of the same type as the type of the variable, so we can't assign, for instance, a string to a variable of type  int .  We check if the right type is used during the compilation of the program.  1\n2 int   x   =   4 ;   // ok  int   y   =   \"5\" ;   // error    By annotating each variable with its type, the C compiler also knows how much memory space is needed to store a variable.",
            "title": "Abstraction: Variable and Type"
        },
        {
            "location": "/lec1/index.html#abstraction-functions",
            "text": "Another important abstraction provided by a programming language is  function  (or  procedure ).  This abstraction allows programmers to group a set of instructions and give it a name.  The named set of instructions may take one or more variables as input parameters, and return one or more values.     Like all other abstractions, defining functions allow us to think at a higher conceptual level.  By composing functions at increasingly higher level of abstractions, we can build programs with increasing level of complexity.  Defining functions allow us to abstract away the implementation details from the caller.  Once a function is defined, we can change the way the function is implemented without affecting the code that calls the function, as long as the semantic and the  interface  of the function remains the same.  Functions therefore is a critical mechanism for achieving  separation of concerns  in a program.  We separate the concerns about how a particular function is implemented, from the concerns about how the function is used to perform a higher-level task.  Defining functions also allow us to  reuse  code.  We do not have to repeatedly write the same chunk of code if we group the sequence of code into a function -- then we just need to call the function to invoke this sequence of code every time we need it.  If this chunk of code is properly written and debugged, then we can be pretty sure that everywhere the function is invoked, the code is correct 3 .  C is a  procedural language .  A C program consists of functions, with the  main()  function serves as the entry point to the program.  Since C is a statically type language, a C function has a return type, and each  function parameter (or  argument ) has a type as well.  (Note that this statement does not mean that C function must return a  value .  If the function does not return a value, we define its return type as  void .)  Recall that the bits representing the instructions are also stored in the computer memory in a separate area from the data.  The group of instructions that belongs to the same function are stored together.  Just like we can refer to a variable using its memory address using its  reference  (or  pointer ), we can refer to a function using the memory address of the entry point to the function.",
            "title": "Abstraction: Functions"
        },
        {
            "location": "/lec1/index.html#abstraction-composite-data-type",
            "text": "Just like functions allow programmers to group instructions, give it a name, and refer to it later, a  composite data type  allow programers to group  primitive types  together, give it a name (a new type), and refer to it later.  This is another powerful abstraction in programming languages that help us to think at a higher conceptual level without worrying about the details.   Commonly used examples are mathematical objects such as complex numbers, 2D data points, multi-dimensional vectors, circles, etc, or everyday objects such as a person, a product, etc.  Defining composite data type allows programmers to abstract away (and be separated from the concern of) how a complex data type is represented.  For instance, a circle on a 2D plane can be represented by the center ( x ,  y ) and its radius  r , or it can be represented by the top left corner ( x , y ) and the width  w  of the bounding square.  In C, we build composite data type with  struct .  For example,  1\n2\n3\n4 struct   circle   { \n   float   x ,   y ;   // (x,y) coordinate of the center. \n   float   r ;   // radius  }    Once we have the  struct  defined, we are not completely shielded from its representation, until we write a set of functions that operates on the  circle  composite type.  For instance,  1\n2\n3 float   circle_area ( circle   c )   {   ...   };  bool    circle_contains_point ( circle   c ,   point   p )   {   ...   }; \n   :    Implementation of these functions obvious requires knowledge of how a circle is represented.  Once the set of functions that operates on and manipulate circles are available, we can use  circle  type without worrying about the internal representation.    If we decided to change the representation of a circle, then only the set of functions that operates on a circle type need to be changed, but not the code that uses circles to do other things.  We can imagine an  abstraction barrier  between the code that uses a composite data type along with its associated set of functions, and the code that define the data type along with the implementation of the functions.  Above the barrier, the concern is about using the composite data type to do useful things, while below the barrier, the concern is about how to represent and manipulate the composite data type.",
            "title": "Abstraction: Composite Data type"
        },
        {
            "location": "/lec1/index.html#abstraction-class-and-object-or-encapsulation",
            "text": "We can further bundle the composite data type and its associated functions together in another abstraction, called a  class .  A class is a data type with a group of functions associated with it.  We call the functions as  methods  and the data in the class as  fields  (or  members , or  states , or  attributes 4 ).   A well-designed class maintain the abstraction barrier, properly wrapped the barrier around the internal representation and implementation, and exposes just the right interface for others to use.  Just like we can create variables of a given type, we can create  objects  of a given class.  Objects are instances of a class, each allowing the same methods to be called, and each containing the same set of variables of the same types, but (possibly) storing different values.  Recall that programs written in a procedural language such as a C consists of functions, with a  main()  function as the entry point.  A program written in an  object-oriented language  such as Java consists of classes, with one main class as the entry point.  One can view a running object-oriented (or OO) program as something that instantiates objects of different classes and orchestrates their interactions with each other by calling each others' methods.  One could argue that an object-oriented way of writing programs is much more natural, as it mirrors our world more closely.  If we look around us, we see objects all around us, and each object has a certain behavior and they allow certain actions.  We interact with the objects through their interfaces, and we rarely need to know the internals of the objects we used everyday (unless we try to repair it) 5 .    This concept, of keeping the all the data and functions operating on the data related to a composite data type together within an abstraction barrier, is called  encapsulation .",
            "title": "Abstraction: Class and Object (or, Encapsulation)"
        },
        {
            "location": "/lec1/index.html#breaking-the-abstraction-barrier",
            "text": "In the ideal case, the code above the abstraction barrier would just call the provided interface to use the composite data type.  There, however, may be cases where a programmer may intentionally or accidentally break the abstraction barrier.    Consider the case of implementing  circle  as a C  struct .  Suppose someone wants to move the center of the circle  c  to a new position ( x ,  y ), instead of implementing a function  circle_move_to(c, x, y)  (which would still keep the representation used under the barrier), the person wrote:  1\n2 c . x   =   x ;  c . y   =   y ;    This code would still be correct, but the abstraction barrier is broken since we now make explicit assumption that there are two variables  x  and  y  inside the  circle  data type that correspond to the center of the circle.  If one day, we want to represent a circle in a different way, then we have to carefully change all the code that read and write these variables  x  and  y  and update them.   Breaking Python's Abstraction Barrier  Python tries to prevent  accidental  access to internal representation by having a convention of prefixing the internal variables with  _  (one underscore) or  __  (two underscores).   This method, however, does not prevent a lazy programmer from directly accessing the variables and possibly planting a bug / error that will surface later.",
            "title": "Breaking the Abstraction Barrier"
        },
        {
            "location": "/lec1/index.html#data-hiding",
            "text": "Many OO languages allow programmers to explicitly specify if a field or a method can be accessed from outside the abstraction barrier.  Java, for instance, support  private  and  public  access modifiers 5 .  A field or a method that is declared as  private  cannot be accessed from outside the class, and can only be accessed within the class.  On the other hand, as you can guess, a  public  field or method can be accessed, modified, or invoked from outside the class.  Such mechanism to protect the abstraction barrier from being broken is called  data hiding  or  information hiding .  This protection is enforced in the  compiler  during compile time.",
            "title": "Data Hiding"
        },
        {
            "location": "/lec1/index.html#example-the-circle-class",
            "text": "Let's put together the concepts of encapsulation, data hiding to define a  Circle  class in Java:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23 /**   * A Circle object encapsulates a circle on a 2D plane.     */  class   Circle   { \n   private   double   x ;    // x-coordinate of the center \n   private   double   y ;    // y-coordinate of the center \n   private   double   r ;    // the length of the radius \n\n   /**     * Return the area of the circle.     */ \n   public   double   getArea ()   { \n     return   3.1415926 * r * r ; \n   } \n\n   /**     * Move the center of the circle to the new position (newX, newY)     */ \n   public   void   moveTo ( double   newX ,   double   newY )   { \n     x   =   newX ; \n     y   =   newY ; \n   }  }    The class above is still missing many essential components, and not a complete program.",
            "title": "Example: The Circle class"
        },
        {
            "location": "/lec1/index.html#constructors-accessors-and-mutators",
            "text": "With data hiding, we completely isolate the internals representation of a class using an abstraction barrier.  With no way for the user of the class to modify the fields directly, it is common for a class to provide methods to initialize and modify these internal fields (such as the  moveTo()  method above).  A method that initializes an object is called a  constructor , and a method that retrieves or modifies the properties of the object is called the  accessor  (or  getter ) or  mutator  (or  setter ).  A constructor method is a special method within the class.  It cannot be called directly, but is invoked automatically when an object is instantiated.   In Java, a constructor method has the same name as the class and has no return type.  A constructor can take in arguments just like other functions.  The class  Circle  can have a constructor such as the following:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12 class   Circle   { \n     : \n   /**     * Create a circle centered on (centerX, centerY) with given radius    */ \n   public   Circle ( double   centerX ,   double   centerY ,   double   radius )   { \n     x   =   centerX ; \n     y   =   centerY ; \n     r   =   radius ; \n   } \n     :  }    The use of accessor and mutator methods is a bit controversial.   Suppose that we provide an accessor method and a mutator method for every private field, then we are actually exposing the internal representation, therefore breaking the encapsulation.  For instance:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28 class   Circle   { \n     : \n\n   public   double   getX ()   { \n     return   x ; \n   } \n\n   public   void   setX ( double   newX )   { \n     x   =   newX ; \n   } \n\n   public   double   getY ()   { \n     return   y ; \n   } \n\n   public   void   setY ( double   newY )   { \n     y   =   newY : \n   } \n\n   public   double   getR ()   { \n     return   r ; \n   } \n\n   public   void   setR ( double   newR )   { \n     r   =   newR ; \n   } \n     :  }    The examples above are pretty pointless.  If we need to know the internal and do something with it, we are doing it wrong.  The right approach is to implement a method within the class that do whatever we want the class to do.   For instance, suppose that we want to know the circumference of the circle, one approach would be:  1     double   circumference   =   2 * c . getR ()* 3.1415926 ;    where c is a  Circle  object.  A better approach would be to add a new method  getCircumference()  in the  Circle  class, and call this instead: 1     double   circumference   =   c . getCircumference ();    The better approach involves writing more lines of code, but it keeps the encapsulation in tact.   Constructor in Python and JavaScript  In Python, the constructor is the  __init__  method.   In JavaScript, the constructor is simply called  constructor .",
            "title": "Constructors, Accessors, and Mutators"
        },
        {
            "location": "/lec1/index.html#class-fields-and-methods",
            "text": "Let's look at the implementation of  getArea()  above.  We use the constant  \\(\\pi\\)  but hardcoded it as 3.1415926.  Hardcoding such a magic number is a  no no  in terms of coding style.  This constant can appear in more than one places, and if we hardcode such a number, and want to change the precision of it later, we would need to trace down and change every occurrence.  Not only this introduces more work, but likely to introduce bugs.    In C, we define it as a macro constant  M_PI .  But how should we do this in Java?  This is where the ideal that a program consists of only objects with internal states that communicate with each other feel a bit constraining.  The constant  \\(\\pi\\)  is universal, and not really belong to any object (the value of Pi is the same for every circle!).  If we start to define a method  sqrt()  that computes the square root of a given number, this is a general function that is not associated with any object as well.  A solution to this is to associate these global values and functions with a  class  instead of with an  object .  For instance. Java predefines a  Math  class 6  that is populated with constants  PI  and  E  (for Euler's number  \\(e\\) ), along with a long list of mathematical functions.  To associate a method or a field with a class in Java, we declare them with the  static  keyword.  We can additionally add a keyword  final  to indicate that the value of the field will not change 7 .  1\n2\n3\n4\n5\n6 class   Math   { \n   : \n   public   static   final   double   PI   =   3.141592653589793 ; \n   : \n   :  }    We call these fields and methods that are associated with a class as  class fields  and  class methods , and fields and methods that are associated with an object as  instance fields  and  instance methods .   Class Fields and Methods in Python  Note that, in Python, any variable declared within a  class  block is a class field: 1\n2\n3 class   Circle : \n   x   =   0 \n   y   =   0   \nIn the above example,  x  and  y  are class fields, not instance fields.",
            "title": "Class Fields and Methods"
        },
        {
            "location": "/lec1/index.html#memory-model-for-objects",
            "text": "Variables and functions are stored in the memory of the computers as bits, usually in two separate regions.  Since an object encapsulates both variables and functions, where are they stored?    Different implementations might stored the objects differently, but here is one way that we will follow for this class:   In the figure above, there are two objects of the same class.  An objects is referred to through its references, which is a pointer to memory location where the instance fields for the object is stored, along with a pointer to a  method table .  A method table stores a table of pointers to the methods, along with a table to the class fields.",
            "title": "Memory Model for Objects"
        },
        {
            "location": "/lec1/index.html#example-the-circle-class_1",
            "text": "Now, let revise our  Circle  class to improve the code and make it a little more complete:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49 import   java.lang.Math ;  /**   * A Circle object encapsulates a circle on a 2D plane.     */  class   Circle   { \n   private   double   x ;    // x-coordinate of the center \n   private   double   y ;    // y-coordinate of the center \n   private   double   r ;    // the length of the radius \n\n   /**     * Create a circle centered on (centerX, centerY) with given radius    */ \n   public   Circle ( double   centerX ,   double   centerY ,   double   radius )   { \n     x   =   centerX ; \n     y   =   centerY ; \n     r   =   radius ; \n   } \n\n   /**     * Return the area of the circle.     */ \n   public   double   getArea ()   { \n     return   Math . PI * r * r ; \n   } \n\n   /**     * Return the circumference of the circle.     */ \n   public   double   getCircumference ()   { \n     return   Math . PI * 2 * r ; \n   } \n\n   /**     * Move the center of the circle to the new position (newX, newY)     */ \n   public   void   moveTo ( double   newX ,   double   newY )   { \n     x   =   newX ; \n     y   =   newY ; \n   } \n\n   /**     * Return true if the given point (testX, testY) is within the circle.     */ \n   public   boolean   contains ( double   testX ,   double   testY )   { \n     return   false ; \n     // TODO: left as an exercise   \n   }  }",
            "title": "Example: The Circle class"
        },
        {
            "location": "/lec1/index.html#creating-and-interacting-with-circle-objects",
            "text": "To use the  Circle  class, we can either:   create a  main()  function, compile and link with the  Circle  class, and create an executable program, just like we usually do with a C program, OR  use a new bleeding-edge tool called  jshell , which is part of Java 9 (to be released September 2017), and its  read-evaluate-print loop  (REPL) to help us quickly try out various features of Java.   We will write a complete Java program with  main()  within two weeks, but for now, we will use  jshell  to demonstrate the various language features of Java 7 .  The demonstration below loads the  Circle  class written above (with the  contains  method completed) from a file named  Circle.java 8 , and creates two  Circle  objects,  c1  and  c2 .  We use the  new  keyword to tell Java to create an object of type  Circle  here, passing in the center and the radius.       Often, the instructions and data are stored in different regions of the memory.\u00a0 \u21a9    Javascript would happily convert  4  into a string for you, and return  45 .\u00a0 \u21a9    assuming the parameters are passed in correctly.\u00a0 \u21a9    Computer scientists just can't decide on what to call this!\u00a0 \u21a9    Others include  protected  and the  default  modifier, but let's not sweat about the details for now.\u00a0 \u21a9 \u21a9    The class  Math  is provided by the package  java.lang  in Java.  A package is simply a set of related classes (and interfaces, but I have not told you what is an interface yet).  To use this class, we need to add the line  import   java.lang.Math  in the beginning of our program.\u00a0 \u21a9    You can download and install  jshell  yourself, as part of  Java Development Kit version 9 (JDK 9) \u00a0 \u21a9 \u21a9    We use the convention of one public class per file, name the file with the exact name of the class (including capitalization), and include the extension  .java  to the filename.\u00a0 \u21a9",
            "title": "Creating and Interacting with Circle objects"
        },
        {
            "location": "/lec2/index.html",
            "text": "Lecture 2: Inheritance & Polymorphism\n\n\nLearning Objectives\n\n\nAfter this lecture, students should:\n\n\n\n\nunderstand that Java is a type-safe language, in contrast to C\n\n\nbe familiar with Java variable and primitive types\n\n\nunderstand the concepts of object-oriented programming, including interface, polymorphism, late binding, inheritance, method overriding and method overloading, and their purposes of introducing them as a method of programming.\n\n\nknow the purpose and usage of Java keywords \nimplements\n, \nextends\n, \nsuper\n, \ninstanceof\n, and \n@Override\n\n\nunderstand Java concepts of arrays, enhanced \nfor\n loop, method signature, \nObject\n class, and object equality. \n\n\n\n\nType Safety\n\n\nRecall that the \ntype\n of a variable tells the compiler how to interpret the bits that represent the value of a variable and how to manipulate the variable.  The compiler also uses the type to decide how much memory is allocated for each variable.  \n\n\nSome languages are stricter in terms of type \"compatibility\" than others.  C compilers, however, are not very strict.  If it detects something strange with the type you used, it will issue a warning, but still let your code compiles and run.\n\n\nTake:\n\n\n1\n2\n3\n4\n5\n#include\n \n<stdio.h>\n\n\nint\n \nmain\n()\n\n\n{\n\n    \nprintf\n(\n\"%d\n\\n\n\"\n,\n \n\"cs2030\"\n);\n\n\n}\n\n\n\n\n\n\n\nIn Line 4, we treat the address to a string as integer.  This generates a compiler's warning.\n\n\nIn C, you can \ntype cast\n a variable from one type into another, i.e., force the compiler to treat a variable of one type as another type.  The compiler would listen and do that for you.  The following code would print out gibberish and would compile perfectly without error.\n\n\n1\n2\n3\n4\n5\n#include\n \n<stdio.h>\n\n\nint\n \nmain\n()\n\n\n{\n\n    \nprintf\n(\n\"%d\n\\n\n\"\n,\n \n(\nint\n)\n\"cs2030\"\n);\n\n\n}\n\n\n\n\n\n\n\nSuch flexibility and loose rules for type compatibility could be useful, if you know what you are doing, but for most programmers, it could be a major source of unintentional bugs, especially if one does not pay attention to compiler's warning or one forces the warning to go away without fully understanding what is going on.\n\n\nJava is very strict when it comes to type checking, and is one of the \ntype-safe\n languages. Java ensures that basic operations (such as \n+\n, \n-\n, etc) and method calls apply to values in a way that makes sense.  If you try to pull the same trick as above, you will receive an error:\n\n\n\n\n\n\n\nJava Primitive Data Types\n\n\nJava supports eight \nprimitive\n data types: \nbyte\n, \nshort\n, \nint\n, \nlong\n, \nfloat\n, \ndouble\n, \nboolean\n and \nchar\n.  If you are familiar with C, these data types should not be foreign to you.  One important difference is that a \nchar\n variable stores a 16-bit Unicode character, not an 8-bit character like in C.  Java uses \nbyte\n for that.  The other notable difference is that Java defines \ntrue\n and \nfalse\n as possible value to a \nboolean\n, unlike C which uses \n0\n for false and non-\n0\n for true.  \n\n\nYou can read all about Java \nvariables\n and \nprimitive data types\n in Oracle's Java Tutorial.\n\n\n\n\nEnforcing Abstraction Barrier with Interface\n\n\nRecall the concept of encapsulation. When we develop a large piece of software, it is important to hide the details about data representation and implementation, and only exposes certain \npublic\n methods for the users to use.  We imagine that there is an abstraction barrier between the code that implements the internals of a class (called the \nimplementer\n) and the code that uses the class (called the \nuser\n) to achieve a higher level task.\n\n\nWe have seen that we use \nprivate\n to enforce data hiding -- to hide certain fields and methods from outside of the barrier.  Now, we are going to see how we enforce that the right set of methods are defined, implemented, and used on both sides of the barrier.\n\n\nThe mechanism to do this is through defining an \ninterface\n (aka a \nprotocol\n as it is called in Objective-C or Swift).  An interface is kinda like a contract between the implementer of a class and the user of a class.  If a class promises to implement an interface, then we are guaranteed that the methods defined in the interface are implemented in the class as it is promised.  Otherwise, the code would not compile.\n\n\nIn Java, we can define an interface using \ninterface\n keyword:\n\n\n1\n2\n3\n4\n5\ninterface\n \nGeometricShape\n \n{\n\n    \npublic\n \ndouble\n \ngetArea\n();\n\n    \npublic\n \ndouble\n \ngetPerimeter\n();\n\n    \npublic\n \nboolean\n \ncontains\n(\nPoint\n \np\n);\n\n\n}\n\n\n\n\n\n\n\nThe example interface \nGeometricShape\n above contains only the declaration of the methods, not the implementation.  \n\n\nNow, let's see how the implementer would implement a class using the interface.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\nimport\n \njava.lang.Math\n;\n\n\nclass\n \nCircle\n \nimplements\n \nGeometricShape\n \n{\n\n    \nprivate\n \nPoint\n \ncenter\n;\n\n    \nprivate\n \ndouble\n \nradius\n;\n\n\n    \npublic\n \nCircle\n(\nPoint\n \ninitCenter\n,\n \ndouble\n \ninitR\n)\n \n{\n\n        \ncenter\n \n=\n \ninitCenter\n;\n\n        \nradius\n \n=\n \ninitR\n;\n\n    \n}\n\n\n    \nvoid\n \nmoveTo\n(\nPoint\n \np\n)\n \n{\n\n        \ncenter\n \n=\n \np\n;\n\n    \n}\n\n\n    \n@Override\n\n    \npublic\n \ndouble\n \ngetArea\n()\n \n{\n\n        \nreturn\n \nMath\n.\nPI\n*\nradius\n*\nradius\n;\n\n    \n}\n\n\n    \n@Override\n\n    \npublic\n \nboolean\n \ncontains\n(\nPoint\n \np\n)\n \n{\n\n        \nreturn\n \n(\np\n.\ndistance\n(\ncenter\n)\n \n<\n \nradius\n);\n\n    \n}\n\n\n    \n@Override\n\n    \npublic\n \ndouble\n \ngetPerimeter\n()\n \n{\n\n        \nreturn\n \nMath\n.\nPI\n*\n2\n*\nradius\n;\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nThis is very similar to the code you saw in Lecture 1 and Exercise 1, except that in Line 2, we say that \nclass\n \nCircle\n \nimplements\n \nGeometricShape\n.  This line informs the compiler that the programmer intends to implement all the methods included in the interface \nGeometricShape\n exactly as declared (in terms of names, the number of arguments, the types of arguments, returned type, and access modifier).  The rest of the class is the same, except that we renamed \ngetCircumference\n with \ngetPerimeter\n, which is more general and apply to all shapes.  You will also see that we added \nannotations\n to our code by adding the line \n@Override\n before methods in \nCircle\n that implements the methods declared in \nGeometricShape\n.  This annotation is optional, but it informs our intention to the compiler and helps make the intention of the programmer clearer to others who read the code.\n\n\n\n\nJava Annotation\n\n\nAnnotations are metadata we add that is not part of the code.  Annotation does not affect execution.  They are useful to compilers and other software tools, as well as humans who read the code.  While we can similarly make the code more human-friendly with comments, an annotation is structured and so can be easily parsed by software.  \n@Override\n is probably going to be the only annotation useful for us in this class.\n\n\n\n\nNote that we can have other methods (such as \nmoveTo\n) in the class beyond what is promised in the interface the class implements.\n\n\nA class can implement more than one interfaces.  For instance, let's say that we have another interface called \nPrintable\n[^1] with a single method defined:\n\n\n1\n2\n3\ninterface\n \nPrintable\n \n{\n\n    \npublic\n \nvoid\n \nprint\n();\n\n\n}\n\n\n\n\n\n\n\nThe implementer of \nCircle\n wants to inform the users that the method \nvoid print()\n is implemented, it can do the following:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\nclass\n \nCircle\n \nimplements\n \nGeometricShape\n,\n \nPrintable\n \n{\n\n     \n:\n\n     \n:\n\n     \n@Override\n\n     \npublic\n \nvoid\n \nprint\n()\n \n{\n\n         \nSystem\n.\nout\n.\nprintf\n(\n\"radius: %f\\n\"\n,\n \nradius\n);\n\n         \nSystem\n.\nout\n.\nprintf\n(\n\"center:\"\n);\n\n         \ncenter\n.\nprint\n();\n\n     \n}\n\n\n}\n\n\n\n\n\n\n\nIn the above, we call \nprint()\n on the \nPoint\n object as well.  How do we know that \nPoint\n provides a \nprint()\n method?  Well, we can read the implementation code of \nPoint\n, or we can agree with the implementer of \nPoint\n that \nPoint\n provides a \nPrintable\n interface!  \n\n\nIt is important to know that, \ninterface\n provides a \nsyntactic\n contract on the abstraction barrier, but it does not provide a \nsemantic\n contract.  It does not, for instance, guarantee that \nprint()\n actually prints something to the screen.  One could still implement interface \nPrintable\n as follows:\n\n\n1\n2\n3\n4\n5\n6\n7\nclass\n \nCircle\n \nimplements\n \nGeometricShape\n,\n \nPrintable\n \n{\n\n     \n:\n\n     \n:\n\n     \n@Override\n\n     \npublic\n \nvoid\n \nprint\n()\n \n{\n\n     \n}\n\n\n}\n\n\n\n\n\n\n\nand the code still compiles!\n\n\nNot all programming languages that support classes support interface.  Javascript and Python, for instance, does not support similar concepts.\n\n\nInterface as Types\n\n\nIn Java, an interface is a type.  What this means is that:\n\n\n\n\nWe can declare a variable with an interface type, such as:\n\n1\n    \nGeometricShape\n \ncircle\n;\n\n\n\n\n\nor\n\n1\n    \nPrintable\n \ncircle\n;\n\n\n\n\n\nWe cannot, however, instantiate an object from an interface\nsince an interface is a \"template\", an \"abstraction\", and does not have an implementation.  For instance:\n\n\n\n\n1\n2\n3\n4\n    \n// this is not OK\n\n    \nPrintable\n \np\n \n=\n \nnew\n \nPrintable\n();\n\n    \n// this is OK\n\n    \nPrintable\n \ncircle\n \n=\n \nnew\n \nCircle\n(\nnew\n \nPoint\n(\n0\n,\n \n0\n),\n \n10\n);\n\n\n\n\n\n\n\n\n\n\n\nSimilarly, we can pass arguments of an interface type into a method, and the return type of a method can be an interface.\n\n\n\n\n\n\nAn object can be an instance of multiple types.  Recall that Java is a statically typed language. We associate a type with a variable.  We can assign a variable to an object if the object is an instance of the type of the variable.  Line 4 above, for instance, creates a new circle, which is an instance of three types: \nCircle\n, \nGeometricShape\n, and \nPrintable\n.  It is ok to assign this new circle to a variable of type \nPrintable\n.\n\n\n\n\n\n\nWe can now do something cool like this:\n\n1\n2\n3\n4\n5\n6\n7\n    \nPrintable\n[]\n \nobjectsToPrint\n;\n\n      \n:\n\n      \n// initialize array objectsToPrint\n\n    \n:\n\n    \nfor\n \n(\nPrintable\n \nobj\n:\n \nobjectsToPrint\n)\n \n{\n\n        \nobj\n.\nprint\n();\n\n    \n}\n\n\n\n\n\n\nLet's look at this code in more details.  Line 1 declares an array of objects of type \nPrintable\n.  We skip over the code to initialize the content of the array for now, and\njump to Line 5-7, which is a \nfor\n loop.  Line 5 declares a loop variable \nobj\n of type \nPrintable\n and loops through all objects in the array \nobjectsToPrint\n, and Line 6 invoke the method \nprint\n of \nobj\n.\n\n\n\n\nArray and For Loops in Java\n\n\nSee Oracle's tutorial on \narray\n and \nenhanced loop\n\n\n\n\nThe magic happens in Line 6:\n\n\n\n\nFirst, since we now that any object in the array has the type \nPrintable\n, this means that they must implement the \nPrintable\n interface and support the method \nprint()\n.  \n\n\nSecond, we do not know, and we do not \nneed\n to know which class an object is an instance of.\n\n\nThird, we can actually have objects of completely unrelated classes in the same array. We can have objects of type \nCircle\n, and objects of type \nPoint\n.  We can have objects of type \nFactory\n, or objects of type \nStudent\n, or objects of type \nCushion\n.  As long as the objects implement the \nPrintable\n interface, we can put them into the same array.\n\n\nForth, at \nrun time\n, Java looks at \nobj\n, and determines its class, and invoke the right implementation of \nprint()\n corresponding to the \nobj\n.  That is, if \nobj\n is an instance of a class \nCircle\n, then it will call \nprint()\n method of \nCircle\n; if \nobj\n is an instance of a class \nPoint\n, then it will call \nprint()\n method of \nPoint\n, and so on.\n\n\n\n\nTo further appreciate the magic that happens in Line 6, especially the last point above, consider how function call is done in C.  In C, you cannot have two functions of the same name within the same scope, so if you call a function \nprint()\n, you know exactly which set of instructions will be called\n1\n.  So, the name \nprint\n is bound to the corresponding set of instructions at compilation time.  This is called \nstatic binding\n or \nearly binding\n.\nTo have \nprint()\n for different types, we need to name them differently to avoid naming conflicts: e.g., \nprint_point()\n, \nprint_circle()\n.\n\n\nIn a language with static binding, suppose you want to mix objects of different types\ntogether in an array, you need to do something like the following pseudocode:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n   \nfor\n \neach\n \nobject\n \nin\n \nthe\n \narray\n\n       \nif\n \nobject\n \nis\n \na\n \npoint\n\n           \nprint_point\n(\nobject\n)\n\n       \nelse\n \nif\n \nobject\n \nis\n \na\n \ncircle\n\n           \nprint_circle\n(\nobject\n)\n\n       \nelse\n \nif\n \nobject\n \nis\n \na\n \nsquare\n\n           \nprint_square\n(\nobject\n)\n\n           \n:\n\n           \n:\n\n\n\n\n\n\nNot only is the code verbose and ugly, if you want to define a new compound data type that supports printing, you need to remember to come to this place and add in a new condition and call the corresponding print function.\n\n\nIn OO languages, you can have methods named \nprint()\n implemented differently in different classes.  When we compile the code above, the compiler will have no way to know which implementation will be called.  The bindings of \nprint()\n to the actual set of instructions will only be done at run time, after \nobj\n is instantiated from a class.  This is known as \ndynamic binding\n, or \nlate binding\n, or \ndynamic dispatch\n.\n\n\n\n\nIf you understand how an object is represented internally, this is not so magical after all.  Referring to the figure above, the array \nobjectsToPrint[]\n contains an array of references to objects, the first one is a \nCircle\n object, and the next two are \nPoint\n objects.  When \nobj.print()\n is invoked, Java refers to the method table, which points to either the method table for \nCircle\n or for \nPoint\n, based on the class the object is an instance of.\n\n\nThis behavior, which is common to OO programming languages, is known as \npolymorphism\n2\n.\n\n\nDRY - Don't Repeat Yourself\n\n\nWith the interface \nGeometricShape\n, we can implement other classes, such as \nRectangle\n, \nSquare\n, \nPolygon\n with the same interface.  For instance,\n\n\n1\n2\n3\nclass\n \nSquare\n \nimplements\n \nGeometricShape\n,\n \nPrintable\n \n{\n\n         \n// left as exercise (See Exercise 2)\n\n\n}\n\n\n\n\n\n\n\nSo far, we have been treating our shapes as pure geometric objects.  Let's consider an application where we want to paint the shapes.  Each shape should have a fill color and a border (with color and thickness).\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\nimport\n \njava.awt.Color\n;\n\n    \n:\n\n\n\nclass\n \nPaintedCircle\n \nimplements\n \nGeometricShape\n,\n \nPrintable\n \n{\n\n  \nprivate\n \nColor\n  \nfillColor\n;\n\n    \nprivate\n \nColor\n  \nborderColor\n;\n\n    \nprivate\n \ndouble\n \nborderThickness\n;\n\n\n    \npublic\n \nvoid\n \nfillWith\n(\nColor\n \nc\n)\n \n{\n\n        \nfillColor\n \n=\n \nc\n;\n\n    \n}\n\n\n    \npublic\n \nvoid\n \nsetBorderThickness\n(\ndouble\n \nt\n)\n \n{\n\n        \nborderThickness\n \n=\n \nt\n;\n\n    \n}\n\n\n    \npublic\n \nvoid\n \nsetBorderColor\n(\nColor\n \nc\n)\n \n{\n\n        \nborderColor\n \n=\n \nc\n;\n\n    \n}\n\n\n    \n// other methods and fields for Circle from before\n\n\n\n}\n\n\n\n\n\n\n\nIn the code above, we added the line \nimport\n \njava.awt.Color\n to use the \nColor class\n that Java provides, and added three private members as well as their setters.\n\n\nWe can do the same for \nSquare\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\nimport\n \njava.awt.Color\n;\n\n    \n:\n\n\n\nclass\n \nPaintedSquare\n \nimplements\n \nGeometricShape\n,\n \nPrintable\n \n{\n\n  \nprivate\n \nColor\n  \nfillColor\n;\n\n    \nprivate\n \nColor\n  \nborderColor\n;\n\n    \nprivate\n \ndouble\n \nborderThickness\n;\n\n\n    \npublic\n \nvoid\n \nfillWith\n(\nColor\n \nc\n)\n \n{\n\n        \nfillColor\n \n=\n \nc\n;\n\n    \n}\n\n\n    \npublic\n \nvoid\n \nsetBorderThickness\n(\ndouble\n \nt\n)\n \n{\n\n        \nborderThickness\n \n=\n \nt\n;\n\n    \n}\n\n\n    \npublic\n \nvoid\n \nsetBorderColor\n(\nColor\n \nc\n)\n \n{\n\n        \nborderColor\n \n=\n \nc\n;\n\n    \n}\n\n\n    \n// other methods and fields written for Square\n\n\n\n}\n\n\n\n\n\n\n\nand for other shapes.\n\n\nGreat!  We now have colorful shapes.  The code above, however, is not \ngood\n code, even though it is \ncorrect\n.  Consider what would need to be done if say, we decided to support border styles (dotted border, solid border, dashed border, etc).  We would have to edit every single class that supports colors and borders.!\n\n\nOne principle that we can follow is the \nabstraction principle\n, which says \"Each significant piece of functionality in a program should be implemented in just one place in the source code. Where similar functions are carried out by distinct pieces of code, it is generally beneficial to combine them into one by abstracting out the varying parts.\"\n3\n\n\nFollowing the principle, we want to implement these style-related fields and methods in just one place.  But where?\n\n\nInheritance\n\n\nThe OO-way to do this is to create a \nparent class\n, and put all common fields and methods into the parent.  A parent class is defined just like a normal class.  For instance:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\nclass\n \nPaintedShape\n \n{\n\n  \nprivate\n \nColor\n  \nfillColor\n;\n\n    \nprivate\n \nColor\n  \nborderColor\n;\n\n    \nprivate\n \ndouble\n \nborderThickness\n;\n\n\n  \npublic\n \nPaintedShape\n(\nColor\n \ninitFillColor\n,\n \nColor\n \ninitBorderColor\n,\n \ndouble\n \ninitBorderThickness\n)\n \n{\n\n        \nfillColor\n \n=\n \ninitFillColor\n;\n\n        \nborderColor\n \n=\n \ninitBorderColor\n;\n\n        \nborderThickness\n \n=\n \ninitBorderThickness\n;\n\n    \n}\n\n\n    \npublic\n \nvoid\n \nfillWith\n(\nColor\n \nc\n)\n \n{\n\n        \nfillColor\n \n=\n \nc\n;\n\n    \n}\n\n\n    \npublic\n \nvoid\n \nsetBorderThickness\n(\ndouble\n \nt\n)\n \n{\n\n        \nborderThickness\n \n=\n \nt\n;\n\n    \n}\n\n\n    \npublic\n \nvoid\n \nsetBorderColor\n(\nColor\n \nc\n)\n \n{\n\n        \nborderColor\n \n=\n \nc\n;\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nThe \nPaintedCircle\n class, \nPaintedSquare\n class, etc, can now \ninherits\n non-private fields and methods from the parent class, using the \nextends\n keyword.\n\n\n1\n2\n3\n4\n5\n6\n7\nclass\n \nPaintedCircle\n \nextends\n \nPaintedShape\n \nimplements\n \nGeometricShape\n,\n \nPrintable\n \n{\n\n      \n:\n\n\n}\n\n\n\nclass\n \nPaintedSquare\n \nextends\n \nPaintedShape\n \nimplements\n \nGeometricShape\n,\n \nPrintable\n \n{\n\n      \n:\n\n\n}\n\n\n\n\n\n\nThis mechanism for a class to inherit the properties and behavior from a parent is called \nInheritance\n, and is the forth and final basic OO principles we cover\n4\n.\n\n\nWith inheritance, we do not have to repeat the declaration of fields \nfillColor\n, \nborderColor\n, \nborderThickness\n and the associated methods in them.  This software engineering principle is also known as the DRY principle -- \"\ndon't repeat yourself\n\" principle.  We are going to see DRY again and again in future lectures.\n\n\nWe also call the \nPaintedShape\n the superclass (or base class) of \nPaintedCircle\n and \nPaintedSquare\n, and call \nPaintedCircle\n and \nPaintedSquare\n the subclass (or derived class)\n5\n of \nPaintedShape\n.\n\n\nA \nPaintedCircle\n object can now call \nfillWith()\n even if the method \nfillWith()\n is not defined in \nPaintedCircle\n -- it is defined in \nPaintedCircle\n's parent \nPaintedShape\n.  \n\n\nNow consider the constructor for \nPaintedCircle\n.   We need to initialize the geometric shape as well as the painting style.  But, we define the fields \nfillColor\n, etc \nprivate\n, and subclasses have no access to \nprivate\n fields in the parent.  We need to call the constructor of the parent to initialize these private fields.  The way to do this is to use the \nsuper\n keyword, like such:\n\n\n1\n2\n3\n4\n5\n  \npublic\n \nPaintedCircle\n(\nPoint\n \ninitCenter\n,\n \ndouble\n \ninitRadius\n,\n \nColor\n \ninitFillColor\n,\n \nColor\n \ninitBorderColor\n,\n \ndouble\n \ninitBorderThickness\n)\n \n{\n\n        \nsuper\n(\ninitFillColor\n,\n \ninitBorderColor\n,\n \ninitBorderThickness\n);\n\n        \nc\n \n=\n \ninitCenter\n;\n\n        \nr\n \n=\n \ninitRadius\n;\n\n    \n}\n\n\n\n\n\n\n\nYou can see that the constructor for \nPaintedCircle\n now takes in five parameters.  You can imagine that as the class get more sophisticated with more fields, we need to pass in more parameters to the class to initialize the fields.  It is not uncommon to provide alternative constructors with fewer parameters and assign some \ndefault\n values to the fields.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n  \n// create circle with default style (white with black border of thickness 1)\n\n  \npublic\n \nPaintedCircle\n(\nPoint\n \ninitCenter\n,\n \ndouble\n \ninitRadius\n)\n \n{\n\n      \nsuper\n(\nColor\n.\nWHITE\n,\n \nColor\n.\nBLACK\n,\n \n1.0\n);\n\n      \nc\n \n=\n \ninitCenter\n;\n\n      \nr\n \n=\n \ninitRadius\n;\n\n  \n}\n\n\n    \n// create circle with customized styles  \n\n  \npublic\n \nPaintedCircle\n(\nPoint\n \ninitCenter\n,\n \ndouble\n \ninitRadius\n,\n \nColor\n \ninitFillColor\n,\n \nColor\n \ninitBorderColor\n,\n \ndouble\n \ninitBorderThickness\n)\n \n{\n\n        \nsuper\n(\ninitFillColor\n,\n \ninitBorderColor\n,\n \ninitBorderThickness\n);\n\n        \nc\n \n=\n \ninitCenter\n;\n\n        \nr\n \n=\n \ninitRadius\n;\n\n    \n}\n\n\n\n\n\n\n\nTwo methods in a class can have the same name and still co-exist peacefully together.  This is called \noverloading\n.  When a method is called, we look at the \nsignature\n of the method, which consists of (i) the name of the method, (ii) the number, order, and type of the arguments, to determine which method is called.  To be precise, the first sentence of this paragraph should read: Two methods in a class can have the same name and still co-exist peacefully together, as long as they have different signatures.  Note that the return type is not part of the method signature, so you cannot have two methods with the same name and same arguments but different return type.  \n\n\nEven though the example above shows overloading of the constructor, we can overload other methods as well.\n\n\nJava \nObject\n class\n\n\nIn Java, every class inherits from the \nclass \nObject\n implicitly.  The \nObject\n class defines many useful methods that are common to all objects.  The two useful ones are :\n\n\n\n\nequals(Object obj)\n, which checks if two objects are equal to each other, and\n\n\ntoString()\n, which returns a string representation of the object, and is a better way to print an object than the \nprint()\n method and \nPrintable\n interface we write\n6\n.\n\n\n\n\nThe \nequals()\n method as implemented in \nObject\n, only compares if two object references refer to the same object In the Figure below, we show an array \ncircles\n with three \nCircle\n objects.  All three circles are centered at (0, 0) with radius 10.  They are created as follows:\n\n\n1\n2\n3\n4\n    \nCircle\n[]\n \ncircles\n \n=\n \nnew\n \nCircle\n[\n3\n];\n\n    \ncircles\n[\n0\n]\n \n=\n \nnew\n \nCircle\n(\nnew\n \nPoint\n(\n0\n,\n \n0\n),\n \n10\n);\n\n    \ncircles\n[\n1\n]\n \n=\n \nnew\n \nCircle\n(\nnew\n \nPoint\n(\n0\n,\n \n0\n),\n \n10\n);\n\n    \ncircles\n[\n2\n]\n \n=\n \ncircles\n[\n1\n];\n\n\n\n\n\n\n\nWhen you check \ncircles[0].equals(circles[1])\n, however, it returns \nfalse\n, because even though \ncircles[0]\n and \ncircles[1]\n are semantically the same, they refer to the two different objects.  Calling \ncircles[1].equals(circles[2])\n returns \ntrue\n, as they are referring to the same object.  \n\n\n\n\nWhat if you need a method that compares if two circles are semantically the same?  You can implement your own method, say \nisTheSameCircle(Circle c)\n.  But, the \nequals()\n method is universal (all classes inherits this method) and is used by other classes for equality tests.  So, in most cases, we can implement a method called \nequals()\n with the same signature with the semantic that we want\n7\n.\n\n\nThat's right.  Even though we cannot have two methods with the same signature in the same class, we can have two methods with the same signature, one in the superclass (or the superclass's superclass, and so on), one in the subclass.  The method in the subclass will override the method in the superclass.  For example,\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n    \nclass\n \nCircle\n \nimplements\n \nShape\n,\n \nPrintable\n \n{\n\n     \n:\n\n         \n@Override\n\n         \npublic\n \nboolean\n \nequals\n(\nObject\n \nobj\n)\n \n{\n\n             \nif\n \n(\nobj\n \ninstanceof\n \nCircle\n)\n \n{\n\n                 \nCircle\n \ncircle\n \n=\n \n(\nCircle\n)\n \nobj\n;\n\n                 \nreturn\n \n(\ncircle\n.\ncenter\n.\nequals\n(\ncenter\n)\n \n&&\n \ncircle\n.\nradius\n \n==\n \nradius\n);\n\n             \n}\n \nelse\n\n               \nreturn\n \nfalse\n;\n\n         \n}\n\n    \n}\n\n\n\n\n\n\n\nLine 7 above compares if the two center points are equals, and the two radius values are equals.  So, we compare if the two circles are semantically the same.  The rest of this code requires some explanation:\n\n\n\n\nLine 3 uses the same \n@Override\n annotation that we have seen before -- we are telling the compilers that we are overriding a method in the superclass.\n\n\nLine 4 declares the method \nequals\n, and note that it has to have exactly the same signature as the \nequals()\n method we are overriding.  Even though we meant to compare two \nCircle\n objects, we cannot declare it as \npublic boolean equals(Circle circle)\n, since the signature is different and the compiler would complain.\n\n\nSince \nobj\n is of an \nObject\n type, we can actually pass in any object to compare with a \nCircle\n.  Line 5 checks if the comparison makes sense, by checking if \nobj\n is instantiated from a \nCircle\n class, using the \ninstanceof\n keyword.  If \nobj\n is not even a \nCircle\n object, then we simply return \nfalse\n.\n\n\nIf \nobj\n is an instance of \nCircle\n, we assign \nobj\n to a variable of type \nCircle\n, and compare as in Line 7.\n\n\n\n\nFor the code above to work, we have to override the \nequals\n method of \nPoint\n as well.  That is left as an exercise.\n\n\nOne final note: polymorphism works here as well.  If we have an object reference \nobj\n of type \nObject\n that refers to an instance of a \nCircle\n, calling \nobj.equals()\n will invoke the \nequals()\n method of \nCircle\n, not \nObject\n, just like the case of interfaces.\n\n\n\n\n\n\n\n\n\n\nRemember a function is just an abstraction over a set of instructions.\u00a0\n\u21a9\n\n\n\n\n\n\nIn biology, polymorphism means that an organism can have many different forms.\u00a0\n\u21a9\n\n\n\n\n\n\nThis principle is formulated by Benjamin C. Pierce in his book \nTypes and Programming Languages\n.\u00a0\n\u21a9\n\n\n\n\n\n\nThe other three is encapsulation, abstraction, and polymorphism.\u00a0\n\u21a9\n\n\n\n\n\n\nAgain, you see that computer scientist can be quite indecisive when it comes to the terminologies in OOP.\u00a0\n\u21a9\n\n\n\n\n\n\nWe leave this for another lesson on another day.  \u00a0\n\u21a9\n\n\n\n\n\n\nIf you override \nequals()\n you should generally override \nhashCode()\n as well, but let's leave that for another lesson on another day.\u00a0\n\u21a9",
            "title": "2. Inheritance & Polymorphism"
        },
        {
            "location": "/lec2/index.html#lecture-2-inheritance-polymorphism",
            "text": "",
            "title": "Lecture 2: Inheritance &amp; Polymorphism"
        },
        {
            "location": "/lec2/index.html#learning-objectives",
            "text": "After this lecture, students should:   understand that Java is a type-safe language, in contrast to C  be familiar with Java variable and primitive types  understand the concepts of object-oriented programming, including interface, polymorphism, late binding, inheritance, method overriding and method overloading, and their purposes of introducing them as a method of programming.  know the purpose and usage of Java keywords  implements ,  extends ,  super ,  instanceof , and  @Override  understand Java concepts of arrays, enhanced  for  loop, method signature,  Object  class, and object equality.",
            "title": "Learning Objectives"
        },
        {
            "location": "/lec2/index.html#type-safety",
            "text": "Recall that the  type  of a variable tells the compiler how to interpret the bits that represent the value of a variable and how to manipulate the variable.  The compiler also uses the type to decide how much memory is allocated for each variable.    Some languages are stricter in terms of type \"compatibility\" than others.  C compilers, however, are not very strict.  If it detects something strange with the type you used, it will issue a warning, but still let your code compiles and run.  Take:  1\n2\n3\n4\n5 #include   <stdio.h>  int   main ()  { \n     printf ( \"%d \\n \" ,   \"cs2030\" );  }    In Line 4, we treat the address to a string as integer.  This generates a compiler's warning.  In C, you can  type cast  a variable from one type into another, i.e., force the compiler to treat a variable of one type as another type.  The compiler would listen and do that for you.  The following code would print out gibberish and would compile perfectly without error.  1\n2\n3\n4\n5 #include   <stdio.h>  int   main ()  { \n     printf ( \"%d \\n \" ,   ( int ) \"cs2030\" );  }    Such flexibility and loose rules for type compatibility could be useful, if you know what you are doing, but for most programmers, it could be a major source of unintentional bugs, especially if one does not pay attention to compiler's warning or one forces the warning to go away without fully understanding what is going on.  Java is very strict when it comes to type checking, and is one of the  type-safe  languages. Java ensures that basic operations (such as  + ,  - , etc) and method calls apply to values in a way that makes sense.  If you try to pull the same trick as above, you will receive an error:    Java Primitive Data Types  Java supports eight  primitive  data types:  byte ,  short ,  int ,  long ,  float ,  double ,  boolean  and  char .  If you are familiar with C, these data types should not be foreign to you.  One important difference is that a  char  variable stores a 16-bit Unicode character, not an 8-bit character like in C.  Java uses  byte  for that.  The other notable difference is that Java defines  true  and  false  as possible value to a  boolean , unlike C which uses  0  for false and non- 0  for true.    You can read all about Java  variables  and  primitive data types  in Oracle's Java Tutorial.",
            "title": "Type Safety"
        },
        {
            "location": "/lec2/index.html#enforcing-abstraction-barrier-with-interface",
            "text": "Recall the concept of encapsulation. When we develop a large piece of software, it is important to hide the details about data representation and implementation, and only exposes certain  public  methods for the users to use.  We imagine that there is an abstraction barrier between the code that implements the internals of a class (called the  implementer ) and the code that uses the class (called the  user ) to achieve a higher level task.  We have seen that we use  private  to enforce data hiding -- to hide certain fields and methods from outside of the barrier.  Now, we are going to see how we enforce that the right set of methods are defined, implemented, and used on both sides of the barrier.  The mechanism to do this is through defining an  interface  (aka a  protocol  as it is called in Objective-C or Swift).  An interface is kinda like a contract between the implementer of a class and the user of a class.  If a class promises to implement an interface, then we are guaranteed that the methods defined in the interface are implemented in the class as it is promised.  Otherwise, the code would not compile.  In Java, we can define an interface using  interface  keyword:  1\n2\n3\n4\n5 interface   GeometricShape   { \n     public   double   getArea (); \n     public   double   getPerimeter (); \n     public   boolean   contains ( Point   p );  }    The example interface  GeometricShape  above contains only the declaration of the methods, not the implementation.    Now, let's see how the implementer would implement a class using the interface.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29 import   java.lang.Math ;  class   Circle   implements   GeometricShape   { \n     private   Point   center ; \n     private   double   radius ; \n\n     public   Circle ( Point   initCenter ,   double   initR )   { \n         center   =   initCenter ; \n         radius   =   initR ; \n     } \n\n     void   moveTo ( Point   p )   { \n         center   =   p ; \n     } \n\n     @Override \n     public   double   getArea ()   { \n         return   Math . PI * radius * radius ; \n     } \n\n     @Override \n     public   boolean   contains ( Point   p )   { \n         return   ( p . distance ( center )   <   radius ); \n     } \n\n     @Override \n     public   double   getPerimeter ()   { \n         return   Math . PI * 2 * radius ; \n     }  }    This is very similar to the code you saw in Lecture 1 and Exercise 1, except that in Line 2, we say that  class   Circle   implements   GeometricShape .  This line informs the compiler that the programmer intends to implement all the methods included in the interface  GeometricShape  exactly as declared (in terms of names, the number of arguments, the types of arguments, returned type, and access modifier).  The rest of the class is the same, except that we renamed  getCircumference  with  getPerimeter , which is more general and apply to all shapes.  You will also see that we added  annotations  to our code by adding the line  @Override  before methods in  Circle  that implements the methods declared in  GeometricShape .  This annotation is optional, but it informs our intention to the compiler and helps make the intention of the programmer clearer to others who read the code.   Java Annotation  Annotations are metadata we add that is not part of the code.  Annotation does not affect execution.  They are useful to compilers and other software tools, as well as humans who read the code.  While we can similarly make the code more human-friendly with comments, an annotation is structured and so can be easily parsed by software.   @Override  is probably going to be the only annotation useful for us in this class.   Note that we can have other methods (such as  moveTo ) in the class beyond what is promised in the interface the class implements.  A class can implement more than one interfaces.  For instance, let's say that we have another interface called  Printable [^1] with a single method defined:  1\n2\n3 interface   Printable   { \n     public   void   print ();  }    The implementer of  Circle  wants to inform the users that the method  void print()  is implemented, it can do the following:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10 class   Circle   implements   GeometricShape ,   Printable   { \n      : \n      : \n      @Override \n      public   void   print ()   { \n          System . out . printf ( \"radius: %f\\n\" ,   radius ); \n          System . out . printf ( \"center:\" ); \n          center . print (); \n      }  }    In the above, we call  print()  on the  Point  object as well.  How do we know that  Point  provides a  print()  method?  Well, we can read the implementation code of  Point , or we can agree with the implementer of  Point  that  Point  provides a  Printable  interface!    It is important to know that,  interface  provides a  syntactic  contract on the abstraction barrier, but it does not provide a  semantic  contract.  It does not, for instance, guarantee that  print()  actually prints something to the screen.  One could still implement interface  Printable  as follows:  1\n2\n3\n4\n5\n6\n7 class   Circle   implements   GeometricShape ,   Printable   { \n      : \n      : \n      @Override \n      public   void   print ()   { \n      }  }    and the code still compiles!  Not all programming languages that support classes support interface.  Javascript and Python, for instance, does not support similar concepts.",
            "title": "Enforcing Abstraction Barrier with Interface"
        },
        {
            "location": "/lec2/index.html#interface-as-types",
            "text": "In Java, an interface is a type.  What this means is that:   We can declare a variable with an interface type, such as: 1      GeometricShape   circle ;   \nor 1      Printable   circle ;   \nWe cannot, however, instantiate an object from an interface\nsince an interface is a \"template\", an \"abstraction\", and does not have an implementation.  For instance:   1\n2\n3\n4      // this is not OK \n     Printable   p   =   new   Printable (); \n     // this is OK \n     Printable   circle   =   new   Circle ( new   Point ( 0 ,   0 ),   10 );      Similarly, we can pass arguments of an interface type into a method, and the return type of a method can be an interface.    An object can be an instance of multiple types.  Recall that Java is a statically typed language. We associate a type with a variable.  We can assign a variable to an object if the object is an instance of the type of the variable.  Line 4 above, for instance, creates a new circle, which is an instance of three types:  Circle ,  GeometricShape , and  Printable .  It is ok to assign this new circle to a variable of type  Printable .    We can now do something cool like this: 1\n2\n3\n4\n5\n6\n7      Printable []   objectsToPrint ; \n       : \n       // initialize array objectsToPrint \n     : \n     for   ( Printable   obj :   objectsToPrint )   { \n         obj . print (); \n     }    Let's look at this code in more details.  Line 1 declares an array of objects of type  Printable .  We skip over the code to initialize the content of the array for now, and\njump to Line 5-7, which is a  for  loop.  Line 5 declares a loop variable  obj  of type  Printable  and loops through all objects in the array  objectsToPrint , and Line 6 invoke the method  print  of  obj .   Array and For Loops in Java  See Oracle's tutorial on  array  and  enhanced loop   The magic happens in Line 6:   First, since we now that any object in the array has the type  Printable , this means that they must implement the  Printable  interface and support the method  print() .    Second, we do not know, and we do not  need  to know which class an object is an instance of.  Third, we can actually have objects of completely unrelated classes in the same array. We can have objects of type  Circle , and objects of type  Point .  We can have objects of type  Factory , or objects of type  Student , or objects of type  Cushion .  As long as the objects implement the  Printable  interface, we can put them into the same array.  Forth, at  run time , Java looks at  obj , and determines its class, and invoke the right implementation of  print()  corresponding to the  obj .  That is, if  obj  is an instance of a class  Circle , then it will call  print()  method of  Circle ; if  obj  is an instance of a class  Point , then it will call  print()  method of  Point , and so on.   To further appreciate the magic that happens in Line 6, especially the last point above, consider how function call is done in C.  In C, you cannot have two functions of the same name within the same scope, so if you call a function  print() , you know exactly which set of instructions will be called 1 .  So, the name  print  is bound to the corresponding set of instructions at compilation time.  This is called  static binding  or  early binding .\nTo have  print()  for different types, we need to name them differently to avoid naming conflicts: e.g.,  print_point() ,  print_circle() .  In a language with static binding, suppose you want to mix objects of different types\ntogether in an array, you need to do something like the following pseudocode: 1\n2\n3\n4\n5\n6\n7\n8\n9     for   each   object   in   the   array \n        if   object   is   a   point \n            print_point ( object ) \n        else   if   object   is   a   circle \n            print_circle ( object ) \n        else   if   object   is   a   square \n            print_square ( object ) \n            : \n            :    Not only is the code verbose and ugly, if you want to define a new compound data type that supports printing, you need to remember to come to this place and add in a new condition and call the corresponding print function.  In OO languages, you can have methods named  print()  implemented differently in different classes.  When we compile the code above, the compiler will have no way to know which implementation will be called.  The bindings of  print()  to the actual set of instructions will only be done at run time, after  obj  is instantiated from a class.  This is known as  dynamic binding , or  late binding , or  dynamic dispatch .   If you understand how an object is represented internally, this is not so magical after all.  Referring to the figure above, the array  objectsToPrint[]  contains an array of references to objects, the first one is a  Circle  object, and the next two are  Point  objects.  When  obj.print()  is invoked, Java refers to the method table, which points to either the method table for  Circle  or for  Point , based on the class the object is an instance of.  This behavior, which is common to OO programming languages, is known as  polymorphism 2 .",
            "title": "Interface as Types"
        },
        {
            "location": "/lec2/index.html#dry-dont-repeat-yourself",
            "text": "With the interface  GeometricShape , we can implement other classes, such as  Rectangle ,  Square ,  Polygon  with the same interface.  For instance,  1\n2\n3 class   Square   implements   GeometricShape ,   Printable   { \n          // left as exercise (See Exercise 2)  }    So far, we have been treating our shapes as pure geometric objects.  Let's consider an application where we want to paint the shapes.  Each shape should have a fill color and a border (with color and thickness).   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23 import   java.awt.Color ; \n     :  class   PaintedCircle   implements   GeometricShape ,   Printable   { \n   private   Color    fillColor ; \n     private   Color    borderColor ; \n     private   double   borderThickness ; \n\n     public   void   fillWith ( Color   c )   { \n         fillColor   =   c ; \n     } \n\n     public   void   setBorderThickness ( double   t )   { \n         borderThickness   =   t ; \n     } \n\n     public   void   setBorderColor ( Color   c )   { \n         borderColor   =   c ; \n     } \n\n     // other methods and fields for Circle from before  }    In the code above, we added the line  import   java.awt.Color  to use the  Color class  that Java provides, and added three private members as well as their setters.  We can do the same for  Square   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23 import   java.awt.Color ; \n     :  class   PaintedSquare   implements   GeometricShape ,   Printable   { \n   private   Color    fillColor ; \n     private   Color    borderColor ; \n     private   double   borderThickness ; \n\n     public   void   fillWith ( Color   c )   { \n         fillColor   =   c ; \n     } \n\n     public   void   setBorderThickness ( double   t )   { \n         borderThickness   =   t ; \n     } \n\n     public   void   setBorderColor ( Color   c )   { \n         borderColor   =   c ; \n     } \n\n     // other methods and fields written for Square  }    and for other shapes.  Great!  We now have colorful shapes.  The code above, however, is not  good  code, even though it is  correct .  Consider what would need to be done if say, we decided to support border styles (dotted border, solid border, dashed border, etc).  We would have to edit every single class that supports colors and borders.!  One principle that we can follow is the  abstraction principle , which says \"Each significant piece of functionality in a program should be implemented in just one place in the source code. Where similar functions are carried out by distinct pieces of code, it is generally beneficial to combine them into one by abstracting out the varying parts.\" 3  Following the principle, we want to implement these style-related fields and methods in just one place.  But where?",
            "title": "DRY - Don't Repeat Yourself"
        },
        {
            "location": "/lec2/index.html#inheritance",
            "text": "The OO-way to do this is to create a  parent class , and put all common fields and methods into the parent.  A parent class is defined just like a normal class.  For instance:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23 class   PaintedShape   { \n   private   Color    fillColor ; \n     private   Color    borderColor ; \n     private   double   borderThickness ; \n\n   public   PaintedShape ( Color   initFillColor ,   Color   initBorderColor ,   double   initBorderThickness )   { \n         fillColor   =   initFillColor ; \n         borderColor   =   initBorderColor ; \n         borderThickness   =   initBorderThickness ; \n     } \n\n     public   void   fillWith ( Color   c )   { \n         fillColor   =   c ; \n     } \n\n     public   void   setBorderThickness ( double   t )   { \n         borderThickness   =   t ; \n     } \n\n     public   void   setBorderColor ( Color   c )   { \n         borderColor   =   c ; \n     }  }    The  PaintedCircle  class,  PaintedSquare  class, etc, can now  inherits  non-private fields and methods from the parent class, using the  extends  keyword.  1\n2\n3\n4\n5\n6\n7 class   PaintedCircle   extends   PaintedShape   implements   GeometricShape ,   Printable   { \n       :  }  class   PaintedSquare   extends   PaintedShape   implements   GeometricShape ,   Printable   { \n       :  }    This mechanism for a class to inherit the properties and behavior from a parent is called  Inheritance , and is the forth and final basic OO principles we cover 4 .  With inheritance, we do not have to repeat the declaration of fields  fillColor ,  borderColor ,  borderThickness  and the associated methods in them.  This software engineering principle is also known as the DRY principle -- \" don't repeat yourself \" principle.  We are going to see DRY again and again in future lectures.  We also call the  PaintedShape  the superclass (or base class) of  PaintedCircle  and  PaintedSquare , and call  PaintedCircle  and  PaintedSquare  the subclass (or derived class) 5  of  PaintedShape .  A  PaintedCircle  object can now call  fillWith()  even if the method  fillWith()  is not defined in  PaintedCircle  -- it is defined in  PaintedCircle 's parent  PaintedShape .    Now consider the constructor for  PaintedCircle .   We need to initialize the geometric shape as well as the painting style.  But, we define the fields  fillColor , etc  private , and subclasses have no access to  private  fields in the parent.  We need to call the constructor of the parent to initialize these private fields.  The way to do this is to use the  super  keyword, like such:  1\n2\n3\n4\n5    public   PaintedCircle ( Point   initCenter ,   double   initRadius ,   Color   initFillColor ,   Color   initBorderColor ,   double   initBorderThickness )   { \n         super ( initFillColor ,   initBorderColor ,   initBorderThickness ); \n         c   =   initCenter ; \n         r   =   initRadius ; \n     }    You can see that the constructor for  PaintedCircle  now takes in five parameters.  You can imagine that as the class get more sophisticated with more fields, we need to pass in more parameters to the class to initialize the fields.  It is not uncommon to provide alternative constructors with fewer parameters and assign some  default  values to the fields.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13    // create circle with default style (white with black border of thickness 1) \n   public   PaintedCircle ( Point   initCenter ,   double   initRadius )   { \n       super ( Color . WHITE ,   Color . BLACK ,   1.0 ); \n       c   =   initCenter ; \n       r   =   initRadius ; \n   } \n\n     // create circle with customized styles   \n   public   PaintedCircle ( Point   initCenter ,   double   initRadius ,   Color   initFillColor ,   Color   initBorderColor ,   double   initBorderThickness )   { \n         super ( initFillColor ,   initBorderColor ,   initBorderThickness ); \n         c   =   initCenter ; \n         r   =   initRadius ; \n     }    Two methods in a class can have the same name and still co-exist peacefully together.  This is called  overloading .  When a method is called, we look at the  signature  of the method, which consists of (i) the name of the method, (ii) the number, order, and type of the arguments, to determine which method is called.  To be precise, the first sentence of this paragraph should read: Two methods in a class can have the same name and still co-exist peacefully together, as long as they have different signatures.  Note that the return type is not part of the method signature, so you cannot have two methods with the same name and same arguments but different return type.    Even though the example above shows overloading of the constructor, we can overload other methods as well.",
            "title": "Inheritance"
        },
        {
            "location": "/lec2/index.html#java-object-class",
            "text": "In Java, every class inherits from the  class  Object  implicitly.  The  Object  class defines many useful methods that are common to all objects.  The two useful ones are :   equals(Object obj) , which checks if two objects are equal to each other, and  toString() , which returns a string representation of the object, and is a better way to print an object than the  print()  method and  Printable  interface we write 6 .   The  equals()  method as implemented in  Object , only compares if two object references refer to the same object In the Figure below, we show an array  circles  with three  Circle  objects.  All three circles are centered at (0, 0) with radius 10.  They are created as follows:  1\n2\n3\n4      Circle []   circles   =   new   Circle [ 3 ]; \n     circles [ 0 ]   =   new   Circle ( new   Point ( 0 ,   0 ),   10 ); \n     circles [ 1 ]   =   new   Circle ( new   Point ( 0 ,   0 ),   10 ); \n     circles [ 2 ]   =   circles [ 1 ];    When you check  circles[0].equals(circles[1]) , however, it returns  false , because even though  circles[0]  and  circles[1]  are semantically the same, they refer to the two different objects.  Calling  circles[1].equals(circles[2])  returns  true , as they are referring to the same object.     What if you need a method that compares if two circles are semantically the same?  You can implement your own method, say  isTheSameCircle(Circle c) .  But, the  equals()  method is universal (all classes inherits this method) and is used by other classes for equality tests.  So, in most cases, we can implement a method called  equals()  with the same signature with the semantic that we want 7 .  That's right.  Even though we cannot have two methods with the same signature in the same class, we can have two methods with the same signature, one in the superclass (or the superclass's superclass, and so on), one in the subclass.  The method in the subclass will override the method in the superclass.  For example,   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11      class   Circle   implements   Shape ,   Printable   { \n      : \n          @Override \n          public   boolean   equals ( Object   obj )   { \n              if   ( obj   instanceof   Circle )   { \n                  Circle   circle   =   ( Circle )   obj ; \n                  return   ( circle . center . equals ( center )   &&   circle . radius   ==   radius ); \n              }   else \n                return   false ; \n          } \n     }    Line 7 above compares if the two center points are equals, and the two radius values are equals.  So, we compare if the two circles are semantically the same.  The rest of this code requires some explanation:   Line 3 uses the same  @Override  annotation that we have seen before -- we are telling the compilers that we are overriding a method in the superclass.  Line 4 declares the method  equals , and note that it has to have exactly the same signature as the  equals()  method we are overriding.  Even though we meant to compare two  Circle  objects, we cannot declare it as  public boolean equals(Circle circle) , since the signature is different and the compiler would complain.  Since  obj  is of an  Object  type, we can actually pass in any object to compare with a  Circle .  Line 5 checks if the comparison makes sense, by checking if  obj  is instantiated from a  Circle  class, using the  instanceof  keyword.  If  obj  is not even a  Circle  object, then we simply return  false .  If  obj  is an instance of  Circle , we assign  obj  to a variable of type  Circle , and compare as in Line 7.   For the code above to work, we have to override the  equals  method of  Point  as well.  That is left as an exercise.  One final note: polymorphism works here as well.  If we have an object reference  obj  of type  Object  that refers to an instance of a  Circle , calling  obj.equals()  will invoke the  equals()  method of  Circle , not  Object , just like the case of interfaces.      Remember a function is just an abstraction over a set of instructions.\u00a0 \u21a9    In biology, polymorphism means that an organism can have many different forms.\u00a0 \u21a9    This principle is formulated by Benjamin C. Pierce in his book  Types and Programming Languages .\u00a0 \u21a9    The other three is encapsulation, abstraction, and polymorphism.\u00a0 \u21a9    Again, you see that computer scientist can be quite indecisive when it comes to the terminologies in OOP.\u00a0 \u21a9    We leave this for another lesson on another day.  \u00a0 \u21a9    If you override  equals()  you should generally override  hashCode()  as well, but let's leave that for another lesson on another day.\u00a0 \u21a9",
            "title": "Java Object class"
        },
        {
            "location": "/lec3/index.html",
            "text": "Lecture 3: Inheritance, Continued\n\n\nLearning Objectives\n\n\nAt the end of this lecture, students should\n\n\n\n\nbe familiar with how Java dispatches methods that have been overridden\n\n\nappreciate the usefulness of overriding \nequals\n and \ntoString\n in the \nObject\n class\n\n\nbe exposed to the \nString\n class and its associated methods, especially the \n+\n operator\n\n\nbe aware that inheritance can be abused to provide bad code\n\n\nunderstand the differences between HAS-A and IS-A relationship\n\n\nbe able to use composition to model classes with HAS-A relationship\n\n\nbe able to use inheritance to model classes with IS-A relationship\n\n\nunderstand the Liskov Substitution Principle and thus be aware that not all IS-A relationship should be modelled with inheritance\n\n\nunderstand the purposes of the Java keywords \nthis\n, \nfinal\n, \nabstract\n and \ndefault\n\n\n\n\nMethod Overriding\n\n\nDuring Lecture 2, I introduced the concept of inheritance.  Today, let's go deeper into how inheritance and its associated concepts work.\n\n\nConsider the class \nCircle\n, which inherits from \nObject\n.  We have seen that \nObject\n defines some non-private methods, which can be inherited by \nCircle\n.\nThese methods will be made available in the \nCircle\n class.  In the internal representation of the class, the methods will be made available in the method table of \nCircle\n.  You can view the fields and methods of class \nCircle\n as containing the fields and methods of \nObject\n, followed by fields and methods defined in \nCircle\n.\n\n\nThe figure below illustrates this.  I use a slightly darker green to represent the methods implemented in the \nObject\n class, and light green to represent methods implemented in the \nCircle\n class.\n\n\n\n\nRecall that when a class implements an interface, an instance of that class can take on the type of that interface.  Similarly, when a class inherits from a parent class, an instance of that class can take on the type of the parent class.  So, we can do the following:\n\n\n1\n2\nCircle\n \nc\n \n=\n \nnew\n \nCircle\n(\nnew\n \nPoint\n(\n0\n,\n0\n),\n \n10\n);\n\n\nObject\n \no\n \n=\n \nc\n;\n\n\n\n\n\n\n\nLine 2 assigns the circle object \nc\n to \no\n of type \nObject\n.  So, both \no\n and \nc\n are referring to the same objects.  Due to type checking at compile time, however, Java does not allow methods and fields in the subclass (e.g., \nCircle\n) that is not in the superclass (e.g., \nObject\n) to be called.  In this example, only the methods known to \nObject\n can be accessed by \no\n.\n\n\nNow, consider what would happen if we override the method \nequals()\n from the \nObject\n class.  This is what we did in the last lecture.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n    \nclass\n \nCircle\n \nimplements\n \nShape\n,\n \nPrintable\n \n{\n\n     \n:\n\n         \n@Override\n\n         \npublic\n \nboolean\n \nequals\n(\nObject\n \nobj\n)\n \n{\n\n             \nif\n \n(\nobj\n \ninstanceof\n \nCircle\n)\n \n{\n\n                 \nCircle\n \ncircle\n \n=\n \n(\nCircle\n)\n \nobj\n;\n\n                 \nreturn\n \n(\ncircle\n.\ncenter\n.\nequals\n(\ncenter\n)\n \n&&\n \ncircle\n.\nradius\n \n==\n \nradius\n);\n\n             \n}\n \nelse\n\n               \nreturn\n \nfalse\n;\n\n         \n}\n\n    \n}\n\n\n\n\n\n\n\n\n\nEquality for Point\n\n\nRecall that we override \nequals\n because we want to compare the content of the two circles, instead of comparing if two circle references point to the same object.  For the implementation above to be correct, we need to override the \nequals\n function for the \nPoint\n class as well.  This is not shown in class and left as an exercise.\n\n\n\n\nThe method table will update the entry for \nequals()\n to point to the implementation provided by the \nCircle\n class, instead of the \nObject\n class.\n\n\n\n\nNow, consider what would happen if we \noverload\n the method \nequals()\n with one that takes in a \nCircle\n object.  I also throw in a couple of \nSystem.out.print()\n to help us figure out what is going on.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n    \nclass\n \nCircle\n \nimplements\n \nShape\n,\n \nPrintable\n \n{\n\n     \n:\n\n         \n@Override\n\n         \npublic\n \nboolean\n \nequals\n(\nObject\n \nobj\n)\n \n{\n\n             \nSystem\n.\nout\n.\nprint\n(\n\"equals(Object) called\\n\"\n);\n\n             \nif\n \n(\nobj\n \ninstanceof\n \nCircle\n)\n \n{\n\n                 \nCircle\n \ncircle\n \n=\n \n(\nCircle\n)\n \nobj\n;\n\n                 \nreturn\n \n((\ncircle\n.\ncenter\n.\nequals\n(\ncenter\n)\n \n&&\n \ncircle\n.\nradius\n \n==\n \nradius\n);\n\n             \n}\n \nelse\n\n               \nreturn\n \nfalse\n;\n\n         \n}\n\n\n         \npublic\n \nboolean\n \nequals\n(\nCircle\n \ncircle\n)\n \n{\n\n             \nSystem\n.\nout\n.\nprint\n(\n\"equals(Circle) called\\n\"\n);\n\n             \nreturn\n \n((\ncircle\n.\ncenter\n.\nequals\n(\ncenter\n)\n \n&&\n \ncircle\n.\nradius\n \n==\n \nradius\n);\n\n         \n}\n\n    \n}\n\n\n\n\n\n\n\nSince this new \nequals()\n method does not override the method in \nObject\n, it gets its own slot in the method table of \nCircle\n, instead of reusing one from the \nObject\n.\n\n\n\n\nNow, consider which version of \nequals\n are called by the following:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\nCircle\n \nc1\n \n=\n \nnew\n \nCircle\n(\nnew\n \nPoint\n(\n0\n,\n0\n),\n \n10\n);\n\n\nCircle\n \nc2\n \n=\n \nnew\n \nCircle\n(\nnew\n \nPoint\n(\n0\n,\n0\n),\n \n10\n);\n\n\nObject\n \no1\n \n=\n \nc1\n;\n\n\nObject\n \no2\n \n=\n \nc2\n;\n\n\n\no1\n.\nequals\n(\no2\n);\n\n\no1\n.\nequals\n((\nCircle\n)\no2\n);\n\n\no1\n.\nequals\n(\nc2\n);\n\n\nc1\n.\nequals\n(\no2\n);\n\n\nc1\n.\nequals\n((\nCircle\n)\no2\n);\n\n\nc1\n.\nequals\n(\nc2\n);\n\n\n\n\n\n\n\nLines 6-9 call \nequals(Object)\n defined in \nCircle\n\uff0c while Lines 10-11 call \nequals(Circle)\n defined in \nCircle\n.  Let's look at why for each one:\n\n\n\n\nLine 6 calls \nequals\n of an \nObject\n object on an \nObject\n object.  Java checks through all methods defined in \nObject\n, and finds a method that matches the signature, which is the \nequals(Object)\n (which \nCircle\n has overridden). This is the one that will get called.\n\n\nLine 7-8 call \nequals\n of an \nObject\n object on a \nCircle\n object.  Java checks through all methods defined in \nObject\n, and finds one method that matches the signature, which is \nequals(Object)\n (which \nCircle\n has overridden).  Even though there is another method \nequals(Circle)\n defined, it is defined as part of the \nCircle\n class, which Java refuses to access because \no1\n is declared to have the type \nObject\n.  Since the only method that Java can find has an argument of type \nObject\n, the argument is cast as an \nObject\n when \nequals\n is invoked.\n\n\nLine 9 calls \nequals\n of a \nCircle\n object on an \nObject\n object.  Java finds a method with matching signature, \nequals(Object)\n, and invokes that.\n\n\nFinal 10-11 calls \nequals\n of a \nCircle\n object on a \nCircle\n object.  Java finds a method with matching signature, \nequals(Circle)\n, and invokes that.\n\n\n\n\nAnother question that came up is why we need to override \nequals\n in \nObject\n, rather than just using the \nCircle\n-specific \nequals(Circle)\n.  As shown above, only when an object declared as \nCircle\n calls \nequals\n on another \nCircle\n object, the \nCircle\n-specific \nequals(Circle)\n is invoked.  \n\n\nTo write code that is general and reusable, we should exploit OO polymorphism, that means different subclasses of \nObject\n implement their own customized version of \nequals\n, and the right version of \nequals\n will be called.\n\n\nOne example of where this is called the \ncontains(Object)\n method from class \nArrayList\n (we will cover this later in class), which checks if an object is already in the list, and to check this, it checks for equality of the given object with every object in the \nArrayList\n, by calling \nequals(Object)\n.\n\n\nWe now turn our attention to another method in \nObject\n that we could override, the \ntoString()\n method.  \ntoString()\n is called whenever the \nString\n representation of an object is needed.  For instance, when we try to print an object.   By default, the \ntoString\n of \nObject\n simply prints the name of the class, followed by \n@\n, followed by the reference.   It is often useful to override this to include the content of the object as well, for debugging and logging purposes.  This is a much more useful and flexible than writing our own \nprint()\n method as we have seen in earlier lectures, since we are not limited to printing to standard output anymore.\n\n\n\n\njava.lang.String\n\n\nString\n is one of many useful classes provided by Java.  You can skim through to see what methods are available and keep the \nAPI reference\n handy.\n\n\n\n\n1\n2\n3\n4\n5\n6\nclass\n \nPoint\n \n{\n\n    \n:\n\n    \npublic\n \nString\n \ntoString\n()\n \n{\n\n        \nreturn\n \n\"(\"\n \n+\n \nx\n \n+\n \n\",\"\n \n+\n \ny\n \n\")\"\n;\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nNow, if we run:\n\n1\n2\nPoint\n \np\n \n=\n \nnew\n \nPoint\n(\n0\n,\n0\n);\n\n\nSystem\n.\nout\n.\nprintln\n(\np\n);\n\n\n\n\n\n\nIt should print \n(0,0)\n instead of \nPoint\n@1235\nde\n.\n\n\nThe ability to override methods that you inherit from a parent, including root class \nObject\n, makes overriding an extremely powerful tool.  It allows you to change how existing libraries behave, and customize them to your classes, without changing a single line of their code or even has access to their code!\n\n\nAs Uncle Ben said, \"With great power, comes great responsibility.\"  We must use overriding and inheritance carefully.  Since we can affect how existing libraries behave, we can easily break existing code and introduce bugs.  Since you may not have access to these existing code, it is often tricky to trace and debug.  \n\n\nModeling HAS-A Relationship\n\n\nInheritance in OO tends to get overused.  In practice, we seldom use inheritance.  Let's look at some examples of how \nnot\n to use inheritance, and why.\n\n\nYou may come across examples online or in books that look like the following:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\nclass\n \nPoint\n \n{\n\n    \nprotected\n \ndouble\n \nx\n;\n\n    \nprotected\n \ndouble\n \ny\n;\n\n      \n:\n\n\n}\n\n\n\nclass\n \nCircle\n \nextends\n \nPoint\n \n{\n\n    \nprotected\n \ndouble\n \nradius\n;\n\n      \n:\n\n\n}\n\n\n\nclass\n \nCylinder\n \nextends\n \nCircle\n \n{\n\n    \nprotected\n \ndouble\n \nheight\n;\n\n      \n:\n\n\n}\n\n\n\n\n\n\n\n\n\nProtected fields\n\n\nThe example above have been changed after the class to clarify the access modifier appropriate for this example.  See After Note below for details.\n\n\n\n\nCircle\n implemented like the above would have the center coordinate inherited from the parent (so it has three fields, x, y, and radius), and \nCylinder\n would have the fields corresponding to a circle, which is its base, and the height.  So, we are \nreusing\n the fields and the code related to initializing and manipulating the fields.\n\n\nWhen we start to consider methods encapsulated with each object, things start to get less intuitive.  What does \ngetPerimeter()\n and \ngetArea()\n of \nCylinder\n means?  How about \ndistanceTo\n between a \nCylinder\n and a \nPoint\n?   What is the meaning of a \nCircle\n containing a \nCylinder\n?\n\n\nThe inheritance hierarchy above actually models the HAS-A relationship: A circle has a center (which is a point), a cylinder has a base which is a circle.  Therefore, a better way to capture the relationship between the three types of objects is through \ncomposition\n:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\nclass\n \nPoint\n \n{\n\n    \ndouble\n \nx\n;\n\n    \ndouble\n \ny\n;\n\n      \n:\n\n\n}\n\n\n\nclass\n \nCircle\n \n{\n\n    \nPoint\n \ncenter\n;\n\n    \ndouble\n \nradius\n;\n\n      \n:\n\n\n}\n\n\n\nclass\n \nCylinder\n \n{\n\n    \nCircle\n \nbase\n;\n\n    \ndouble\n \nheight\n;\n\n      \n:\n\n\n}\n\n\n\n\n\n\n\nComposition allows us to build more complex classes from simpler ones, and is usually favored over inheritance.  \n\n\nThe \nPaintedShape\n class from Lecture 2, for instance, could be modeled as a composition of a \nStyle\n object and \nGeometricShape\n object.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\nclass\n \nStyle\n \n{\n\n    \nColor\n \nfillColor\n;\n\n    \nColor\n \nborderColor\n;\n\n      \n:\n\n\n}\n\n\n\nclass\n \nPaintedShape\n \n{\n\n    \nStyle\n \nstyle\n;\n\n    \nGeometricShape\n \nshape\n;\n\n      \n:\n\n    \npublic\n \ndouble\n \ngetArea\n()\n \n{\n\n        \nreturn\n \nshape\n.\ngetArea\n();\n\n    \n}\n\n    \n:\n\n    \npublic\n \nvoid\n \nfillWith\n(\nColor\n \nc\n)\n \n{\n\n        \nstyle\n.\nfillWith\n(\nc\n);\n\n    \n}\n\n      \n:\n\n\n}\n\n\n\n\n\n\n\nThe design above is also known as the \nforwarding\n -- calls to methods on \nPaintedShape\n gets forwarded to either \nStyle\n or \nGeometricShape\n objects.\n\n\nModeling IS-A Relationship\n\n\nA better situation to use inheritance is to model a IS-A relationship: when the subclass behaves just like parent class, but has some additional behaviors.  For instance, it is natural to model a \nPaintedCircle\n as a subclass of \nCircle\n -- since a PaintedCircle has all the behavior of \nCircle\n, but has \nadditional\n behaviors related to being painted.\n\n\n1\n2\n3\n4\nclass\n \nPaintedCircle\n \nextends\n \nCircle\n \n{\n\n    \nStyle\n \nstyle\n;\n\n      \n:\n\n\n}\n\n\n\n\n\n\n\nA more tricky situation for modeling a IS-A relationship occurs when the subclass behaves just like the parent class \nmost\n of the time, but is slightly different than the parent's behavior.  Consider how do we model a rectangle and a square.  Normally, we consider a square IS-A special case of rectangle.  So, we could model as:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\nclass\n \nRectangle\n \n{\n\n    \ndouble\n \nwidth\n,\n \nheight\n;\n\n    \nPoint\n \ntopLeft\n;\n\n    \nRectangle\n(\nPoint\n \ntopLeft\n,\n \nin\n \nwidth\n,\n \nint\n \nheight\n)\n \n{\n\n        \nthis\n.\ntopLeft\n \n=\n \ntopLeft\n;\n\n        \nthis\n.\nwidth\n \n=\n \nwidth\n;\n\n        \nthis\n.\nheight\n \n=\n \nheight\n;\n\n    \n}\n\n\n}\n\n\n\nclass\n \nSquare\n \nextends\n \nRectangle\n \n{\n\n    \nSquare\n(\nPoint\n \ntopLeft\n,\n \nint\n \nwidth\n)\n \n{\n\n        \nsuper\n(\ntopLeft\n,\n \nwidth\n,\n \nwidth\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\n\n\nthis\n\n\nThe \nthis\n keyword in Java that refers to the current object.\n\n\n\n\nSo far, so good.\n\n\nNow, suppose the two classes are written by two different developers.  The developer who wrote Rectangle decides to add the method \nresizeTo\n:\n\n\n1\n2\n3\n4\n5\n6\n7\nclass\n \nRectangle\n \n{\n\n      \n:\n\n    \nvoid\n \nresizeTo\n(\nint\n \nwidth\n,\n \nint\n \nheight\n)\n \n{\n\n        \nthis\n.\nwidth\n \n=\n \nwidth\n;\n\n        \nthis\n.\nheight\n \n=\n \nheight\n;\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nThis developer assumes the behavior that, after calling \nresizeTo(w, h)\n, the width of the rectangle will be \nw\n and the height will be \nh\n.  He/she publishes this API, and another developer then assumes this behavior, and wrote some code, like:\n\n\n1\n2\n3\n4\nvoid\n \ndoSomething\n(\nRectangle\n \nr\n)\n \n{\n\n    \nr\n.\nresizeTo\n(\n1\n,\n \n2\n);\n\n      \n:\n\n\n}\n\n\n\n\n\nWhat should the developer who develops \nSquare\n do?  Since \nSquare\n is a subclass of rectangle, it would inherit \nresizeTo\n from its parent, but it does not make sense to call \nresizeTo\n with two different parameters.  Sure, \nSquare\n can overload \nresizeTo\n and provide a \nresizeTo\n with one parameter only, but that does not prevent someone from calling \nresizeTo\n with two parameters on a \nSquare\n.  Someone could do the following and the code would still compile and run, turning the square into a rectangle!\n\n\n1\n2\nSquare\n \ns\n \n=\n \nnew\n \nSquare\n(\nnew\n \nPoint\n(\n0\n,\n0\n),\n \n10\n);\n\n\ns\n.\nresize\n(\n4\n,\n \n8\n);\n\n\n\n\n\n\n\nThe \nSquare\n developer can try to override \nresizeTo\n, to ignore the second parameter:\n\n\n1\n2\n3\n4\n5\n6\n7\nclass\n \nSquare\n \n{\n\n      \n:\n\n    \nvoid\n \nresizeTo\n(\nint\n \nwidth\n,\n \nint\n \nheight\n)\n \n{\n\n        \nthis\n.\nwidth\n \n=\n \nwidth\n;\n\n        \nthis\n.\nheight\n \n=\n \nwidth\n;\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nThis makes more sense and would make everyone who uses \nSquare\n happy -- a square is always a square -- but it introduces an \ninconsistency\n in behavior and will likely break another part of the code the developer is totally unaware of.  The developer for \ndoSomething\n suddenly cannot assume that \nresizeTo\n works as intended and documented.\n\n\nIt is a developer's responsibility that any inheritance with method overriding does not alter the behavior of existing code.  This brings us to the Liskov Substitution Principle, which says that: \"Let \n\\(\\phi(x)\\)\n be a property provable about objects \n\\(x\\)\n of type \n\\(T\\)\n. Then \n\\(\\phi(y)\\)\n should be true for objects \n\\(y\\)\n of type \n\\(S\\)\n where \n\\(S\\)\n is a subtype of \n\\(T\\)\n.\"   This means that if \n\\(S\\)\n is a subclass of \n\\(T\\)\n, then an object of type \n\\(T\\)\n can be replaced by an object of type \n\\(S\\)\n without changing the desirable property of the program.\n\n\nIn the example above, this means that everywhere we can expect rectangles to be used, we can replace a rectangle with a square.  This was no longer true with the introduction of \nresizeTo\n method.\n\n\nPreventing Inheritance and Method Overriding\n\n\nSometimes, it is useful for a developer to explicitly prevent a class to be inherited.  Not allowing inheritance would make it much easier to argue for the correctness of programs, something important when it comes to writing secure program.  Both the two java classes you have seen, \njava.lang.Math\n and \njava.lang.String\n, cannot be inherited from.  In Java, we use the keyword \nfinal\n when declaring a class to tell Java that we ban this class from being inherited.\n\n\n1\n2\n3\nfinal\n \nclass\n \nCircle\n \n{\n\n    \n:\n\n\n}\n\n\n\n\n\n\n\nAlternatively, we can allow inheritance, but still prevent a specific method from being overridden, by declaring a method as \nfinal\n.  Usually, we do this on methods that are critical for the correctness of the class.\n\n\n1\n2\n3\n4\n5\n6\nclass\n \nCircle\n \n{\n\n   \n:\n\n    \nfinal\n \npublic\n \nboolean\n \ncontains\n(\nPoint\n \np\n)\n \n{\n\n        \n:\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\n\n\nfinal variable\n\n\nThe keyword \nfinal\n has another use.   When declaring a variable as \nfinal\n, just like\n    \nPI\n in \nMath\n, it prevents the variable from being modified.  In other words, the variable becomes constant.\n\n1\n    \npublic\n \nstatic\n \nfinal\n \ndouble\n \nPI\n   \n=\n \n3.141592653589793\n;\n\n\n\n\n\n\n\n\nAbstract Class and Interface with Default Methods\n\n\nWe have seen how a class can inherit from a parent class, and implement one or more interfaces.  So far, the parent class that we have seen is a \nconcrete\n class -- it has fields and methods, complete with method implementation.  Such concrete parent class can be instantiated into objects.   \n\n\nOn the other hand, we have interfaces, which is completely virtual, it declared what public methods it should provide -- together with the returned type for each method and the method signature.  There is no field and no implementation.\n\n\nBetween these two extremes, there are two other possibilities in Java:\n\n\n\n\nAn \nabstract class\n, which is just like a class, but it is declared as \nabstract\n, and some of its methods are declared as \nabstract\n, without implementation.  An abstract class cannot be instantiated, and any subclass who wish to be concrete needs to implement these abstract methods.\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\nabstract\n \nclass\n \nPaintedShape\n \n{\n\n    \nColor\n \nfillColor\n;\n\n      \n:\n\n  \nvoid\n \nfillWith\n(\nColor\n \nc\n)\n \n{\n\n        \nfillColor\n \n=\n \nc\n;\n\n    \n}\n\n    \n:\n\n    \nabstract\n \ndouble\n \ngetArea\n();\n\n    \nabstract\n \ndouble\n \ngetPerimeter\n();\n\n      \n:\n\n\n}\n\n\n\n\n\n\nAn interface with default implementation.  Introduced only in Java 8, with the goal of allowing interface to evolve, an interface can now contain implementation of the methods.  Such interface still cannot be instantiated into objects, but classes that implement such interface need not provide implementation for a method where a default implementation exists.  For instance, we can have:\n\n1\n2\n3\n4\n5\n6\n7\n    \ninterface\n \nGeometricShape\n \n{\n\n    \npublic\n \ndouble\n \ngetArea\n();\n\n    \npublic\n \ndouble\n \ngetPerimeter\n();\n\n    \npublic\n \nboolean\n \ncontains\n(\nPoint\n \np\n);\n\n        \ndefault\n \npublic\n \nboolean\n \ncover\n(\nPoint\n \np\n)\n \n{\n\n            \nreturn\n \ncontains\n(\np\n);\n\n        \n}\n\n\n\n\n\nwhere \ncover\n is a new method with default implementation, denoted with keyword \ndefault\n.\n\n\n\n\nAt this point in CS2030, let's not worry about when to use abstract class or default methods in interfaces, but just be aware that they exists and understand what they mean when you come across them.  After you gain some experience writing OO programs, we will revisit these concepts so that you can better appreciate their differences and usage.\n\n\nAfter Note\n\n\nThere are a couple of points to clarify with regards to Lecture 3.\n\n\n\n\n\n\nWhen we override \nequals()\n of \nObject\n in \nCircle\n, I said \"\n\nThe method table will update the entry for \nequals()\n to point to the implementation provided by the \nCircle\n class, instead of the \nObject\n class.\n\"\nand in the figure, I showed that the code for \nCircle\n's customized \nequals\n replacing the \nequals\n for \nObject\n.  What I should have added, is that, the original implementation of \nequals\n from \nObject\n is not completely gone.  Methods from the immediate parent that have been overriden can still be called, with \nsuper\n keyword.  Here is a useful example from \nPoint\n's \ntoString()\n:\n\n1\n2\n3\n4\n@Override\n\n\npublic\n \nString\n \ntoString\n()\n \n{\n\n  \nreturn\n \nsuper\n.\ntoString\n()\n \n+\n \n\" (\"\n \n+\n \nx\n \n+\n \n\",\"\n \n+\n \ny\n \n+\n \n\")\"\n;\n\n\n}\n\n\n\n\n\nwhich prefix the string representation of Point with the class and reference address.\n\n\n\n\n\n\nIn the example where we inherit \nCylinder\n from \nCircle\n, and \nCircle\n from \nPoint\n, what should the access modifier of the fields, \nx\n,\ny\n, and \nradius\n be?   If they are declared \nprivate\n, then \nCircle\n has no access to \nx\n and \ny\n; \nCylinder\n has no access to \nx\n,\ny\n, and \nradius\n.  If they are declared \npublic\n, then they are accessible by everyone, breaking the abstraction barrier!  Fortunately, Java has just the right access modifier for this situation: \nx\n, \ny\n, and \nradius\n should be declared as \nprotected\n.  A \nprotected\n field is less restrictive than \npublic\n, and is accessible by subclass but is not accessible by the whole world.",
            "title": "3. Inheritance, Continued"
        },
        {
            "location": "/lec3/index.html#lecture-3-inheritance-continued",
            "text": "",
            "title": "Lecture 3: Inheritance, Continued"
        },
        {
            "location": "/lec3/index.html#learning-objectives",
            "text": "At the end of this lecture, students should   be familiar with how Java dispatches methods that have been overridden  appreciate the usefulness of overriding  equals  and  toString  in the  Object  class  be exposed to the  String  class and its associated methods, especially the  +  operator  be aware that inheritance can be abused to provide bad code  understand the differences between HAS-A and IS-A relationship  be able to use composition to model classes with HAS-A relationship  be able to use inheritance to model classes with IS-A relationship  understand the Liskov Substitution Principle and thus be aware that not all IS-A relationship should be modelled with inheritance  understand the purposes of the Java keywords  this ,  final ,  abstract  and  default",
            "title": "Learning Objectives"
        },
        {
            "location": "/lec3/index.html#method-overriding",
            "text": "During Lecture 2, I introduced the concept of inheritance.  Today, let's go deeper into how inheritance and its associated concepts work.  Consider the class  Circle , which inherits from  Object .  We have seen that  Object  defines some non-private methods, which can be inherited by  Circle .\nThese methods will be made available in the  Circle  class.  In the internal representation of the class, the methods will be made available in the method table of  Circle .  You can view the fields and methods of class  Circle  as containing the fields and methods of  Object , followed by fields and methods defined in  Circle .  The figure below illustrates this.  I use a slightly darker green to represent the methods implemented in the  Object  class, and light green to represent methods implemented in the  Circle  class.   Recall that when a class implements an interface, an instance of that class can take on the type of that interface.  Similarly, when a class inherits from a parent class, an instance of that class can take on the type of the parent class.  So, we can do the following:  1\n2 Circle   c   =   new   Circle ( new   Point ( 0 , 0 ),   10 );  Object   o   =   c ;    Line 2 assigns the circle object  c  to  o  of type  Object .  So, both  o  and  c  are referring to the same objects.  Due to type checking at compile time, however, Java does not allow methods and fields in the subclass (e.g.,  Circle ) that is not in the superclass (e.g.,  Object ) to be called.  In this example, only the methods known to  Object  can be accessed by  o .  Now, consider what would happen if we override the method  equals()  from the  Object  class.  This is what we did in the last lecture.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11      class   Circle   implements   Shape ,   Printable   { \n      : \n          @Override \n          public   boolean   equals ( Object   obj )   { \n              if   ( obj   instanceof   Circle )   { \n                  Circle   circle   =   ( Circle )   obj ; \n                  return   ( circle . center . equals ( center )   &&   circle . radius   ==   radius ); \n              }   else \n                return   false ; \n          } \n     }     Equality for Point  Recall that we override  equals  because we want to compare the content of the two circles, instead of comparing if two circle references point to the same object.  For the implementation above to be correct, we need to override the  equals  function for the  Point  class as well.  This is not shown in class and left as an exercise.   The method table will update the entry for  equals()  to point to the implementation provided by the  Circle  class, instead of the  Object  class.   Now, consider what would happen if we  overload  the method  equals()  with one that takes in a  Circle  object.  I also throw in a couple of  System.out.print()  to help us figure out what is going on.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17      class   Circle   implements   Shape ,   Printable   { \n      : \n          @Override \n          public   boolean   equals ( Object   obj )   { \n              System . out . print ( \"equals(Object) called\\n\" ); \n              if   ( obj   instanceof   Circle )   { \n                  Circle   circle   =   ( Circle )   obj ; \n                  return   (( circle . center . equals ( center )   &&   circle . radius   ==   radius ); \n              }   else \n                return   false ; \n          } \n\n          public   boolean   equals ( Circle   circle )   { \n              System . out . print ( \"equals(Circle) called\\n\" ); \n              return   (( circle . center . equals ( center )   &&   circle . radius   ==   radius ); \n          } \n     }    Since this new  equals()  method does not override the method in  Object , it gets its own slot in the method table of  Circle , instead of reusing one from the  Object .   Now, consider which version of  equals  are called by the following:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11 Circle   c1   =   new   Circle ( new   Point ( 0 , 0 ),   10 );  Circle   c2   =   new   Circle ( new   Point ( 0 , 0 ),   10 );  Object   o1   =   c1 ;  Object   o2   =   c2 ;  o1 . equals ( o2 );  o1 . equals (( Circle ) o2 );  o1 . equals ( c2 );  c1 . equals ( o2 );  c1 . equals (( Circle ) o2 );  c1 . equals ( c2 );    Lines 6-9 call  equals(Object)  defined in  Circle \uff0c while Lines 10-11 call  equals(Circle)  defined in  Circle .  Let's look at why for each one:   Line 6 calls  equals  of an  Object  object on an  Object  object.  Java checks through all methods defined in  Object , and finds a method that matches the signature, which is the  equals(Object)  (which  Circle  has overridden). This is the one that will get called.  Line 7-8 call  equals  of an  Object  object on a  Circle  object.  Java checks through all methods defined in  Object , and finds one method that matches the signature, which is  equals(Object)  (which  Circle  has overridden).  Even though there is another method  equals(Circle)  defined, it is defined as part of the  Circle  class, which Java refuses to access because  o1  is declared to have the type  Object .  Since the only method that Java can find has an argument of type  Object , the argument is cast as an  Object  when  equals  is invoked.  Line 9 calls  equals  of a  Circle  object on an  Object  object.  Java finds a method with matching signature,  equals(Object) , and invokes that.  Final 10-11 calls  equals  of a  Circle  object on a  Circle  object.  Java finds a method with matching signature,  equals(Circle) , and invokes that.   Another question that came up is why we need to override  equals  in  Object , rather than just using the  Circle -specific  equals(Circle) .  As shown above, only when an object declared as  Circle  calls  equals  on another  Circle  object, the  Circle -specific  equals(Circle)  is invoked.    To write code that is general and reusable, we should exploit OO polymorphism, that means different subclasses of  Object  implement their own customized version of  equals , and the right version of  equals  will be called.  One example of where this is called the  contains(Object)  method from class  ArrayList  (we will cover this later in class), which checks if an object is already in the list, and to check this, it checks for equality of the given object with every object in the  ArrayList , by calling  equals(Object) .  We now turn our attention to another method in  Object  that we could override, the  toString()  method.   toString()  is called whenever the  String  representation of an object is needed.  For instance, when we try to print an object.   By default, the  toString  of  Object  simply prints the name of the class, followed by  @ , followed by the reference.   It is often useful to override this to include the content of the object as well, for debugging and logging purposes.  This is a much more useful and flexible than writing our own  print()  method as we have seen in earlier lectures, since we are not limited to printing to standard output anymore.   java.lang.String  String  is one of many useful classes provided by Java.  You can skim through to see what methods are available and keep the  API reference  handy.   1\n2\n3\n4\n5\n6 class   Point   { \n     : \n     public   String   toString ()   { \n         return   \"(\"   +   x   +   \",\"   +   y   \")\" ; \n     }  }    Now, if we run: 1\n2 Point   p   =   new   Point ( 0 , 0 );  System . out . println ( p );    It should print  (0,0)  instead of  Point @1235 de .  The ability to override methods that you inherit from a parent, including root class  Object , makes overriding an extremely powerful tool.  It allows you to change how existing libraries behave, and customize them to your classes, without changing a single line of their code or even has access to their code!  As Uncle Ben said, \"With great power, comes great responsibility.\"  We must use overriding and inheritance carefully.  Since we can affect how existing libraries behave, we can easily break existing code and introduce bugs.  Since you may not have access to these existing code, it is often tricky to trace and debug.",
            "title": "Method Overriding"
        },
        {
            "location": "/lec3/index.html#modeling-has-a-relationship",
            "text": "Inheritance in OO tends to get overused.  In practice, we seldom use inheritance.  Let's look at some examples of how  not  to use inheritance, and why.  You may come across examples online or in books that look like the following:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15 class   Point   { \n     protected   double   x ; \n     protected   double   y ; \n       :  }  class   Circle   extends   Point   { \n     protected   double   radius ; \n       :  }  class   Cylinder   extends   Circle   { \n     protected   double   height ; \n       :  }     Protected fields  The example above have been changed after the class to clarify the access modifier appropriate for this example.  See After Note below for details.   Circle  implemented like the above would have the center coordinate inherited from the parent (so it has three fields, x, y, and radius), and  Cylinder  would have the fields corresponding to a circle, which is its base, and the height.  So, we are  reusing  the fields and the code related to initializing and manipulating the fields.  When we start to consider methods encapsulated with each object, things start to get less intuitive.  What does  getPerimeter()  and  getArea()  of  Cylinder  means?  How about  distanceTo  between a  Cylinder  and a  Point ?   What is the meaning of a  Circle  containing a  Cylinder ?  The inheritance hierarchy above actually models the HAS-A relationship: A circle has a center (which is a point), a cylinder has a base which is a circle.  Therefore, a better way to capture the relationship between the three types of objects is through  composition :   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17 class   Point   { \n     double   x ; \n     double   y ; \n       :  }  class   Circle   { \n     Point   center ; \n     double   radius ; \n       :  }  class   Cylinder   { \n     Circle   base ; \n     double   height ; \n       :  }    Composition allows us to build more complex classes from simpler ones, and is usually favored over inheritance.    The  PaintedShape  class from Lecture 2, for instance, could be modeled as a composition of a  Style  object and  GeometricShape  object.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19 class   Style   { \n     Color   fillColor ; \n     Color   borderColor ; \n       :  }  class   PaintedShape   { \n     Style   style ; \n     GeometricShape   shape ; \n       : \n     public   double   getArea ()   { \n         return   shape . getArea (); \n     } \n     : \n     public   void   fillWith ( Color   c )   { \n         style . fillWith ( c ); \n     } \n       :  }    The design above is also known as the  forwarding  -- calls to methods on  PaintedShape  gets forwarded to either  Style  or  GeometricShape  objects.",
            "title": "Modeling HAS-A Relationship"
        },
        {
            "location": "/lec3/index.html#modeling-is-a-relationship",
            "text": "A better situation to use inheritance is to model a IS-A relationship: when the subclass behaves just like parent class, but has some additional behaviors.  For instance, it is natural to model a  PaintedCircle  as a subclass of  Circle  -- since a PaintedCircle has all the behavior of  Circle , but has  additional  behaviors related to being painted.  1\n2\n3\n4 class   PaintedCircle   extends   Circle   { \n     Style   style ; \n       :  }    A more tricky situation for modeling a IS-A relationship occurs when the subclass behaves just like the parent class  most  of the time, but is slightly different than the parent's behavior.  Consider how do we model a rectangle and a square.  Normally, we consider a square IS-A special case of rectangle.  So, we could model as:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15 class   Rectangle   { \n     double   width ,   height ; \n     Point   topLeft ; \n     Rectangle ( Point   topLeft ,   in   width ,   int   height )   { \n         this . topLeft   =   topLeft ; \n         this . width   =   width ; \n         this . height   =   height ; \n     }  }  class   Square   extends   Rectangle   { \n     Square ( Point   topLeft ,   int   width )   { \n         super ( topLeft ,   width ,   width ); \n     }  }     this  The  this  keyword in Java that refers to the current object.   So far, so good.  Now, suppose the two classes are written by two different developers.  The developer who wrote Rectangle decides to add the method  resizeTo :  1\n2\n3\n4\n5\n6\n7 class   Rectangle   { \n       : \n     void   resizeTo ( int   width ,   int   height )   { \n         this . width   =   width ; \n         this . height   =   height ; \n     }  }    This developer assumes the behavior that, after calling  resizeTo(w, h) , the width of the rectangle will be  w  and the height will be  h .  He/she publishes this API, and another developer then assumes this behavior, and wrote some code, like:  1\n2\n3\n4 void   doSomething ( Rectangle   r )   { \n     r . resizeTo ( 1 ,   2 ); \n       :  }   \nWhat should the developer who develops  Square  do?  Since  Square  is a subclass of rectangle, it would inherit  resizeTo  from its parent, but it does not make sense to call  resizeTo  with two different parameters.  Sure,  Square  can overload  resizeTo  and provide a  resizeTo  with one parameter only, but that does not prevent someone from calling  resizeTo  with two parameters on a  Square .  Someone could do the following and the code would still compile and run, turning the square into a rectangle!  1\n2 Square   s   =   new   Square ( new   Point ( 0 , 0 ),   10 );  s . resize ( 4 ,   8 );    The  Square  developer can try to override  resizeTo , to ignore the second parameter:  1\n2\n3\n4\n5\n6\n7 class   Square   { \n       : \n     void   resizeTo ( int   width ,   int   height )   { \n         this . width   =   width ; \n         this . height   =   width ; \n     }  }    This makes more sense and would make everyone who uses  Square  happy -- a square is always a square -- but it introduces an  inconsistency  in behavior and will likely break another part of the code the developer is totally unaware of.  The developer for  doSomething  suddenly cannot assume that  resizeTo  works as intended and documented.  It is a developer's responsibility that any inheritance with method overriding does not alter the behavior of existing code.  This brings us to the Liskov Substitution Principle, which says that: \"Let  \\(\\phi(x)\\)  be a property provable about objects  \\(x\\)  of type  \\(T\\) . Then  \\(\\phi(y)\\)  should be true for objects  \\(y\\)  of type  \\(S\\)  where  \\(S\\)  is a subtype of  \\(T\\) .\"   This means that if  \\(S\\)  is a subclass of  \\(T\\) , then an object of type  \\(T\\)  can be replaced by an object of type  \\(S\\)  without changing the desirable property of the program.  In the example above, this means that everywhere we can expect rectangles to be used, we can replace a rectangle with a square.  This was no longer true with the introduction of  resizeTo  method.",
            "title": "Modeling IS-A Relationship"
        },
        {
            "location": "/lec3/index.html#preventing-inheritance-and-method-overriding",
            "text": "Sometimes, it is useful for a developer to explicitly prevent a class to be inherited.  Not allowing inheritance would make it much easier to argue for the correctness of programs, something important when it comes to writing secure program.  Both the two java classes you have seen,  java.lang.Math  and  java.lang.String , cannot be inherited from.  In Java, we use the keyword  final  when declaring a class to tell Java that we ban this class from being inherited.  1\n2\n3 final   class   Circle   { \n     :  }    Alternatively, we can allow inheritance, but still prevent a specific method from being overridden, by declaring a method as  final .  Usually, we do this on methods that are critical for the correctness of the class.  1\n2\n3\n4\n5\n6 class   Circle   { \n    : \n     final   public   boolean   contains ( Point   p )   { \n         : \n     }  }     final variable  The keyword  final  has another use.   When declaring a variable as  final , just like\n     PI  in  Math , it prevents the variable from being modified.  In other words, the variable becomes constant. 1      public   static   final   double   PI     =   3.141592653589793 ;",
            "title": "Preventing Inheritance and Method Overriding"
        },
        {
            "location": "/lec3/index.html#abstract-class-and-interface-with-default-methods",
            "text": "We have seen how a class can inherit from a parent class, and implement one or more interfaces.  So far, the parent class that we have seen is a  concrete  class -- it has fields and methods, complete with method implementation.  Such concrete parent class can be instantiated into objects.     On the other hand, we have interfaces, which is completely virtual, it declared what public methods it should provide -- together with the returned type for each method and the method signature.  There is no field and no implementation.  Between these two extremes, there are two other possibilities in Java:   An  abstract class , which is just like a class, but it is declared as  abstract , and some of its methods are declared as  abstract , without implementation.  An abstract class cannot be instantiated, and any subclass who wish to be concrete needs to implement these abstract methods.  1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11 abstract   class   PaintedShape   { \n     Color   fillColor ; \n       : \n   void   fillWith ( Color   c )   { \n         fillColor   =   c ; \n     } \n     : \n     abstract   double   getArea (); \n     abstract   double   getPerimeter (); \n       :  }    An interface with default implementation.  Introduced only in Java 8, with the goal of allowing interface to evolve, an interface can now contain implementation of the methods.  Such interface still cannot be instantiated into objects, but classes that implement such interface need not provide implementation for a method where a default implementation exists.  For instance, we can have: 1\n2\n3\n4\n5\n6\n7      interface   GeometricShape   { \n     public   double   getArea (); \n     public   double   getPerimeter (); \n     public   boolean   contains ( Point   p ); \n         default   public   boolean   cover ( Point   p )   { \n             return   contains ( p ); \n         }   \nwhere  cover  is a new method with default implementation, denoted with keyword  default .   At this point in CS2030, let's not worry about when to use abstract class or default methods in interfaces, but just be aware that they exists and understand what they mean when you come across them.  After you gain some experience writing OO programs, we will revisit these concepts so that you can better appreciate their differences and usage.",
            "title": "Abstract Class and Interface with Default Methods"
        },
        {
            "location": "/lec3/index.html#after-note",
            "text": "There are a couple of points to clarify with regards to Lecture 3.    When we override  equals()  of  Object  in  Circle , I said \" The method table will update the entry for  equals()  to point to the implementation provided by the  Circle  class, instead of the  Object  class. \"\nand in the figure, I showed that the code for  Circle 's customized  equals  replacing the  equals  for  Object .  What I should have added, is that, the original implementation of  equals  from  Object  is not completely gone.  Methods from the immediate parent that have been overriden can still be called, with  super  keyword.  Here is a useful example from  Point 's  toString() : 1\n2\n3\n4 @Override  public   String   toString ()   { \n   return   super . toString ()   +   \" (\"   +   x   +   \",\"   +   y   +   \")\" ;  }   \nwhich prefix the string representation of Point with the class and reference address.    In the example where we inherit  Cylinder  from  Circle , and  Circle  from  Point , what should the access modifier of the fields,  x , y , and  radius  be?   If they are declared  private , then  Circle  has no access to  x  and  y ;  Cylinder  has no access to  x , y , and  radius .  If they are declared  public , then they are accessible by everyone, breaking the abstraction barrier!  Fortunately, Java has just the right access modifier for this situation:  x ,  y , and  radius  should be declared as  protected .  A  protected  field is less restrictive than  public , and is accessible by subclass but is not accessible by the whole world.",
            "title": "After Note"
        },
        {
            "location": "/lec4/index.html",
            "text": "Lecture 4: Memory, Exception and Generics\n\n\nLearning Outcomes\n\n\nAfter this class, students should:\n\n\n\n\nbe understand when memory are allocated/deallocated from heap vs. from stack\n\n\nunderstand the concept of call stack in JVM\n\n\nunderstand how Java call by reference and call by value\n\n\nknow about the keywords \nnull\n, \ntry\n, \ncatch\n, \nfinally\n, \nthrow\n, and \nthrows\n.\n\n\nappreciate why exceptions is useful way of handling errors\n\n\naware of the differences between errors, unchecked exception, and checked exception in Java\n\n\nbe able to trace through the control flow of \ntry\n/\ncatch\n/\nfinally\n block\n\n\nhow to generate an exception and create a new exception\n\n\nnot commit bad practices when using exceptions\n\n\napprecaite why generics is helpful\n\n\nbe able to create generic class with type parameter, and instantiate parameterized type by passing in type arguments.\n\n\n\n\nWhere are Objects and Variables Stored?\n\n\nFirst, let's look at where Java stores the objects and variables when a program is executed.  There are two memory regions, a heap and a stack\n1\n.  The \nheap\n is where all objects are allocated, while the \nstack\n is where all variables (including primitive types and object references) are allocated.\n\n\nConsiders the following two lines of code.\n\n1\n2\nCircle\n \nc\n;\n\n\nc\n \n=\n \nnew\n \nCircle\n(\nnew\n \nPoint\n(\n1\n,\n \n1\n),\n \n8\n);\n\n\n\n\n\nLine 1 declares a variable \nc\n.  When Java executes this line of code, it allocates some memory space for an object reference for \nc\n, the content is initialized to \nnull\n.  Since \nc\n is a variable, it resides in the stack.\n\n\n\n\nnull\n in Java\n\n\nnull\n is a special value for object reference, that signify that this reference is not pointing to any object.  This is similar to the \nnull\n in Javascript, \nNULL\n macro in C, \nnullptr\n in C++11, \nNone\n in Python, \nnil\n in Objective-C.  (Again, you see here computer scientists just can't agree on names!)  \nSir Tony Hoare\n (who also invented quicksort) famously apologized for inventing the null pointer.  He calls it his billion-dollar mistake.\n\n\n\n\nLine 2 creates a new Circle object.  When Java executes this line of code, it allocates some memory space for a \nCircle\n object on the heap.  The memory address of this memory space becomes the reference of the object, and is assigned to the variable \nc\n.\n\n\nThis is shown in the figure below\n2\n.\n\n\n\n\nThe first argument to \nCircle\n constructor is also an object, so to be more precise, when Line 2 above is executed, a \nPoint\n object is also created and allocated on the heap.  So the field \nc\n inside \nCircle\n is actually a reference to this object.\n\n\n\n\nNow, let's look at a slightly different example.\n\n\n1\n2\n3\n4\n5\n6\nCircle\n \nc\n;\n\n\nPoint\n \ncenter\n;\n\n\ndouble\n \nradius\n;\n\n\nradius\n \n=\n \n8\n;\n\n\ncenter\n \n=\n \nnew\n \nPoint\n(\n1\n,\n \n1\n);\n\n\nc\n \n=\n \nnew\n \nCircle\n(\ncenter\n,\n \nradius\n);\n\n\n\n\n\n\nIn the second example, we have three variables, \nc\n, \ncenter\n, and \nradius\n .  Lines 1-3 declare the variables, and as a result, we have three variables allocated on the stack.  Recall that for object references, they are initialized to \nnull\n.  Primitive type variables (e.g., \nradius\n) are initialized to 0.\n\n\n\n\nAfter Lines 4-6, we have:\n\n\n\n\nCall Stack\n\n\nNow, let's look at what happens when we invoke a method.  Take the \ndistanceTo\n method in \nPoint\n as an example:\n\n\n1\n2\n3\n4\n5\n6\n7\nclass\n \nPoint\n \n{\n\n  \nprivate\n \ndouble\n \nx\n;\n\n  \nprivate\n \ndouble\n \ny\n;\n\n  \npublic\n \ndouble\n \ndistanceTo\n(\nPoint\n \nq\n)\n \n{\n\n    \nreturn\n \nMath\n.\nsqrt\n((\nq\n.\nx\n \n-\n \nthis\n.\nx\n)*(\nq\n.\nx\n \n-\n \nthis\n.\nx\n)+(\nq\n.\ny\n \n-\n \nthis\n.\ny\n)*(\nq\n.\ny\n \n-\n \nthis\n.\ny\n));\n\n  \n}\n\n\n}\n\n\n\n\n\nand the invocation:\n\n1\n2\n3\nPoint\n \np1\n \n=\n \nnew\n \nPoint\n(\n0\n,\n0\n);\n\n\nPoint\n \np2\n \n=\n \nnew\n \nPoint\n(\n1\n,\n1\n);\n\n\np1\n.\ndistanceTo\n(\np2\n);\n\n\n\n\n\n\nAfter declaring \np1\n and \np2\n and creating both objects, we have:\n\n\n\nLet's see what happen when we call \ndistanceTo\n.  How is the argument \nq\n initialized?  What about \nthis\n?  \n\n\nWhen \ndistanceTo\n is called, Java (to be more precise, the Java Virtual Machine, or JVM) creates a \nstack frame\n for this instance method call.  This stack frame is a region of memory that tentatively contains (i) the \nthis\n reference, (ii) the method arguments, and (iii) local variables within the method, among other things\n3\n4\n.  When a class method is called, the stack frame does not contain the \nthis\n reference.\n\n\n\n\nYou can see that the \nreference\n of the objects \np1\n and \np2\n are copied onto the stack frame. \np1\n and \nthis\n point to the same object, and \np2\n and \nq\n point to the same object.\nWithin the method, any modification done to \nthis\n would change the object referenced to by \np1\n, and any change made to \nq\n would change the object referenced to by \np2\n as well.\nAfter the method returns, the stack frame for that method is destroyed.\n\n\nLet's call the \nmove\n function from your \nLab 1\n, with arguments \n(double theta, double d)\n.\n\n\n1\n2\n3\ndouble\n \ntheta\n \n=\n \nMath\n.\nPI\n/\n4.0\n;\n\n\ndouble\n \ndistance\n \n=\n \n1\n;\n\n\np2\n.\nmove\n(\ntheta\n,\n \ndistance\n);\n\n\n\n\n\n\n\nAgain, we create a stack frame, copy the reference to object \np2\n into \nthis\n, copy \ntheta\n from the calling function to \ntheta\n the argument within the method, copy \ndistance\n from the calling function to \nd\n the argument within the method.  Recall that, in this function, you actually change the \nx\n and \ny\n of \nthis\n to move \np2\n.  \n\n\n\n\nWhat is important here is that, as \ntheta\n and \ndistance\n are primitive types instead of references, we copy the values onto the stack.  If we change \ntheta\n or \nd\n within \nmove\n, the \ntheta\n and \ndistance\n of the calling function will not change.  This behavior is the same as you would expect in C.  However, unlike in C where you can pass in a pointer to a variable, you cannot pass in a reference to a primitive type in any way in Java.  If you want to pass in a variable of primitive type into a method and have its value changed, you will have to use a \nwrapper class\n, but we leave the details of that for another lesson on another day.\n\n\nIn short, Java uses \ncall by value\n for primitive types, and \ncall by reference\n for objects.\n\n\nIf we made multiple nested method calls, as we usually do, the stack frames get stacked on top of each other.  For instance, in Lab 1, \nmain\n calls \nsolve\n, which calls the \nCircle\n constructor, which calls the \nangleTo\n.  When JVM is executing \nangleTo\n, the call stack contains the stack frames of (in order of top to bottom): \nangleTo\n, \nCircle\n constructor, \nsolve\n, and \nmain\n.\n\n\nOne final note: the memory allocated on the stack are deallocated when a method returns.  The memory allocated on the heap, however, stays there as long as there is a reference to it (either from another object or from a variable in the stack).  Unlike C or C++, in Java, you do not have to free the memory allocated to objects.  The JVM runs a \ngarbage collector\n  that checks for unreferenced objects on the heap and cleans up the memory automatically.\n\n\nExceptions\n\n\nOne of the nuances of programming is having to write code to deal with exceptions and errors.  Consider writing a method that reads in a series of x and y coordinates from a file, not unlike what you have seen in Lab 1.  Here are some things that could go wrong:\n\n\n\n\nThe file to read from may not exist\n\n\nThe file to read from exists, but you may not have permission to read it\n\n\nYou can open the file for reading, but it might contain non-numeric text where you numerical values\n\n\nThe file might contain fewer values than expected\n\n\nThe file might become unreadable as you are reading through it (e.g., someone unplug the USB drive)\n\n\n\n\nIn C, we usually have to write code like this:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\nfd\n \n=\n \nfopen\n(\nfilename\n,\n\"r\"\n);\n\n\nif\n \n(\nfd\n \n==\n \nNULL\n)\n \n{\n\n  \nfprintf\n(\nstderr\n,\n \n\"Unable to open file. \"\n);\n\n  \nif\n \n(\nerrno\n \n==\n \nENFILE\n)\n \n{\n\n    \nfprintf\n(\nstderr\n,\n \n\"Too many opened files.  Unable to open another\n\\n\n\"\n);\n\n  \n}\n \nelse\n \nif\n \n(\nerrno\n \n==\n \nENOENT\n)\n \n{\n\n    \nfprintf\n(\nstderr\n,\n \n\"No such file %s\n\\n\n\"\n,\n \nfilename\n);\n\n  \n}\n \nelse\n \nif\n \n(\nerrno\n \n==\n \nEACCES\n)\n \n{\n\n    \nfprintf\n(\nstderr\n,\n \n\"No read permission to %s\n\\n\n\"\n,\n \nfilename\n);\n\n  \n}\n\n  \nreturn\n \n-\n1\n;\n\n\n}\n\n\nscanned\n \n=\n \nfscanf\n(\nfd\n,\n \n\"%d\"\n,\n \n&\nnum_of_points\n);\n\n\nif\n \n(\nscanned\n \n==\n \n0\n)\n \n{\n\n  \nfprintf\n(\nstderr\n,\n \n\"Unable to scan for an integer\n\\n\n\"\n);\n\n  \nfclose\n(\nfd\n);\n\n  \nreturn\n \n-\n2\n;\n\n\n}\n\n\nif\n \n(\nscanned\n \n==\n \nEOF\n)\n \n{\n\n  \nfprintf\n(\nstderr\n,\n \n\"No input found.\n\\n\n\"\n);\n\n  \nfclose\n(\nfd\n);\n\n  \nreturn\n \n-\n3\n;\n\n\n}\n\n\n\n\n\n\n\nOut of the lines above, only 2 lines correspond to the actual tasks, the others are for exception checking/handling.  How uncool is that?  Furthermore, the actual tasks are intersperse between exception checking code, making reading and understanding the logic of the code difficult.\n\n\nThe examples above also have to return different values to the calling method, because the calling method may have to do something to handle the errors.  Note that the POSIX APIs has a global variable \nerrno\n which signifies the detailed error.  First, we have to check for different \nerrno\n values and react accordingly (we can use \nperror\n, but that has its limits).  Second, \nerrno\n is global and we know that global variable is bad practice.  In fact, I am not even sure that code above works because \nfprintf\n in Line 3 might have changed \nerrno\n!\n\n\nThen, there is the issue of having to repeatedly clean up after an error -- here we \nfclose\n the file if there is an error reading, twice.  It is easy to forgot to do so if we have to do this in multiple places.   Furthermore, if we need to perform more complex clean up, then we would end up with lots of repeated code.\n\n\nJava supports \ntry\n/\ncatch\n/\nfinally\n control statements, which is a way to group statements that check/handle errors together making code easier to read.  The Java equivalent to the above is:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\ntry\n \n{\n\n  \nreader\n \n=\n \nnew\n \nFileReader\n(\nfilename\n);\n\n  \nscanner\n \n=\n \nnew\n \nScanner\n(\nreader\n);\n\n  \nnumOfPoints\n \n=\n \nscanner\n.\nnextInt\n();\n\n\n}\n\n\ncatch\n \n(\nFileNotFoundException\n \ne\n)\n \n{\n\n    \nSystem\n.\nerr\n.\nprintln\n(\n\"Unable to open \"\n \n+\n \nfilename\n \n+\n \n\" \"\n \n+\n \ne\n);\n\n\n}\n\n\ncatch\n \n(\nInputMismatchException\n \ne\n)\n \n{\n\n    \nSystem\n.\nerr\n.\nprintln\n(\n\"Unable to scan for an integer\"\n);\n\n\n}\n\n\ncatch\n \n(\nNoSuchElementException\n \ne\n)\n \n{\n\n    \nSystem\n.\nerr\n.\nprintln\n(\n\"No input found\"\n);\n\n\n}\n\n\nfinally\n \n{\n\n  \nif\n \n(\nscanner\n \n!=\n \nnull\n)\n\n    \nscanner\n.\nclose\n();\n\n\n}\n\n\n\n\n\n\n\nHere Lines 2-4 keep the basic tasks together, and all the clean up tasks are grouped together in Lines 18-19.  Lines 8-16 handles the exceptions.  We no longer rely on global variable to convey the type of exceptions, or special return value to indicate exceptions.   What if we want the calling method to handle the exception?  Then, we simply do not do anything (i.e., do not catch the exception) and let the exception propagates to the calling method automatically.\n\n\n\n\nError vs. Exception in Java\n\n\nWe have been using the term error and exception loosely.  Java has different classes for \nError\n and \nException\n.  \nError\n is for situations where the program should terminate as generally there is no way to recover.  For instance, when the heap is full (\nOutOfMemoryError\n) or the stack is full (\nStackOverflowError\n).  Exceptions are for situations where it is still possible to reasonably recover from the error.\n\n\n\n\n\n\nCombining Multiple Catches\n\n\nIn cases where the code to handle the exceptions is the same, you can\n\n1\n2\n3\ncatch (FileNotFoundException | InputMismatchException | NoSuchElementException e) {\n    System.err.println(e);\n}\n\n\n\n\n\n\n\nHere is a more detailed description of the control flow of exceptions.  Consider we have a \ntry\n-\ncatch\n-\nfinally\n block that catches two exceptions \nE1\n and \nE2\n.  Inside the \ntry\n block, we call a method \nm1()\n; \nm1()\n calls \nm2()\n; \nm2()\n calls \nm3()\n, and \nm3()\n calls \nm4()\n.   In a normal (no exception) situation, the control flow looks like this:\n\n\n\n\nThe statements in \ntry\n block is executed, followed by the statements in \nfinally\n block.\n\n\nNow, let's suppose something went wrong deep inside the nested call, in \nm4()\n.  One of the statement executes \nthrow new E2();\n, which causes the execution in \nm4()\n to stop.  JVM now looks for the block of code that catches \nE2\n, going down the call stack, until it can find a place where the exception is handled.  In this example, we suppose that none of \nm1()\n-\nm4()\n handles (i.e., \ncatch\n) the exception.  Thus, JVM then jumps to the code that handles \nE2\n.  Finally, JVM executes the \nfinally\n block.\n\n\n\n\nChecked Exceptions\n\n\nThere are two types of exceptions in Java: \nchecked\n and \nunchecked\n exceptions:\n\n\n\n\nA checked exception is something that the programmer should anticipate and handle.  For instance, when you open a file, you should anticipate that in some cases, the file cannot be open.   \n\n\nAn unchecked exception is something that the programmer does not anticipate, and usually is a result of bugs.  For example, when you try to call \np.distanceTo(q)\n but \np\n is \nnull\n, resulting in a \nNullPointerException\n being thrown.  \n\n\n\n\nWe need to catch all checked exceptions or let it propagate to the calling method.  Otherwise, the program will not compile.  \n\n\nFor unchecked exceptions, even though we could catch it, it makes more sense to eliminate the bugs.  In Java, unchecked exceptions are subclasses of \nRuntimeException\n.  All \nError\ns are unchecked.\n\n\nAll methods that throw checked exception need to \nspecify\n the checked exception(s).  For example, if we want to put the code to open a file and read an \nint\n from it into a function, and want the calling function to deal with the exception, this is what we should do:\n\n\n1\n2\n3\n4\n5\n6\n7\n8\npublic\n \nstatic\n \nint\n \nreadIntFromFile\n(\nString\n \nfilename\n)\n\n  \nthrows\n \nFileNotFoundException\n \n{\n\n  \nFileReader\n \nreader\n \n=\n \nnew\n \nFileReader\n(\nfilename\n);\n\n  \nScanner\n \nscanner\n \n=\n \nnew\n \nScanner\n(\nreader\n);\n\n  \nint\n \nnumOfPoints\n \n=\n \nscanner\n.\nnextInt\n();\n    \n  \nscanner\n.\nclose\n();\n\n  \nreturn\n \nnumOfPoints\n;\n\n\n}\n\n\n\n\n\n\n\nNote Line 2 specify that this method might throw \nFileNotFoundException\n.  \n\n\nA checked exception must be either caught or thrown to calling function, except \nmain\n, which has no calling function to throw to.  If the main() does not catch an checked exception, the running program exits, and the exception is revealed to the user -- this is generally considered as bad programming.\n\n\nThe two other exceptions from the examples above \nInputMismatchException\n and \nNoSuchElementException\n are subclasses of \nRuntimeException\n, and therefore are unchecked.\n\n\nGenerating Exception\n\n\nThe Circle constructor in Lab 1 requires the distance \n\\(d\\)\n between two input points to be \n\\(0 < d \\le 2r\\)\n.  If the condition is violated, you are asked to return an invalid circle.  Another way is to throw an unchecked exception \nIllegalArgumentException\n if one of the above two conditions is met.  \n\n\n1\n2\n3\n4\n5\n6\n7\npublic\n \nCircle\n(\nPoint\n \np\n,\n \nPoint\n \nq\n,\n \ndouble\n \nr\n,\n \nboolean\n \ncenterOnLeft\n)\n \n{\n\n  \nif\n \n(\np\n.\ndistanceTo\n(\nq\n)\n \n>\n \n2\n*\nr\n)\n \n{\n\n    \nthrow\n \nnew\n \nIllegalArgumentException\n(\n\"Input points are too far apart\"\n);\n\n  \n}\n\n  \nif\n \n(\np\n.\nequals\n(\nq\n))\n \n{\n\n    \nthrow\n \nnew\n \nIllegalArgumentException\n(\n\"Input points coincide\"\n);\n\n  \n}\n\n\n\n\n\n\n\nNote that difference between \nthrow\n and \nthrows\n: the former is to generate an exception, the latter to specify that the exception(s) thrown by a method.\n\n\nIf you find that none of the \nexceptions provided by Java\n meet your needs, you can create your own exceptions, by simply inheriting from one of the existing ones.\nBut, you should only do so if there is a good reason, for instance, to provide additional useful information to the exception handler.\n\n\nOverriding Method that Throws Exceptions\n\n\nWhen you override a method that throws a checked exception, the overriding method must throw only the same, or a more specific checked exception, than the overridden method.  This rule enforces the Liskov Substitution Principle.  The caller of the overridden method cannot expect any new checked exception than what has already been \"promised\" in the method specification.\n\n\nGood Practices for Exception Handling\n\n\nCatch Exceptions to Clean Up\n\n\nWhile it is convenient to just let the calling method deals with exceptions (\"Hey! Not my problem!\"), it is not always responsible to do so.  Consider the example earlier, where \nm1()\n, \nm2()\n, and \nm3()\n do not handle exception E2.  Let's say that E2 is a checked exception, and it is possible to react to this and let the program continues properly.  Also, suppose that \nm2()\n allocated some system resources (e.g., temporary files, network connections) at the beginning of the method, and deallocated the resources at the end of the method.  Not handling the exception, means that, code that deallocates these resources does not get called when an exception occur!  It is better for \nm2()\n to catch the exception, handle the resource deallocation in a \nfinally\n block.  If there is a need for the calling methods to be aware of the exception, \nm2()\n can always re-throw the exception:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\npublic\n \nvoid\n \nm2\n()\n \nthrows\n \nE2\n \n{\n\n  \ntry\n \n{\n\n    \n// setup resources\n\n    \nm3\n();\n\n  \n}\n\n  \ncatch\n \n(\nE2\n \ne\n)\n \n{\n\n    \nthrow\n \ne\n;\n\n  \n}\n\n  \nfinally\n \n{\n\n    \n// clean up resources\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nNote that the \nfinally\n block is always executed even when \nreturn\n or \nthrow\n is called in a \ncatch\n block.\n\n\nCatch All Exception is Bad\n\n\nSometimes, you just want to focus on the main logic of the program and get it working instead of dealing with the exceptions.  Since Java uses checked exceptions, it forces you to handle the exceptions or else your code will not compile.  One way to quickly get around this is to write:\n\n\n1\n2\n3\n4\ntry\n \n{\n\n  \n// your code\n\n\n}\n\n\ncatch\n \n(\nException\n \ne\n)\n \n{}\n\n\n\n\n\n\n\nto shut the compiler up.  DO NOT DO THIS.  All exceptions thrown are now silently ignored!  \n\n\nCan we do \nworse\n?  How about the following:\n\n1\n2\n3\n4\ntry\n \n{\n\n  \n// your code\n\n\n}\n\n\ncatch\n \n(\nError\n \ne\n)\n \n{}\n\n\n\n\n\n\ud83d\ude31\n\n\nOverreacting\n\n\nDo not exit a program just because of exception.  This would prevent the calling function from cleaning up their resources.  Worse, do not exit a program silently.\n\n\n1\n2\n3\n4\n5\n6\ntry\n \n{\n\n  \n// your code\n\n\n}\n\n\ncatch\n \n(\nException\n \ne\n)\n \n{\n\n  \nSystem\n.\nexit\n(\n0\n);\n\n\n}\n\n\n\n\n\n\n\nDo Not Break Abstraction Barrier\n\n\nSometimes, letting the calling method handles the exception causes the implementation details to be leak, and make it harder to change the implementation later.\n\n\nFor instance, suppose we design a class \nClassRoster\n with a method \ngetStudents()\n, which reads the list of students from a text file.\n\n\n1\n2\n3\n4\n5\n6\nclass\n \nClassRoster\n \n{\n\n   \n:\n\n  \npublic\n \nStudents\n[]\n \ngetStudents\n()\n \nthrows\n \nFileNotFoundException\n \n{\n\n    \n:\n\n  \n}\n\n\n}\n\n\n\n\n\nLater, we change the implementation to reading the list from an SQL database,\n\n1\n2\n3\n4\n5\n6\nclass\n \nClassRoster\n \n{\n\n   \n:\n\n  \npublic\n \nStudents\n[]\n \ngetStudents\n()\n \nthrows\n \nSQLException\n \n{\n\n    \n:\n\n  \n}\n\n\n}\n\n\n\n\n\nWe should, as much as possible, handle the implementation specific exceptions within the abstraction barrier.  \n\n\nGenerics\n\n\nThird topic of today is on generics.  \n\n\nSuppose you want to create a new class that encapsulates a queue of circles.  You wrote:\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nclass\n \nCircleQueue\n \n{\n\n  \nprivate\n \nCircle\n[]\n \ncircles\n;\n\n   \n:\n\n  \npublic\n \nCircleQueue\n(\nint\n \nsize\n)\n \n{...}\n\n  \npublic\n \nboolean\n \nisFull() {\n...}\n\n  \npublic\n \nboolean\n \nisEmpty() {\n...}\n\n  \npublic\n \nvoid\n \nenqueue\n(\nCircle\n \nc\n)\n \n{...}\n\n  \npublic\n \nCircle\n \ndequeue() {\n...}\n\n\n}\n\n\n\n\n\n\n\nLater, you found that you need a new class that encapsulates a queue of points.  You wrote:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nclass\n \nPointQueue\n \n{\n\n  \nprivate\n \nPoint\n[]\n \npoints\n;\n\n   \n:\n\n  \npublic\n \nPointQueue\n(\nint\n \nsize\n)\n \n{...}\n\n  \npublic\n \nboolean\n \nisFull() {\n...}\n\n  \npublic\n \nboolean\n \nisEmpty() {\n...}\n\n  \npublic\n \nvoid\n \nenqueue\n(\nPoint\n \np\n)\n \n{...}\n\n  \npublic\n \nPoint\n \ndequeue() {\n...}\n\n\n}\n\n\n\n\n\n\nAnd you realize that there are actually a lot of similar code.  Invoking the \nabstraction principle\n, which states that \n\"Where similar functions are carried out by distinct pieces of code, it is generally beneficial to combine them into one by abstracting out the varying parts\n\", you decided to create an queue of Objects to replace the two classes above.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nclass\n \nObjectQueue\n \n{\n\n  \nprivate\n \nObject\n[]\n \nobjects\n;\n\n   \n:\n\n  \npublic\n \nObjectQueue\n(\nint\n \nsize\n)\n \n{...}\n\n  \npublic\n \nboolean\n \nisFull\n()\n \n{...}\n\n  \npublic\n \nboolean\n \nisEmpty\n()\n \n{...}\n\n  \npublic\n \nvoid\n \nenqueue\n(\nObject\n \no\n)\n \n{...}\n\n  \npublic\n \nObject\n \ndequeue\n()\n \n{...}\n\n\n}\n\n\n\n\n\n\n\nNow you have a very general class, that you can use to store objects of any kind, including a queue of strings, a queue of colors, etc.  You are quite pleased with yourself, as you should!  The early Java collection library contains many such generic data structures that stores elements of type \nObject\n.\n\n\nTo create a queue of 10 circles and add some circles, you just need:\n\n1\n2\n3\n4\nObjectQueue\n \ncq\n \n=\n \nnew\n \nObjectQueue\n(\n10\n);\n\n\ncq\n.\nenqueue\n(\nnew\n \nCircle\n(\nnew\n \nPoint\n(\n0\n,\n \n0\n),\n \n10\n));\n\n\ncq\n.\nenqueue\n(\nnew\n \nCircle\n(\nnew\n \nPoint\n(\n1\n,\n \n1\n),\n \n5\n));\n\n \n:\n\n\n\n\n\n\nGetting a circle out of the queue is a bit more troublesome:\n\n1\nCircle\n \nc\n \n=\n \ncq\n.\ndequeue\n();\n\n\n\n\n\nWould generate a compilation error, since we cannot assign a variable of type \nObject\n to a variable of type \nCircle\n.\n\n\nWe can get around the compilation error by typecasting it into a \nCircle\n, since \nCircle\n is a subclass of \nObject\n, Java compiler would let it go, assuming that you know what you are doing.\n\n1\nCircle\n \nc\n \n=\n \n(\nCircle\n)\ncq\n.\ndequeue\n();\n\n\n\n\n\n\nThe code above, however, could be dangerous.  For instance, it might generate a runtime \nClassCastException\n if there is an object in the queue that is not \nCircle\n or its subclass.  To avoid runtime error, we should check the type first:\n\n\n1\n2\n3\n4\nObject\n \no\n \n=\n \ncq\n.\ndequeue\n();\n\n\nif\n \n(\no\n \ninstanceof\n \nCircle\n)\n \n{\n\n    \nCircle\n \nc\n \n=\n \n(\nCircle\n)\no\n;\n\n\n}\n\n\n\n\n\n\n\nWouldn't it be nice if we can still have general code, but let the compiler generates an error if we try to add a non-\nCircle\n into our queue of \nCircle\n objects, so that we don't have to check for the type of an object all the time?\n\n\nJava 5 introduces generics, which is a significant improvement to the type systems in Java.  It allows a \ngeneric class\n of some type \nT\n to be written:\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nclass\n \nQueue\n<\nT\n>\n \n{\n\n  \nprivate\n \nT\n[]\n \nobjects\n;\n\n   \n:\n\n  \npublic\n \nQueue\n<\nT\n>(\nint\n \nsize\n)\n \n{...}\n\n  \npublic\n \nboolean\n \nisFull\n()\n \n{...}\n\n  \npublic\n \nboolean\n \nisEmpty\n()\n \n{...}\n\n  \npublic\n \nvoid\n \nenqueue\n(\nT\n \no\n)\n \n{...}\n\n  \npublic\n \nT\n \ndequeue\n()\n \n{...}\n\n\n}\n\n\n\n\n\n\n\nT\n is known as \ntype parameter\n.\nThe same code as before can be written as:\n\n\n1\n2\n3\n4\nQueue\n<\nCircle\n>\n \ncq\n \n=\n \nnew\n \nQueue\n<\nCircle\n>(\n10\n);\n\n\ncq\n.\nenqueue\n(\nnew\n \nCircle\n(\nnew\n \nPoint\n(\n0\n,\n \n0\n),\n \n10\n));\n\n\ncq\n.\nenqueue\n(\nnew\n \nCircle\n(\nnew\n \nPoint\n(\n1\n,\n \n1\n),\n \n5\n));\n\n\nCircle\n \nc\n \n=\n \ncq\n.\ndequeue\n();\n\n\n\n\n\n\n\nHere, we passed \nCircle\n as \ntype argument\n to \nT\n, creating a \nparameterized type\n \nQueue<Circle>\n.\n\n\nIn Line 4, we no longer need to cast, and there is no danger of runtime error due to object of the wrong class being added to the queue, for doing this:\n\n1\n2\nQueue\n<\nCircle\n>\n \ncq\n \n=\n \nnew\n \nQueue\n<\nCircle\n>(\n10\n);\n\n\ncq\n.\nenqueue\n(\nnew\n \nPoint\n(\n1\n,\n \n3\n));\n\n\n\n\n\nwill generate a compile time error! \n\n\n\n\nDiamond Notation\n\n\nWe can use the short form \n<>\n in the constructor as the compiler can infer the type:\n\n1\nQueue\n<\nCircle\n>\n \ncq\n \n=\n \nnew\n \nQueue\n<>(\n10\n);\n\n\n\n\n\n\n\n\nWe can use parameterized type anywhere a type is used, including as type argument.  If we want to have a queue of queue of circle, we can:\n    \n1\nQueue\n<\nQueue\n<\nCircle\n>>\n \ncqq\n \n=\n \nnew\n \nQueue\n<>(\n10\n);\n\n\n\n\n\n\nWe will see many examples of generics next lecture.\n\n\n\n\n\n\n\n\n\n\nThe actual memory store is more complex that what is presented here, but for the purpose of this lecture, we only consider heap and stack.  Heap and stack is also common to all the languages and runtime system I am aware of.\u00a0\n\u21a9\n\n\n\n\n\n\nUnlike earlier figures, I didn't show the class metadata and method tables for simplicity.\u00a0\n\u21a9\n\n\n\n\n\n\nThis is not that difference from how an OS handles function call in a machine code, as you will see in CS2100/CS2106.\u00a0\n\u21a9\n\n\n\n\n\n\nThe other things are JVM implementation independent and not relevant to our discussion here.\u00a0\n\u21a9",
            "title": "4. Memory, Exceptions, Generics"
        },
        {
            "location": "/lec4/index.html#lecture-4-memory-exception-and-generics",
            "text": "",
            "title": "Lecture 4: Memory, Exception and Generics"
        },
        {
            "location": "/lec4/index.html#learning-outcomes",
            "text": "After this class, students should:   be understand when memory are allocated/deallocated from heap vs. from stack  understand the concept of call stack in JVM  understand how Java call by reference and call by value  know about the keywords  null ,  try ,  catch ,  finally ,  throw , and  throws .  appreciate why exceptions is useful way of handling errors  aware of the differences between errors, unchecked exception, and checked exception in Java  be able to trace through the control flow of  try / catch / finally  block  how to generate an exception and create a new exception  not commit bad practices when using exceptions  apprecaite why generics is helpful  be able to create generic class with type parameter, and instantiate parameterized type by passing in type arguments.",
            "title": "Learning Outcomes"
        },
        {
            "location": "/lec4/index.html#where-are-objects-and-variables-stored",
            "text": "First, let's look at where Java stores the objects and variables when a program is executed.  There are two memory regions, a heap and a stack 1 .  The  heap  is where all objects are allocated, while the  stack  is where all variables (including primitive types and object references) are allocated.  Considers the following two lines of code. 1\n2 Circle   c ;  c   =   new   Circle ( new   Point ( 1 ,   1 ),   8 );   \nLine 1 declares a variable  c .  When Java executes this line of code, it allocates some memory space for an object reference for  c , the content is initialized to  null .  Since  c  is a variable, it resides in the stack.   null  in Java  null  is a special value for object reference, that signify that this reference is not pointing to any object.  This is similar to the  null  in Javascript,  NULL  macro in C,  nullptr  in C++11,  None  in Python,  nil  in Objective-C.  (Again, you see here computer scientists just can't agree on names!)   Sir Tony Hoare  (who also invented quicksort) famously apologized for inventing the null pointer.  He calls it his billion-dollar mistake.   Line 2 creates a new Circle object.  When Java executes this line of code, it allocates some memory space for a  Circle  object on the heap.  The memory address of this memory space becomes the reference of the object, and is assigned to the variable  c .  This is shown in the figure below 2 .   The first argument to  Circle  constructor is also an object, so to be more precise, when Line 2 above is executed, a  Point  object is also created and allocated on the heap.  So the field  c  inside  Circle  is actually a reference to this object.   Now, let's look at a slightly different example.  1\n2\n3\n4\n5\n6 Circle   c ;  Point   center ;  double   radius ;  radius   =   8 ;  center   =   new   Point ( 1 ,   1 );  c   =   new   Circle ( center ,   radius );    In the second example, we have three variables,  c ,  center , and  radius  .  Lines 1-3 declare the variables, and as a result, we have three variables allocated on the stack.  Recall that for object references, they are initialized to  null .  Primitive type variables (e.g.,  radius ) are initialized to 0.   After Lines 4-6, we have:",
            "title": "Where are Objects and Variables Stored?"
        },
        {
            "location": "/lec4/index.html#call-stack",
            "text": "Now, let's look at what happens when we invoke a method.  Take the  distanceTo  method in  Point  as an example:  1\n2\n3\n4\n5\n6\n7 class   Point   { \n   private   double   x ; \n   private   double   y ; \n   public   double   distanceTo ( Point   q )   { \n     return   Math . sqrt (( q . x   -   this . x )*( q . x   -   this . x )+( q . y   -   this . y )*( q . y   -   this . y )); \n   }  }   \nand the invocation: 1\n2\n3 Point   p1   =   new   Point ( 0 , 0 );  Point   p2   =   new   Point ( 1 , 1 );  p1 . distanceTo ( p2 );    After declaring  p1  and  p2  and creating both objects, we have:  Let's see what happen when we call  distanceTo .  How is the argument  q  initialized?  What about  this ?    When  distanceTo  is called, Java (to be more precise, the Java Virtual Machine, or JVM) creates a  stack frame  for this instance method call.  This stack frame is a region of memory that tentatively contains (i) the  this  reference, (ii) the method arguments, and (iii) local variables within the method, among other things 3 4 .  When a class method is called, the stack frame does not contain the  this  reference.   You can see that the  reference  of the objects  p1  and  p2  are copied onto the stack frame.  p1  and  this  point to the same object, and  p2  and  q  point to the same object.\nWithin the method, any modification done to  this  would change the object referenced to by  p1 , and any change made to  q  would change the object referenced to by  p2  as well.\nAfter the method returns, the stack frame for that method is destroyed.  Let's call the  move  function from your  Lab 1 , with arguments  (double theta, double d) .  1\n2\n3 double   theta   =   Math . PI / 4.0 ;  double   distance   =   1 ;  p2 . move ( theta ,   distance );    Again, we create a stack frame, copy the reference to object  p2  into  this , copy  theta  from the calling function to  theta  the argument within the method, copy  distance  from the calling function to  d  the argument within the method.  Recall that, in this function, you actually change the  x  and  y  of  this  to move  p2 .     What is important here is that, as  theta  and  distance  are primitive types instead of references, we copy the values onto the stack.  If we change  theta  or  d  within  move , the  theta  and  distance  of the calling function will not change.  This behavior is the same as you would expect in C.  However, unlike in C where you can pass in a pointer to a variable, you cannot pass in a reference to a primitive type in any way in Java.  If you want to pass in a variable of primitive type into a method and have its value changed, you will have to use a  wrapper class , but we leave the details of that for another lesson on another day.  In short, Java uses  call by value  for primitive types, and  call by reference  for objects.  If we made multiple nested method calls, as we usually do, the stack frames get stacked on top of each other.  For instance, in Lab 1,  main  calls  solve , which calls the  Circle  constructor, which calls the  angleTo .  When JVM is executing  angleTo , the call stack contains the stack frames of (in order of top to bottom):  angleTo ,  Circle  constructor,  solve , and  main .  One final note: the memory allocated on the stack are deallocated when a method returns.  The memory allocated on the heap, however, stays there as long as there is a reference to it (either from another object or from a variable in the stack).  Unlike C or C++, in Java, you do not have to free the memory allocated to objects.  The JVM runs a  garbage collector   that checks for unreferenced objects on the heap and cleans up the memory automatically.",
            "title": "Call Stack"
        },
        {
            "location": "/lec4/index.html#exceptions",
            "text": "One of the nuances of programming is having to write code to deal with exceptions and errors.  Consider writing a method that reads in a series of x and y coordinates from a file, not unlike what you have seen in Lab 1.  Here are some things that could go wrong:   The file to read from may not exist  The file to read from exists, but you may not have permission to read it  You can open the file for reading, but it might contain non-numeric text where you numerical values  The file might contain fewer values than expected  The file might become unreadable as you are reading through it (e.g., someone unplug the USB drive)   In C, we usually have to write code like this:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23 fd   =   fopen ( filename , \"r\" );  if   ( fd   ==   NULL )   { \n   fprintf ( stderr ,   \"Unable to open file. \" ); \n   if   ( errno   ==   ENFILE )   { \n     fprintf ( stderr ,   \"Too many opened files.  Unable to open another \\n \" ); \n   }   else   if   ( errno   ==   ENOENT )   { \n     fprintf ( stderr ,   \"No such file %s \\n \" ,   filename ); \n   }   else   if   ( errno   ==   EACCES )   { \n     fprintf ( stderr ,   \"No read permission to %s \\n \" ,   filename ); \n   } \n   return   - 1 ;  }  scanned   =   fscanf ( fd ,   \"%d\" ,   & num_of_points );  if   ( scanned   ==   0 )   { \n   fprintf ( stderr ,   \"Unable to scan for an integer \\n \" ); \n   fclose ( fd ); \n   return   - 2 ;  }  if   ( scanned   ==   EOF )   { \n   fprintf ( stderr ,   \"No input found. \\n \" ); \n   fclose ( fd ); \n   return   - 3 ;  }    Out of the lines above, only 2 lines correspond to the actual tasks, the others are for exception checking/handling.  How uncool is that?  Furthermore, the actual tasks are intersperse between exception checking code, making reading and understanding the logic of the code difficult.  The examples above also have to return different values to the calling method, because the calling method may have to do something to handle the errors.  Note that the POSIX APIs has a global variable  errno  which signifies the detailed error.  First, we have to check for different  errno  values and react accordingly (we can use  perror , but that has its limits).  Second,  errno  is global and we know that global variable is bad practice.  In fact, I am not even sure that code above works because  fprintf  in Line 3 might have changed  errno !  Then, there is the issue of having to repeatedly clean up after an error -- here we  fclose  the file if there is an error reading, twice.  It is easy to forgot to do so if we have to do this in multiple places.   Furthermore, if we need to perform more complex clean up, then we would end up with lots of repeated code.  Java supports  try / catch / finally  control statements, which is a way to group statements that check/handle errors together making code easier to read.  The Java equivalent to the above is:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18 try   { \n   reader   =   new   FileReader ( filename ); \n   scanner   =   new   Scanner ( reader ); \n   numOfPoints   =   scanner . nextInt ();  }  catch   ( FileNotFoundException   e )   { \n     System . err . println ( \"Unable to open \"   +   filename   +   \" \"   +   e );  }  catch   ( InputMismatchException   e )   { \n     System . err . println ( \"Unable to scan for an integer\" );  }  catch   ( NoSuchElementException   e )   { \n     System . err . println ( \"No input found\" );  }  finally   { \n   if   ( scanner   !=   null ) \n     scanner . close ();  }    Here Lines 2-4 keep the basic tasks together, and all the clean up tasks are grouped together in Lines 18-19.  Lines 8-16 handles the exceptions.  We no longer rely on global variable to convey the type of exceptions, or special return value to indicate exceptions.   What if we want the calling method to handle the exception?  Then, we simply do not do anything (i.e., do not catch the exception) and let the exception propagates to the calling method automatically.   Error vs. Exception in Java  We have been using the term error and exception loosely.  Java has different classes for  Error  and  Exception .   Error  is for situations where the program should terminate as generally there is no way to recover.  For instance, when the heap is full ( OutOfMemoryError ) or the stack is full ( StackOverflowError ).  Exceptions are for situations where it is still possible to reasonably recover from the error.    Combining Multiple Catches  In cases where the code to handle the exceptions is the same, you can 1\n2\n3 catch (FileNotFoundException | InputMismatchException | NoSuchElementException e) {\n    System.err.println(e);\n}    Here is a more detailed description of the control flow of exceptions.  Consider we have a  try - catch - finally  block that catches two exceptions  E1  and  E2 .  Inside the  try  block, we call a method  m1() ;  m1()  calls  m2() ;  m2()  calls  m3() , and  m3()  calls  m4() .   In a normal (no exception) situation, the control flow looks like this:   The statements in  try  block is executed, followed by the statements in  finally  block.  Now, let's suppose something went wrong deep inside the nested call, in  m4() .  One of the statement executes  throw new E2(); , which causes the execution in  m4()  to stop.  JVM now looks for the block of code that catches  E2 , going down the call stack, until it can find a place where the exception is handled.  In this example, we suppose that none of  m1() - m4()  handles (i.e.,  catch ) the exception.  Thus, JVM then jumps to the code that handles  E2 .  Finally, JVM executes the  finally  block.",
            "title": "Exceptions"
        },
        {
            "location": "/lec4/index.html#checked-exceptions",
            "text": "There are two types of exceptions in Java:  checked  and  unchecked  exceptions:   A checked exception is something that the programmer should anticipate and handle.  For instance, when you open a file, you should anticipate that in some cases, the file cannot be open.     An unchecked exception is something that the programmer does not anticipate, and usually is a result of bugs.  For example, when you try to call  p.distanceTo(q)  but  p  is  null , resulting in a  NullPointerException  being thrown.     We need to catch all checked exceptions or let it propagate to the calling method.  Otherwise, the program will not compile.    For unchecked exceptions, even though we could catch it, it makes more sense to eliminate the bugs.  In Java, unchecked exceptions are subclasses of  RuntimeException .  All  Error s are unchecked.  All methods that throw checked exception need to  specify  the checked exception(s).  For example, if we want to put the code to open a file and read an  int  from it into a function, and want the calling function to deal with the exception, this is what we should do:  1\n2\n3\n4\n5\n6\n7\n8 public   static   int   readIntFromFile ( String   filename ) \n   throws   FileNotFoundException   { \n   FileReader   reader   =   new   FileReader ( filename ); \n   Scanner   scanner   =   new   Scanner ( reader ); \n   int   numOfPoints   =   scanner . nextInt ();     \n   scanner . close (); \n   return   numOfPoints ;  }    Note Line 2 specify that this method might throw  FileNotFoundException .    A checked exception must be either caught or thrown to calling function, except  main , which has no calling function to throw to.  If the main() does not catch an checked exception, the running program exits, and the exception is revealed to the user -- this is generally considered as bad programming.  The two other exceptions from the examples above  InputMismatchException  and  NoSuchElementException  are subclasses of  RuntimeException , and therefore are unchecked.",
            "title": "Checked Exceptions"
        },
        {
            "location": "/lec4/index.html#generating-exception",
            "text": "The Circle constructor in Lab 1 requires the distance  \\(d\\)  between two input points to be  \\(0 < d \\le 2r\\) .  If the condition is violated, you are asked to return an invalid circle.  Another way is to throw an unchecked exception  IllegalArgumentException  if one of the above two conditions is met.    1\n2\n3\n4\n5\n6\n7 public   Circle ( Point   p ,   Point   q ,   double   r ,   boolean   centerOnLeft )   { \n   if   ( p . distanceTo ( q )   >   2 * r )   { \n     throw   new   IllegalArgumentException ( \"Input points are too far apart\" ); \n   } \n   if   ( p . equals ( q ))   { \n     throw   new   IllegalArgumentException ( \"Input points coincide\" ); \n   }    Note that difference between  throw  and  throws : the former is to generate an exception, the latter to specify that the exception(s) thrown by a method.  If you find that none of the  exceptions provided by Java  meet your needs, you can create your own exceptions, by simply inheriting from one of the existing ones.\nBut, you should only do so if there is a good reason, for instance, to provide additional useful information to the exception handler.",
            "title": "Generating Exception"
        },
        {
            "location": "/lec4/index.html#overriding-method-that-throws-exceptions",
            "text": "When you override a method that throws a checked exception, the overriding method must throw only the same, or a more specific checked exception, than the overridden method.  This rule enforces the Liskov Substitution Principle.  The caller of the overridden method cannot expect any new checked exception than what has already been \"promised\" in the method specification.",
            "title": "Overriding Method that Throws Exceptions"
        },
        {
            "location": "/lec4/index.html#good-practices-for-exception-handling",
            "text": "",
            "title": "Good Practices for Exception Handling"
        },
        {
            "location": "/lec4/index.html#catch-exceptions-to-clean-up",
            "text": "While it is convenient to just let the calling method deals with exceptions (\"Hey! Not my problem!\"), it is not always responsible to do so.  Consider the example earlier, where  m1() ,  m2() , and  m3()  do not handle exception E2.  Let's say that E2 is a checked exception, and it is possible to react to this and let the program continues properly.  Also, suppose that  m2()  allocated some system resources (e.g., temporary files, network connections) at the beginning of the method, and deallocated the resources at the end of the method.  Not handling the exception, means that, code that deallocates these resources does not get called when an exception occur!  It is better for  m2()  to catch the exception, handle the resource deallocation in a  finally  block.  If there is a need for the calling methods to be aware of the exception,  m2()  can always re-throw the exception:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12 public   void   m2 ()   throws   E2   { \n   try   { \n     // setup resources \n     m3 (); \n   } \n   catch   ( E2   e )   { \n     throw   e ; \n   } \n   finally   { \n     // clean up resources \n   }  }    Note that the  finally  block is always executed even when  return  or  throw  is called in a  catch  block.",
            "title": "Catch Exceptions to Clean Up"
        },
        {
            "location": "/lec4/index.html#catch-all-exception-is-bad",
            "text": "Sometimes, you just want to focus on the main logic of the program and get it working instead of dealing with the exceptions.  Since Java uses checked exceptions, it forces you to handle the exceptions or else your code will not compile.  One way to quickly get around this is to write:  1\n2\n3\n4 try   { \n   // your code  }  catch   ( Exception   e )   {}    to shut the compiler up.  DO NOT DO THIS.  All exceptions thrown are now silently ignored!    Can we do  worse ?  How about the following: 1\n2\n3\n4 try   { \n   // your code  }  catch   ( Error   e )   {}   \n\ud83d\ude31",
            "title": "Catch All Exception is Bad"
        },
        {
            "location": "/lec4/index.html#overreacting",
            "text": "Do not exit a program just because of exception.  This would prevent the calling function from cleaning up their resources.  Worse, do not exit a program silently.  1\n2\n3\n4\n5\n6 try   { \n   // your code  }  catch   ( Exception   e )   { \n   System . exit ( 0 );  }",
            "title": "Overreacting"
        },
        {
            "location": "/lec4/index.html#do-not-break-abstraction-barrier",
            "text": "Sometimes, letting the calling method handles the exception causes the implementation details to be leak, and make it harder to change the implementation later.  For instance, suppose we design a class  ClassRoster  with a method  getStudents() , which reads the list of students from a text file.  1\n2\n3\n4\n5\n6 class   ClassRoster   { \n    : \n   public   Students []   getStudents ()   throws   FileNotFoundException   { \n     : \n   }  }   \nLater, we change the implementation to reading the list from an SQL database, 1\n2\n3\n4\n5\n6 class   ClassRoster   { \n    : \n   public   Students []   getStudents ()   throws   SQLException   { \n     : \n   }  }   \nWe should, as much as possible, handle the implementation specific exceptions within the abstraction barrier.",
            "title": "Do Not Break Abstraction Barrier"
        },
        {
            "location": "/lec4/index.html#generics",
            "text": "Third topic of today is on generics.    Suppose you want to create a new class that encapsulates a queue of circles.  You wrote:  1\n2\n3\n4\n5\n6\n7\n8\n9 class   CircleQueue   { \n   private   Circle []   circles ; \n    : \n   public   CircleQueue ( int   size )   {...} \n   public   boolean   isFull() { ...} \n   public   boolean   isEmpty() { ...} \n   public   void   enqueue ( Circle   c )   {...} \n   public   Circle   dequeue() { ...}  }    Later, you found that you need a new class that encapsulates a queue of points.  You wrote: 1\n2\n3\n4\n5\n6\n7\n8\n9 class   PointQueue   { \n   private   Point []   points ; \n    : \n   public   PointQueue ( int   size )   {...} \n   public   boolean   isFull() { ...} \n   public   boolean   isEmpty() { ...} \n   public   void   enqueue ( Point   p )   {...} \n   public   Point   dequeue() { ...}  }    And you realize that there are actually a lot of similar code.  Invoking the  abstraction principle , which states that  \"Where similar functions are carried out by distinct pieces of code, it is generally beneficial to combine them into one by abstracting out the varying parts \", you decided to create an queue of Objects to replace the two classes above.  1\n2\n3\n4\n5\n6\n7\n8\n9 class   ObjectQueue   { \n   private   Object []   objects ; \n    : \n   public   ObjectQueue ( int   size )   {...} \n   public   boolean   isFull ()   {...} \n   public   boolean   isEmpty ()   {...} \n   public   void   enqueue ( Object   o )   {...} \n   public   Object   dequeue ()   {...}  }    Now you have a very general class, that you can use to store objects of any kind, including a queue of strings, a queue of colors, etc.  You are quite pleased with yourself, as you should!  The early Java collection library contains many such generic data structures that stores elements of type  Object .  To create a queue of 10 circles and add some circles, you just need: 1\n2\n3\n4 ObjectQueue   cq   =   new   ObjectQueue ( 10 );  cq . enqueue ( new   Circle ( new   Point ( 0 ,   0 ),   10 ));  cq . enqueue ( new   Circle ( new   Point ( 1 ,   1 ),   5 )); \n  :    Getting a circle out of the queue is a bit more troublesome: 1 Circle   c   =   cq . dequeue ();   \nWould generate a compilation error, since we cannot assign a variable of type  Object  to a variable of type  Circle .  We can get around the compilation error by typecasting it into a  Circle , since  Circle  is a subclass of  Object , Java compiler would let it go, assuming that you know what you are doing. 1 Circle   c   =   ( Circle ) cq . dequeue ();    The code above, however, could be dangerous.  For instance, it might generate a runtime  ClassCastException  if there is an object in the queue that is not  Circle  or its subclass.  To avoid runtime error, we should check the type first:  1\n2\n3\n4 Object   o   =   cq . dequeue ();  if   ( o   instanceof   Circle )   { \n     Circle   c   =   ( Circle ) o ;  }    Wouldn't it be nice if we can still have general code, but let the compiler generates an error if we try to add a non- Circle  into our queue of  Circle  objects, so that we don't have to check for the type of an object all the time?  Java 5 introduces generics, which is a significant improvement to the type systems in Java.  It allows a  generic class  of some type  T  to be written:  1\n2\n3\n4\n5\n6\n7\n8\n9 class   Queue < T >   { \n   private   T []   objects ; \n    : \n   public   Queue < T >( int   size )   {...} \n   public   boolean   isFull ()   {...} \n   public   boolean   isEmpty ()   {...} \n   public   void   enqueue ( T   o )   {...} \n   public   T   dequeue ()   {...}  }    T  is known as  type parameter .\nThe same code as before can be written as:  1\n2\n3\n4 Queue < Circle >   cq   =   new   Queue < Circle >( 10 );  cq . enqueue ( new   Circle ( new   Point ( 0 ,   0 ),   10 ));  cq . enqueue ( new   Circle ( new   Point ( 1 ,   1 ),   5 ));  Circle   c   =   cq . dequeue ();    Here, we passed  Circle  as  type argument  to  T , creating a  parameterized type   Queue<Circle> .  In Line 4, we no longer need to cast, and there is no danger of runtime error due to object of the wrong class being added to the queue, for doing this: 1\n2 Queue < Circle >   cq   =   new   Queue < Circle >( 10 );  cq . enqueue ( new   Point ( 1 ,   3 ));   \nwill generate a compile time error!    Diamond Notation  We can use the short form  <>  in the constructor as the compiler can infer the type: 1 Queue < Circle >   cq   =   new   Queue <>( 10 );     We can use parameterized type anywhere a type is used, including as type argument.  If we want to have a queue of queue of circle, we can:\n     1 Queue < Queue < Circle >>   cqq   =   new   Queue <>( 10 );    We will see many examples of generics next lecture.      The actual memory store is more complex that what is presented here, but for the purpose of this lecture, we only consider heap and stack.  Heap and stack is also common to all the languages and runtime system I am aware of.\u00a0 \u21a9    Unlike earlier figures, I didn't show the class metadata and method tables for simplicity.\u00a0 \u21a9    This is not that difference from how an OS handles function call in a machine code, as you will see in CS2100/CS2106.\u00a0 \u21a9    The other things are JVM implementation independent and not relevant to our discussion here.\u00a0 \u21a9",
            "title": "Generics"
        },
        {
            "location": "/lec5/index.html",
            "text": "Lecture 5: Numbers, Strings, Collections\n\n\nLearning Outcomes\n\n\n\n\nFamiliar with wrapper classes with primitives and autoboxing / unboxing; when to use primitive types and when to use wrapper classes\n\n\nUnderstand the differences between mutable and immutable objects, using \nString\n and \nStringBuilder\n as example\n\n\nFamiliar with the \nComparator\n and \nIterator\n interfaces\n\n\nUnderstand more about generics: type erasure, generic methods, wildcard types, bounded wild card types.\n\n\nFamiliar with Java collection frameworks: \nSet\n, \nList\n, \nMap\n and their concrete class \nHashSet\n, \nLinkedList\n, \nArrayList\n, and \nHashMap\n.\n\n\nAware of the other classes in Java Collection and is comfortable to look them up by reading the Java documentation.\n\n\nUnderstand the need to override \nhashCode\n every time \nequals\n is overriden.\n\n\nUnderstand there are differences between the collection classes and know when to use which one\n\n\n\n\nWrapper Classes\n\n\n\n\nEarlier Version of This Note\n\n\nAn earlier version of this note includes a discussion on passing-by-reference and motiving the use of wrapper class through swapping, which is wrong.  Please ignore that.\n\n\n\n\nRecall the generic class \nQueue<E>\n which we talked in \nLecture 4\n.  We can declare a \nQueue\n of \nPoint\n, a \nQueue\n of \nCircle\n, etc, but we cannot create a \nQueue\n of \nint\n or a \nQueue\n of \nboolean\n.  We can only pass in a class name to the type parameter \nE\n, not a primitive type.  So, to create a queue of integers, we cannot use \nQueue<int>\n -- we have to use \nQueue<Integer>\n.\n\n\nJava provides a set of wrapper class:  one for each primitive type: \nBoolean\n, \nByte\n, \nCharacter\n, \nInteger\n, \nDouble\n, \nLong\n, \nFloat\n, and \nShort\n.\n\n\n1\n2\n3\n4\nQueue\n<\nInteger\n>\n \niq\n \n=\n \nnew\n \nQueue\n<\nInteger\n>(\n10\n);\n\n\ncq\n.\nenqueue\n(\nnew\n \nInteger\n(\n4\n));\n\n\ncq\n.\nenqueue\n(\nnew\n \nInteger\n(\n8\n));\n\n\ncq\n.\nenqueue\n(\nnew\n \nInteger\n(\n15\n));\n\n\n\n\n\n\n\nJava 5 introduces something called \nautoboxing\n and \nunboxing\n, which creates the wrapper objects automatically (autoboxing) and retrieves its value (unboxing) automatically.  With autoboxing and unboxing, we can just write:\n\n\n1\n2\n3\n4\nQueue\n<\nInteger\n>\n \niq\n \n=\n \nnew\n \nQueue\n<\nInteger\n>(\n10\n);\n\n\ncq\n.\nenqueue\n(\n4\n);\n\n\ncq\n.\nenqueue\n(\n8\n);\n\n\ncq\n.\nenqueue\n(\n15\n);\n\n\n\n\n\n\n\nNote that \nenqueue\n expects an \nInteger\n object, but we pass in an \nint\n.  This would cause the \nint\n variable to automatically be boxed (i.e., be wrapped in Integer object) and put onto the call stack of \nenqueue\n.  \n\n\n\n\nType Erasure\n\n\nThe reason why Java compiler does not allow generic class with primitive types, is that internally, the compiler uses \ntype erasure\n to implement generic class.  Type erasure just means that during compile time, the compiler replaces the type parameter with the most general type.  In the example given in \nLecture 4\n, \nE\n in \nQueue<E>\n is replaced with \nObject\n,  The compiler then inserts necessary cast to convert the \nObject\n to the type argument (e.g., \nCircle\n), exactly like how it is done in the \nObjectQueue\n example, and additional checks to ensure that only objects of given type is used as \nE\n (e.g., cannot add \nPoint\n to \nQueue<Circle>\n).  Since primitive types are not subclass \nObject\n, replacing \nE\n with primitive types would not work with type erasure.\n\n\nNote that, as a consequence of type erasure, at runtime, Java has no information about \nE\n.\n\n\n\n\nIn short, wrapper class allows us to use primitive types to parameterize a generic class, and we do not have to write code to box and unbox the primitive types.\n\n\nPerformance Penalty\n\n\nIf the wrapper class is so great, why not use it all the time and forget about primitive types?  \n\n\nThe answer: performance.  Because using an object comes with the cost of allocating memory for the object and collecting of garbage afterwards, it is less efficient than primitive types.  Consider the following two programs:\n\n\n1\n2\n3\n4\n5\nDouble\n \nsum\n;\n\n\nfor\n \n(\nint\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \nInteger\n.\nMAX_VALUE\n;\n \ni\n++)\n\n\n{\n\n    \nsum\n \n+=\n \ni\n;\n\n\n}\n\n\n\n\n\nvs.\n\n1\n2\n3\n4\n5\ndouble\n \nsum\n;\n\n\nfor\n \n(\nint\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \nInteger\n.\nMAX_VALUE\n;\n \ni\n++)\n\n\n{\n\n    \nsum\n \n+=\n \ni\n;\n\n\n}\n\n\n\n\n\n\nThe second one is 2 times faster!  Due to autoboxing and unboxing, the cost of creating objects become hidden and often forgotten.\n\n\nAll primitive wrapper class objects are immutable.\n\nWhat this means is that once you create an object, it cannot be changed.  Thus, everytime \nsum\n in the example above is updated, a new object gets created!\n\n\nString and StringBuilder\n\n\nAnother place with hidden cost for object creation and allocation is when dealing with \nString\n.\n\n\nA \nString\n object is also \nimmutable\n.\n\nWhen we do:\n\n1\n2\n3\nString\n \nwords\n \n=\n \n\"\"\n;\n\n\nwords\n \n+=\n \n\"Hello \"\n;\n\n\nwords\n \n+=\n \n\"World!\"\n;\n\n\n\n\n\nA new \nString\n object is created everytime we concatenate it with another \nString\n.\n\n\nJava provides a mutable version of \nString\n, called \n[StringBuilder](https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuilder.html)\n.  To build up a string, we could do:\n\n1\n2\n3\n4\nStringBuilder\n \nwordsBuilder\n \n=\n \nnew\n \nStringBuilder\n();\n\n\nwordsBuilder\n.\nappend\n(\n\"Hello \"\n);\n\n\nwordsBuilder\n.\nappend\n(\n\"World!\"\n);\n\n\nString\n \nwords\n \n=\n \nwordsBuilder\n.\ntoString\n();\n\n\n\n\n\n\nCode that uses \nStringBuilder\n is not as intuitive and readable than just using the \n+\n operator.  My preference is to use \nString\n and \n+\n for occasional concatenation, and \nStringBuilder\n for frequent concatenation that could become performance bottleneck.\n\n\nEquality for Strings and Numbers\n\n\nThe following is a common bug, so worthy of a special mention here, with its own header!\n\n\nOne common mistake when comparing strings and numbers is to do the following:\n\n\n1\n2\n3\nString\n \ns1\n \n=\n \nnew\n \nString\n(\n\"Hello\"\n);\n\n\nString\n \ns2\n \n=\n \nnew\n \nString\n(\n\"Hello\"\n);\n\n\nif\n \n(\ns1\n \n==\n \ns2\n)\n \n{\n \n...\n \n}\n\n\n\n\n\n\n\nor\n\n1\n2\n3\nInteger\n \ni1\n \n=\n \n2342\n;\n\n\nInteger\n \ni2\n \n=\n \n2342\n;\n\n\nif\n \n(\ni1\n \n==\n \ni2\n)\n \n{\n \n...\n \n}\n\n\n\n\n\n\nRemember that \n==\n compares only references: whether the two references are pointing the the same object or not.   The \nequals\n method has been overridden to compare if the values are the same or not.  So, the right way to compare two strings or two numbers are:\n\n\n1\n2\nif\n \n(\ns1\n.\nequals\n(\ns2\n))\n \n{\n \n...\n \n}\n\n\nif\n \n(\ni1\n.\nequals\n(\ni2\n))\n \n{\n \n...\n \n}\n\n\n\n\n\n\n\nIf you try:\n        \n1\n2\n3\nInteger\n \ni1\n \n=\n \n1\n;\n\n\nInteger\n \ni2\n \n=\n \n1\n;\n\n\nif\n \n(\ni1\n \n==\n \ni2\n)\n \n{\n \n...\n \n}\n\n\n\n\n\nIt might return \ntrue\n!  This behaviour is caused by some autoboxing optimization in the Integer class so that it does not create too many objects for frequently requested values.  It is called \nInteger caching\n.  If another \nInteger\n object with the same value has been autoboxed before, JVM just returns that object instead of returning a new one.\n        Do not rely on Integer caching for proper comparisons of \n==\n.  Use \nequals()\n, always.\n\n\nSimilarly, if you try:\n\n1\n2\n3\nString\n \ns1\n \n=\n \n\"hello\"\n;\n\n\nString\n \ns2\n \n=\n \n\"hello\"\n;\n\n\nif\n \n(\ns1\n \n==\n \ns2\n)\n \n{\n \n...\n \n}\n \n\n\n\n\nJava always returns \ntrue\n.  This is because, the Java \nString\n class internally maintain a pool of \ninterned string\n objects for all string literals and expression, as an optimization.  \n\n\nJava Collections\n\n\nNow, we turn our attention to the Java Collection Framework.  Java provides a rich set of classes for managing and manipulating data.  They efficiently implement many useful data structures (hash tables, red black trees, etc.) and algorithms (sorting, searching, etc.) so that we no longer have to.  As computer scientists, it is still very important for us to know how these data structures and algorithms can be implemented, how to prove some behaviors (such as running time) and their correctness, how certain trade offs are made, etc. They are so important that we have two modules dedicated to them: CS2040 and CS3230 in the core CS curriculum.\n\n\nFor CS2030, however, we focus on how to use them.\n\n\nCollection\n\n\nOne of the basic interface in Java Collection Framework is \nCollection<E>\n, it looks like:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\npublic\n \ninterface\n \nCollection\n<\nE\n>\n \nextends\n \nIterable\n<\nE\n>\n \n{\n\n  \nboolean\n \nadd\n(\nE\n \ne\n);\n\n  \nboolean\n \ncontains\n(\nObject\n \no\n);\n\n  \nboolean\n \nremove\n(\nObject\n \no\n);\n\n  \nvoid\n \nclear\n();\n\n  \nboolean\n \nisEmpty\n();\n\n  \nint\n \nsize\n();\n\n\n  \nboolean\n \nequals\n(\nObject\n \no\n);\n\n  \nint\n \nhashCode\n();\n\n\n  \nObject\n[]\n \ntoArray\n();\n\n  \n<\nT\n>\n \nT\n[]\n \ntoArray\n(\nT\n[]\n \na\n);\n\n\n  \nboolean\n \naddAll\n(\nCollection\n<?\n \nextends\n \nE\n>\n \nc\n);\n\n  \nboolean\n \ncontainsAll\n(\nCollection\n<?>\n \nc\n);\n\n  \nboolean\n \nremoveAll\n(\nCollection\n<?>\n \nc\n);\n\n  \nboolean\n \nretainAll\n(\nCollection\n<?>\n \nc\n);\n\n    \n:\n\n\n}\n\n\n\n\n\n\n\nThere are some newly added methods in Java 8 that we will visit in the second half of this module, but first,\nlet's try to understand what the definition above means.  First, like a generic class that you have seen, \nCollection\n is a \ngeneric interface\n parameterized with a type parameter \nE\n.  It extends a generic \nIterable<E>\n interface (we will get to this later).\n\n\nThe first six methods of \nCollection<E>\n should be self-explanatory.  \nadd\n adds an element into the collection; \ncontains\n checks if a given object is in the collection;  \nremove\n removes a single instance of the given object from the collection;  \nclear\n removes all objects from the collection;  \nisEmpty()\n checks if the collection has no elements or not; and finally, \nsize\n returns the number of elements.\n\n\nOne point of note is that \ncontains()\n relies of the implementation of \nequals()\n to check if the object exists in the collection or not.  Similarly, \nremove()\n relies on \nequals()\n to find the matching objects.  We said earlier that it is useful to override the \nequals\n methods of \nObject\n instead of implement our own \nequals\n because the overriden \nequals()\n will be called elsewhere.  This is one of the \"elsewhere\" I mentioned.  The documentation of \ncontains(o)\n mentions that it is gurantee to return \ntrue\n if there exists an element \ne\n such that \ne.equals(o)\n or \ne == null\n (if \no == null\n).  Ditto for \nremove(o)\n.\n\n\n\n\nNon-generic Methods\n\n\nYou might notice that, instead of \ncontains(E e)\nand \nremove(E e)\n, the \nCollection\n interface uses \ncontains(Object o)\n and \nremove(Object o)\n.  This little inconsistency, however, is harmless.  For instance, if you have a collection intended for circles only, adding a non-circle could be disastrous.  Trying to remove an non-circle or checking for a non-circle, would just return false.\nMore information can be found on this \nStackOverflow\n thread.\n\n\n\n\nJava Collection Framework allows classes that implements an interface to throw an \nUnsupportedOperationException\n if the implementation decides not to implement one of the operations (but still need to have the method in the class).\n\n\nThe methods on Lines 9-10 should also be familiar.  A collection can check if it is equal to another collection (which inevitably also a subclass of \nObject\n).  As before, we will explain why we need \nhashCode()\n later.  Just bear with it a little longer.\n\n\nThe method \ntoArray()\n on Line 12 returns an array containing all the elements inside this collection.  The second overloaded \ntoArray\n method takes in an array of generic type \nT\n.  If the collections fit in \na\n, \na\n is filled and returned.  Else, it allocates a new array of type \nT\n and returned.\n\n\nThe second \ntoArray\n method is a \ngeneric method\n.  It is declared with \n<T>\n to indicate that the method can take any type \nT\n.  When we call generic method, we do not have to pass in a type argument.  Instead, the Java compiler infers the type from the arguments.  If we call \ntoArray(new String[10)\n, it would return a \nString[]\n, if we call \ntoArray(new Point[0])\n, it would return a \nPoint[]\n and so on.\nIt is the caller resonsibility to pass in the right type, otherwise, an \nArrayStoreException\n will be thrown.\n\n\nThe next group of methods operate on another collection.  \naddAll\n add all the elements of collection \nc\n into the current collection; \ncontainsAll\n checks if all the elements of collection \nc\n are contained in the current collection; \nremoveAll\n removes all elements from collection \nc\n, and finally, \nretainsAll\n remove all elements not in \nc\n.\n\n\nWhat is more interesting about the methods is the type of \nc\n.  In \ncontainsAll\n, for instance, the collection \nc\n has the type \nCollection\n<?\n>\n.  \n?\n is known as wildcard type, or \nunknown\n type.  This notation is used to denote the supertype of all parameterized interfaces created from \nCollection<E>\n.\n\n\nIn \naddAll\n, \nc\n is declared as \nCollection\n<?\n \nextends\n \nE\n>\n.  The type parameter \n<?\n \nextends\n \nE\n>\n is an example of bounded type in generics.  It means that the type argument is still unknown, but we know that it extends \nE\n.  So, suppose I have a parameterized interface \nCollection<Circle>\n and \nCircle extends PaintedCircle\n, I can pass in a collection that has type \nCollection<PaintedCircle>\n.\n\n\nFinally, let's get back to supertype of \nCollection<E>\n, \nIterable<E>\n.  The \nIterable<E>\n interface provides only a single interface, \nIterator<E> iterator()\n, which returns a generic interface called \nIterator<E>\n over the collection.  An \nIterator\n is another interface that allows us to go through all the elements in a \nCollection<E>\n.  It has four method interfaces, three of which we will talk about today: \nhasNext()\n, which returns if there is a next element in the \nCollection<E>\n; \nnext()\n, which returns the next element (with paramterized type \nE\n; and \nremove()\n, which removes the last returned element from the \nCollection<E>\n.\n\n\nOK, so far I have talked about lots of methods but haven't showed any code.  This is because Java Collection Framework does not provide a class that implements the \nCollection<E>\n directly.  The documentation recommends that we implement the \nCollection<E>\n interface\n1\n if we want a collection of objects that allows duplicates and does not care about the orders.\n\n\nLet's move to somethat Java does have a concrete class implementation.\n\n\nSet and List\n\n\nThe \nSet<E>\n \nList<E>\n interfaces extend the \nCollection<E>\n class.  \nSet<E>\n is meant for implementing a collection of objects that does not allow duplicates (but still does not care about order of elements), while \nList<E>\n is for implementing a collection of objects that allow duplicates, but the order of elements matters.\n\n\nMathematically, a \nCollection<E>\n is used to implement a bag, \nSet<E>\n, a set, and \nList<E>\n, a sequence.\n\n\nTHe \nList<E>\n interface has additional methods for adding and removing elements.  \nadd(e)\n by default would just add to the end of the list.  \nadd(i, e)\n inserts \ne\n to position \ni\n.  \nget(i)\n returns the element at position \ni\n, \nremove(i)\n removes the elements at position \ni\n; \nset(i,e)\n replace the \ni\n-th element with \ne\n.\n\n\nUseful classes in Java collection that implements \nList<E>\n includes \nArrayList\n and \nLinkedList\n, and useful classhes that implements \nSet<E>\n includes \nHashSet\n.\n\n\nLet's see some examples:\n\n\n1\n2\n3\n4\n5\nList\n<\nString\n>\n \nnames\n \n=\n \nnew\n \nArrayList\n();\n\n\naryaList\n.\nadd\n(\n\"Cersei\"\n);\n\n\naryaList\n.\nadd\n(\n\"Joffrey\"\n);\n\n\naryaList\n.\nadd\n(\n0\n,\n \n\"Gregor\"\n);\n\n\nSystem\n.\nout\n.\nprintln\n(\naryaList\n.\nget\n(\n1\n));\n\n\n\n\n\n\n\nLine 1 above creates a empty array list.  The second line adds two strings into the list, each appending them to the list.  After executing Line 3, it would contain the sequence \n<\"Cersei\",\"Joffrey\">\n.  Line 4 inserts the string \n\"Gregor\"\n to position 0, moving the rest of the list down by 1 position.  The sequence is now \n<\"Gregor\",\"Cersei\",\"Joffrey\">\n.  Finally, calling \nget(1)\n would return the string \n\"Cersei\"\n.\n\n\nNote that we declare \nnames\n with the interface type \nList<String>\n.  We should always do this to keep our code flexible.  If we want to change our implementation to \nLinkedList\n, we only need to change Line 1 to:\n\n1\nList\n<\nString\n>\n \nnames\n \n=\n \nnew\n \nLinkedList\n();\n\n\n\n\n\n\nComparator\n\n\nThe \nList<E>\n interface also specifies a \nsort\n method, with the following specification:\n\n1\ndefault\n \nvoid\n \nsort\n(\nComparator\n<?\n \nsuper\n \nE\n>\n \nc\n)\n\n\n\n\n\n\nRemember at the end of Lecture 3 when we said there are \"unpure\" interfaces, that is interface that comes with implementation?  This is one of them.  The keyword \ndefault\n indicates that the interface \nList<E>\n comes with a default implementation of \nsort\n method.  So a class that implements the interface needs not implement it again if they do not want to.\n\n\nThis method specification is also interesting and worth looking closer.  It takes in an object \nc\n with generic interface \nComparator\n<?\n \nsuper\n \nE\n>\n.  Like \n<?\n \nextends\n \nE\n>\n that we have seen before, this is a \nbounded\n wildcard type.  While \n<?\n \nextends\n \nE\n>\n is an unknown type upper bounded by \nE\n, \n<?\n \nsuper\n \nE\n>\n is an unknown type lower bounded by \nE\n.  This means that we can pass in \nE\n or any supertype of E.\n\n\nWhat does the \nComparator\n interface do?  We can specify how to compare two elements of a given type, by implementing a \ncompare()\n method.\n\ncompare(o1,o2)\n should return 0 if the two elements are equals, a negative integer if o1 is \"less than\" o2, and a positive integer otherwise.\n\n\nLet's write \nComparator\n class\n2\n:\n\n\n1\n2\n3\n4\n5\nclass\n \nNameComparator\n \nimplements\n \nComparator\n<\nString\n>\n \n{\n\n    \npublic\n \nint\n \ncompare\n(\nString\n \ns1\n,\n \nString\n \ns2\n)\n \n{\n\n        \nreturn\n \ns1\n.\ncompareTo\n(\ns2\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nIn the above, we use the \ncompareTo\n method provided by the \nString\n class to do the comparison.  With the above, we can now sort the \nnames\n:\n\n\n1\nnames\n.\nsort\n(\nnew\n \nNameComparator\n());\n\n\n\n\n\n\n\nThis would result in the sequence being changed to \n<\"Cersei\",\"Gregor\",\"Joffrey\">\n.\n\n\nMap\n\n\nOne of the more powerful data structures provided by Java Collection is maps (also known as dictionary in other languages).  A map allows us to store a (unique key, value) pair into the collection, and retrieve the value later by looking up the key.\n\n\nThe \nMap<K,V>\n interface is again generic, but this time, has two type parameters, \nK\n for the type of the key, and \nV\n for the type of the value.  These makes the \nMap\n interface flexible -- we can use any type as the key and value.\n\n\nThe two most important methods for \nMap\n is \nput\n and \nget\n:\n\n\n1\n2\n    \nV\n \nput\n(\nK\n \nkey\n,\n \nV\n \nvalue\n);\n\n    \nV\n \nget\n(\nObject\n \nk\n);\n\n\n\n\n\n\n\nA useful class that implements \nMap\n interface is \nHashMap\n:\n\n\n1\n2\n3\n4\nMap\n<\nString\n,\nInteger\n>\n \npopulation\n \n=\n \nnew\n \nHashMap\n<\nString\n,\nInteger\n>();\n\n\npopulation\n.\nput\n(\n\"Oldtown\"\n,\n500000\n);\n\n\npopulation\n.\nput\n(\n\"Kings Landing\"\n,\n500000\n);\n\n\npopulation\n.\nput\n(\n\"Lannisport\"\n,\n300000\n);\n\n\n\n\n\n\n\nLater, if we want to lookup the value, we can:\n\n1\npopulation\n.\nget\n(\n\"Kings Landing\"\n);\n\n\n\n\n\n\nInternally, to implement \nput\n, \nHashMap\n calls key's \nhashCode\n to return a \nint\n, which it uses to determine which \"bucket\" to store the (key, value) pair.  When \nget\n, \nHashMap\n again calls \nhashCode\n on the given key to determine which bucket, then it looks for the key in the bucket.  This process, called \nhashing\n, circumvents the need to look through every pair in the map to find the right key.\n\n\nYou will learn more about hashing and hash tables in CS2040.\n\n\nBut, what is important here is that, two keys (two objects, in general) which are the same (\nequals()\n returns \ntrue\n), must have the same \nhashCode()\n.  Otherwise, \nHashMap\n would fail!\n\n\nSo it is important to ensure that if \no1.equals(o2)\n, then \no1.hashCode() == o2.hashCode()\n.  Note that the reverse does not have to be true -- two objects with the same hash code does not have to be equals.\n\n\nThis property is also useful for implementing \nequals()\n.  For a complex object, comparing every field for equality can be expensive.  If we can compare the hash code first, we could filter out objects with different hash code (since they cannot be equal).  We only need to compare field by field if the hash code is the same.\n\n\nDitto for implementation of \nHashSet\n -- to checks if an element to add already exists, \nHashSet\n uses hash code, instead of going through all the elements and compare one by one.\n\n\nCalculating good hash code is an involved topic, and is best left to the expert (some of you might become expert in this), but for now, we can rely on the static \nhashCode\n methods in the \nArray\n class to help us.\n\n\nWhich Collection Class?\n\n\nJava provides many collection classes, more than what we have time to go through.  It is important to know which one to use to get the best performance out of them.  For the few classes we have seen:\n\n\n\n\nUse \nHashMap\n if you want to keep a (key, value) pair for lookup later.\n\n\nUse \nHashSet\n if you have a collection of elements with no duplicates and order is not important.\n\n\nUse \nArrayList\n if you have a collection of elements with possibly duplicates and order is important, and retriving a specific location is more important than removing elements from the list.\n\n\nUse \nLinkedList\n if you have a collection of elements with possibly duplicates and order is important, retriving a specific location is less important than removing elements from the list.\n\n\n\n\nYou should understand the reasons above after CS2040.\n\n\nFurther, if you want to check if a given object is contained in the list, then \nArrayList\n and \nLinkedList\n are not good candidates.  \nHashSet\n, on the other hand, can quickly check if an item is already contained in the set.  There is unfortunately no standard collection class that supports fast \ncontain\n and allow duplicates.  Maybe CS2040, you can build you own collection class :)\n\n\nSample Code\n\n\nRequested by some students, I am dumping the code I used in class here.  They are badly written code (not following style guidelines, no comments, etc) edited live in class to demonstrate the concepts -- not meant to be a model of how code should be written.  Here they are:\n\n\nThe following code was used to demonstrate the overhead of using wrapper class unnecessary.\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\nclass\n \nDable\n \n{\n\n  \npublic\n \nstatic\n \nvoid\n \nmain\n(\nString\n[]\n \nargs\n)\n \n{\n\n    \n// Double sum = 0.0;\n\n    \ndouble\n \nsum\n \n=\n \n0.0\n;\n\n    \nfor\n \n(\nint\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \nInteger\n.\nMAX_VALUE\n;\n \ni\n++)\n\n    \n{\n\n          \nsum\n \n+=\n \ni\n;\n\n    \n}\n\n  \n}\n\n\n}\n\n\n\n\n\n\nThe following code was used to demonstrate sorting of an \nArrayList\n.\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\nimport\n \njava.util.*\n;\n\n\n\nclass\n \nNameComparator\n \nimplements\n \nComparator\n<\nString\n>\n \n{\n\n  \npublic\n \nint\n \ncompare\n(\nString\n \ns1\n,\n \nString\n \ns2\n)\n \n{\n\n    \n// return (s1.compareTo(s2));\n\n    \n// return (s2.compareTo(s1));\n\n    \nreturn\n \n(\ns2\n.\nlength\n()\n \n-\n \ns1\n.\nlength\n());\n\n  \n}\n\n\n}\n\n\n\nclass\n \nSortedList\n \n{\n\n  \npublic\n \nstatic\n \nvoid\n \nmain\n(\nString\n[]\n \nargs\n)\n \n{\n\n    \nList\n<\nString\n>\n \nnames\n \n=\n \nnew\n \nArrayList\n<\nString\n>();\n\n\n    \nnames\n.\nadd\n(\n0\n,\n \n\"Joffrey\"\n);\n\n    \nnames\n.\nadd\n(\n1\n,\n \n\"Cersei\"\n);\n\n    \nnames\n.\nadd\n(\n2\n,\n \n\"Meryn\"\n);\n\n    \nnames\n.\nadd\n(\n3\n,\n \n\"Walder\"\n);\n\n    \nnames\n.\nadd\n(\n4\n,\n \n\"Gregor\"\n);\n\n    \nnames\n.\nadd\n(\n5\n,\n \n\"Sandor\"\n);\n\n\n    \nSystem\n.\nout\n.\nprintln\n(\n\"Initial List\"\n);\n\n    \nfor\n \n(\nString\n \ni\n:\n \nnames\n)\n \n{\n\n      \nSystem\n.\nout\n.\nprintln\n(\ni\n);\n\n    \n}\n\n\n    \nnames\n.\nsort\n(\nnew\n \nNameComparator\n());\n\n\n    \nSystem\n.\nout\n.\nprintln\n(\n\"Sorted List\"\n);\n\n    \nfor\n \n(\nString\n \ni\n:\n \nnames\n)\n \n{\n\n      \nSystem\n.\nout\n.\nprintln\n(\ni\n);\n\n    \n}\n\n  \n}\n\n\n}\n\n\n\n\n\n\nThe following was used to demonstrate \nHashMap\n.\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\nimport\n \njava.util.*\n;\n\n\n\nclass\n \nPopulation\n \n{\n\n  \npublic\n \nstatic\n \nvoid\n \nmain\n(\nString\n[]\n \nargs\n)\n \n{\n\n    \nMap\n<\nString\n,\nInteger\n>\n \npopulation\n \n=\n \nnew\n \nHashMap\n<\nString\n,\nInteger\n>();\n\n    \npopulation\n.\nput\n(\n\"Oldtown\"\n,\n500000\n);\n\n    \npopulation\n.\nput\n(\n\"Kings Landing\"\n,\n500000\n);\n\n    \npopulation\n.\nput\n(\n\"Lannisport\"\n,\n300000\n);\n\n    \nSystem\n.\nout\n.\nprintln\n(\npopulation\n.\nget\n(\n\"Lannisport\"\n));\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIf you want to do so, however, it is likely more useful to inherit from the abstract class \nAbstractCollection<E>\n (which implements most of the basic methods of the interface) rather than implementing the interface \nCollection<E>\n directly.\u00a0\n\u21a9\n\n\n\n\n\n\nLater in CS2030, you will see how we significantly reduce the verbosity of this code!  But let's do it the hard way first.\u00a0\n\u21a9",
            "title": "5. Numbers, Strings, Collections"
        },
        {
            "location": "/lec5/index.html#lecture-5-numbers-strings-collections",
            "text": "",
            "title": "Lecture 5: Numbers, Strings, Collections"
        },
        {
            "location": "/lec5/index.html#learning-outcomes",
            "text": "Familiar with wrapper classes with primitives and autoboxing / unboxing; when to use primitive types and when to use wrapper classes  Understand the differences between mutable and immutable objects, using  String  and  StringBuilder  as example  Familiar with the  Comparator  and  Iterator  interfaces  Understand more about generics: type erasure, generic methods, wildcard types, bounded wild card types.  Familiar with Java collection frameworks:  Set ,  List ,  Map  and their concrete class  HashSet ,  LinkedList ,  ArrayList , and  HashMap .  Aware of the other classes in Java Collection and is comfortable to look them up by reading the Java documentation.  Understand the need to override  hashCode  every time  equals  is overriden.  Understand there are differences between the collection classes and know when to use which one",
            "title": "Learning Outcomes"
        },
        {
            "location": "/lec5/index.html#wrapper-classes",
            "text": "Earlier Version of This Note  An earlier version of this note includes a discussion on passing-by-reference and motiving the use of wrapper class through swapping, which is wrong.  Please ignore that.   Recall the generic class  Queue<E>  which we talked in  Lecture 4 .  We can declare a  Queue  of  Point , a  Queue  of  Circle , etc, but we cannot create a  Queue  of  int  or a  Queue  of  boolean .  We can only pass in a class name to the type parameter  E , not a primitive type.  So, to create a queue of integers, we cannot use  Queue<int>  -- we have to use  Queue<Integer> .  Java provides a set of wrapper class:  one for each primitive type:  Boolean ,  Byte ,  Character ,  Integer ,  Double ,  Long ,  Float , and  Short .  1\n2\n3\n4 Queue < Integer >   iq   =   new   Queue < Integer >( 10 );  cq . enqueue ( new   Integer ( 4 ));  cq . enqueue ( new   Integer ( 8 ));  cq . enqueue ( new   Integer ( 15 ));    Java 5 introduces something called  autoboxing  and  unboxing , which creates the wrapper objects automatically (autoboxing) and retrieves its value (unboxing) automatically.  With autoboxing and unboxing, we can just write:  1\n2\n3\n4 Queue < Integer >   iq   =   new   Queue < Integer >( 10 );  cq . enqueue ( 4 );  cq . enqueue ( 8 );  cq . enqueue ( 15 );    Note that  enqueue  expects an  Integer  object, but we pass in an  int .  This would cause the  int  variable to automatically be boxed (i.e., be wrapped in Integer object) and put onto the call stack of  enqueue .     Type Erasure  The reason why Java compiler does not allow generic class with primitive types, is that internally, the compiler uses  type erasure  to implement generic class.  Type erasure just means that during compile time, the compiler replaces the type parameter with the most general type.  In the example given in  Lecture 4 ,  E  in  Queue<E>  is replaced with  Object ,  The compiler then inserts necessary cast to convert the  Object  to the type argument (e.g.,  Circle ), exactly like how it is done in the  ObjectQueue  example, and additional checks to ensure that only objects of given type is used as  E  (e.g., cannot add  Point  to  Queue<Circle> ).  Since primitive types are not subclass  Object , replacing  E  with primitive types would not work with type erasure.  Note that, as a consequence of type erasure, at runtime, Java has no information about  E .   In short, wrapper class allows us to use primitive types to parameterize a generic class, and we do not have to write code to box and unbox the primitive types.",
            "title": "Wrapper Classes"
        },
        {
            "location": "/lec5/index.html#performance-penalty",
            "text": "If the wrapper class is so great, why not use it all the time and forget about primitive types?    The answer: performance.  Because using an object comes with the cost of allocating memory for the object and collecting of garbage afterwards, it is less efficient than primitive types.  Consider the following two programs:  1\n2\n3\n4\n5 Double   sum ;  for   ( int   i   =   0 ;   i   <   Integer . MAX_VALUE ;   i ++)  { \n     sum   +=   i ;  }   \nvs. 1\n2\n3\n4\n5 double   sum ;  for   ( int   i   =   0 ;   i   <   Integer . MAX_VALUE ;   i ++)  { \n     sum   +=   i ;  }    The second one is 2 times faster!  Due to autoboxing and unboxing, the cost of creating objects become hidden and often forgotten.  All primitive wrapper class objects are immutable. \nWhat this means is that once you create an object, it cannot be changed.  Thus, everytime  sum  in the example above is updated, a new object gets created!",
            "title": "Performance Penalty"
        },
        {
            "location": "/lec5/index.html#string-and-stringbuilder",
            "text": "Another place with hidden cost for object creation and allocation is when dealing with  String .  A  String  object is also  immutable . \nWhen we do: 1\n2\n3 String   words   =   \"\" ;  words   +=   \"Hello \" ;  words   +=   \"World!\" ;   \nA new  String  object is created everytime we concatenate it with another  String .  Java provides a mutable version of  String , called  [StringBuilder](https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuilder.html) .  To build up a string, we could do: 1\n2\n3\n4 StringBuilder   wordsBuilder   =   new   StringBuilder ();  wordsBuilder . append ( \"Hello \" );  wordsBuilder . append ( \"World!\" );  String   words   =   wordsBuilder . toString ();    Code that uses  StringBuilder  is not as intuitive and readable than just using the  +  operator.  My preference is to use  String  and  +  for occasional concatenation, and  StringBuilder  for frequent concatenation that could become performance bottleneck.",
            "title": "String and StringBuilder"
        },
        {
            "location": "/lec5/index.html#equality-for-strings-and-numbers",
            "text": "The following is a common bug, so worthy of a special mention here, with its own header!  One common mistake when comparing strings and numbers is to do the following:  1\n2\n3 String   s1   =   new   String ( \"Hello\" );  String   s2   =   new   String ( \"Hello\" );  if   ( s1   ==   s2 )   {   ...   }    or 1\n2\n3 Integer   i1   =   2342 ;  Integer   i2   =   2342 ;  if   ( i1   ==   i2 )   {   ...   }    Remember that  ==  compares only references: whether the two references are pointing the the same object or not.   The  equals  method has been overridden to compare if the values are the same or not.  So, the right way to compare two strings or two numbers are:  1\n2 if   ( s1 . equals ( s2 ))   {   ...   }  if   ( i1 . equals ( i2 ))   {   ...   }    If you try:\n         1\n2\n3 Integer   i1   =   1 ;  Integer   i2   =   1 ;  if   ( i1   ==   i2 )   {   ...   }   \nIt might return  true !  This behaviour is caused by some autoboxing optimization in the Integer class so that it does not create too many objects for frequently requested values.  It is called  Integer caching .  If another  Integer  object with the same value has been autoboxed before, JVM just returns that object instead of returning a new one.\n        Do not rely on Integer caching for proper comparisons of  == .  Use  equals() , always.  Similarly, if you try: 1\n2\n3 String   s1   =   \"hello\" ;  String   s2   =   \"hello\" ;  if   ( s1   ==   s2 )   {   ...   }    \nJava always returns  true .  This is because, the Java  String  class internally maintain a pool of  interned string  objects for all string literals and expression, as an optimization.",
            "title": "Equality for Strings and Numbers"
        },
        {
            "location": "/lec5/index.html#java-collections",
            "text": "Now, we turn our attention to the Java Collection Framework.  Java provides a rich set of classes for managing and manipulating data.  They efficiently implement many useful data structures (hash tables, red black trees, etc.) and algorithms (sorting, searching, etc.) so that we no longer have to.  As computer scientists, it is still very important for us to know how these data structures and algorithms can be implemented, how to prove some behaviors (such as running time) and their correctness, how certain trade offs are made, etc. They are so important that we have two modules dedicated to them: CS2040 and CS3230 in the core CS curriculum.  For CS2030, however, we focus on how to use them.",
            "title": "Java Collections"
        },
        {
            "location": "/lec5/index.html#collection",
            "text": "One of the basic interface in Java Collection Framework is  Collection<E> , it looks like:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20 public   interface   Collection < E >   extends   Iterable < E >   { \n   boolean   add ( E   e ); \n   boolean   contains ( Object   o ); \n   boolean   remove ( Object   o ); \n   void   clear (); \n   boolean   isEmpty (); \n   int   size (); \n\n   boolean   equals ( Object   o ); \n   int   hashCode (); \n\n   Object []   toArray (); \n   < T >   T []   toArray ( T []   a ); \n\n   boolean   addAll ( Collection <?   extends   E >   c ); \n   boolean   containsAll ( Collection <?>   c ); \n   boolean   removeAll ( Collection <?>   c ); \n   boolean   retainAll ( Collection <?>   c ); \n     :  }    There are some newly added methods in Java 8 that we will visit in the second half of this module, but first,\nlet's try to understand what the definition above means.  First, like a generic class that you have seen,  Collection  is a  generic interface  parameterized with a type parameter  E .  It extends a generic  Iterable<E>  interface (we will get to this later).  The first six methods of  Collection<E>  should be self-explanatory.   add  adds an element into the collection;  contains  checks if a given object is in the collection;   remove  removes a single instance of the given object from the collection;   clear  removes all objects from the collection;   isEmpty()  checks if the collection has no elements or not; and finally,  size  returns the number of elements.  One point of note is that  contains()  relies of the implementation of  equals()  to check if the object exists in the collection or not.  Similarly,  remove()  relies on  equals()  to find the matching objects.  We said earlier that it is useful to override the  equals  methods of  Object  instead of implement our own  equals  because the overriden  equals()  will be called elsewhere.  This is one of the \"elsewhere\" I mentioned.  The documentation of  contains(o)  mentions that it is gurantee to return  true  if there exists an element  e  such that  e.equals(o)  or  e == null  (if  o == null ).  Ditto for  remove(o) .   Non-generic Methods  You might notice that, instead of  contains(E e) and  remove(E e) , the  Collection  interface uses  contains(Object o)  and  remove(Object o) .  This little inconsistency, however, is harmless.  For instance, if you have a collection intended for circles only, adding a non-circle could be disastrous.  Trying to remove an non-circle or checking for a non-circle, would just return false.\nMore information can be found on this  StackOverflow  thread.   Java Collection Framework allows classes that implements an interface to throw an  UnsupportedOperationException  if the implementation decides not to implement one of the operations (but still need to have the method in the class).  The methods on Lines 9-10 should also be familiar.  A collection can check if it is equal to another collection (which inevitably also a subclass of  Object ).  As before, we will explain why we need  hashCode()  later.  Just bear with it a little longer.  The method  toArray()  on Line 12 returns an array containing all the elements inside this collection.  The second overloaded  toArray  method takes in an array of generic type  T .  If the collections fit in  a ,  a  is filled and returned.  Else, it allocates a new array of type  T  and returned.  The second  toArray  method is a  generic method .  It is declared with  <T>  to indicate that the method can take any type  T .  When we call generic method, we do not have to pass in a type argument.  Instead, the Java compiler infers the type from the arguments.  If we call  toArray(new String[10) , it would return a  String[] , if we call  toArray(new Point[0]) , it would return a  Point[]  and so on.\nIt is the caller resonsibility to pass in the right type, otherwise, an  ArrayStoreException  will be thrown.  The next group of methods operate on another collection.   addAll  add all the elements of collection  c  into the current collection;  containsAll  checks if all the elements of collection  c  are contained in the current collection;  removeAll  removes all elements from collection  c , and finally,  retainsAll  remove all elements not in  c .  What is more interesting about the methods is the type of  c .  In  containsAll , for instance, the collection  c  has the type  Collection <? > .   ?  is known as wildcard type, or  unknown  type.  This notation is used to denote the supertype of all parameterized interfaces created from  Collection<E> .  In  addAll ,  c  is declared as  Collection <?   extends   E > .  The type parameter  <?   extends   E >  is an example of bounded type in generics.  It means that the type argument is still unknown, but we know that it extends  E .  So, suppose I have a parameterized interface  Collection<Circle>  and  Circle extends PaintedCircle , I can pass in a collection that has type  Collection<PaintedCircle> .  Finally, let's get back to supertype of  Collection<E> ,  Iterable<E> .  The  Iterable<E>  interface provides only a single interface,  Iterator<E> iterator() , which returns a generic interface called  Iterator<E>  over the collection.  An  Iterator  is another interface that allows us to go through all the elements in a  Collection<E> .  It has four method interfaces, three of which we will talk about today:  hasNext() , which returns if there is a next element in the  Collection<E> ;  next() , which returns the next element (with paramterized type  E ; and  remove() , which removes the last returned element from the  Collection<E> .  OK, so far I have talked about lots of methods but haven't showed any code.  This is because Java Collection Framework does not provide a class that implements the  Collection<E>  directly.  The documentation recommends that we implement the  Collection<E>  interface 1  if we want a collection of objects that allows duplicates and does not care about the orders.  Let's move to somethat Java does have a concrete class implementation.",
            "title": "Collection"
        },
        {
            "location": "/lec5/index.html#set-and-list",
            "text": "The  Set<E>   List<E>  interfaces extend the  Collection<E>  class.   Set<E>  is meant for implementing a collection of objects that does not allow duplicates (but still does not care about order of elements), while  List<E>  is for implementing a collection of objects that allow duplicates, but the order of elements matters.  Mathematically, a  Collection<E>  is used to implement a bag,  Set<E> , a set, and  List<E> , a sequence.  THe  List<E>  interface has additional methods for adding and removing elements.   add(e)  by default would just add to the end of the list.   add(i, e)  inserts  e  to position  i .   get(i)  returns the element at position  i ,  remove(i)  removes the elements at position  i ;  set(i,e)  replace the  i -th element with  e .  Useful classes in Java collection that implements  List<E>  includes  ArrayList  and  LinkedList , and useful classhes that implements  Set<E>  includes  HashSet .  Let's see some examples:  1\n2\n3\n4\n5 List < String >   names   =   new   ArrayList ();  aryaList . add ( \"Cersei\" );  aryaList . add ( \"Joffrey\" );  aryaList . add ( 0 ,   \"Gregor\" );  System . out . println ( aryaList . get ( 1 ));    Line 1 above creates a empty array list.  The second line adds two strings into the list, each appending them to the list.  After executing Line 3, it would contain the sequence  <\"Cersei\",\"Joffrey\"> .  Line 4 inserts the string  \"Gregor\"  to position 0, moving the rest of the list down by 1 position.  The sequence is now  <\"Gregor\",\"Cersei\",\"Joffrey\"> .  Finally, calling  get(1)  would return the string  \"Cersei\" .  Note that we declare  names  with the interface type  List<String> .  We should always do this to keep our code flexible.  If we want to change our implementation to  LinkedList , we only need to change Line 1 to: 1 List < String >   names   =   new   LinkedList ();",
            "title": "Set and List"
        },
        {
            "location": "/lec5/index.html#comparator",
            "text": "The  List<E>  interface also specifies a  sort  method, with the following specification: 1 default   void   sort ( Comparator <?   super   E >   c )    Remember at the end of Lecture 3 when we said there are \"unpure\" interfaces, that is interface that comes with implementation?  This is one of them.  The keyword  default  indicates that the interface  List<E>  comes with a default implementation of  sort  method.  So a class that implements the interface needs not implement it again if they do not want to.  This method specification is also interesting and worth looking closer.  It takes in an object  c  with generic interface  Comparator <?   super   E > .  Like  <?   extends   E >  that we have seen before, this is a  bounded  wildcard type.  While  <?   extends   E >  is an unknown type upper bounded by  E ,  <?   super   E >  is an unknown type lower bounded by  E .  This means that we can pass in  E  or any supertype of E.  What does the  Comparator  interface do?  We can specify how to compare two elements of a given type, by implementing a  compare()  method. compare(o1,o2)  should return 0 if the two elements are equals, a negative integer if o1 is \"less than\" o2, and a positive integer otherwise.  Let's write  Comparator  class 2 :  1\n2\n3\n4\n5 class   NameComparator   implements   Comparator < String >   { \n     public   int   compare ( String   s1 ,   String   s2 )   { \n         return   s1 . compareTo ( s2 ); \n     }  }    In the above, we use the  compareTo  method provided by the  String  class to do the comparison.  With the above, we can now sort the  names :  1 names . sort ( new   NameComparator ());    This would result in the sequence being changed to  <\"Cersei\",\"Gregor\",\"Joffrey\"> .",
            "title": "Comparator"
        },
        {
            "location": "/lec5/index.html#map",
            "text": "One of the more powerful data structures provided by Java Collection is maps (also known as dictionary in other languages).  A map allows us to store a (unique key, value) pair into the collection, and retrieve the value later by looking up the key.  The  Map<K,V>  interface is again generic, but this time, has two type parameters,  K  for the type of the key, and  V  for the type of the value.  These makes the  Map  interface flexible -- we can use any type as the key and value.  The two most important methods for  Map  is  put  and  get :  1\n2      V   put ( K   key ,   V   value ); \n     V   get ( Object   k );    A useful class that implements  Map  interface is  HashMap :  1\n2\n3\n4 Map < String , Integer >   population   =   new   HashMap < String , Integer >();  population . put ( \"Oldtown\" , 500000 );  population . put ( \"Kings Landing\" , 500000 );  population . put ( \"Lannisport\" , 300000 );    Later, if we want to lookup the value, we can: 1 population . get ( \"Kings Landing\" );    Internally, to implement  put ,  HashMap  calls key's  hashCode  to return a  int , which it uses to determine which \"bucket\" to store the (key, value) pair.  When  get ,  HashMap  again calls  hashCode  on the given key to determine which bucket, then it looks for the key in the bucket.  This process, called  hashing , circumvents the need to look through every pair in the map to find the right key.  You will learn more about hashing and hash tables in CS2040.  But, what is important here is that, two keys (two objects, in general) which are the same ( equals()  returns  true ), must have the same  hashCode() .  Otherwise,  HashMap  would fail!  So it is important to ensure that if  o1.equals(o2) , then  o1.hashCode() == o2.hashCode() .  Note that the reverse does not have to be true -- two objects with the same hash code does not have to be equals.  This property is also useful for implementing  equals() .  For a complex object, comparing every field for equality can be expensive.  If we can compare the hash code first, we could filter out objects with different hash code (since they cannot be equal).  We only need to compare field by field if the hash code is the same.  Ditto for implementation of  HashSet  -- to checks if an element to add already exists,  HashSet  uses hash code, instead of going through all the elements and compare one by one.  Calculating good hash code is an involved topic, and is best left to the expert (some of you might become expert in this), but for now, we can rely on the static  hashCode  methods in the  Array  class to help us.",
            "title": "Map"
        },
        {
            "location": "/lec5/index.html#which-collection-class",
            "text": "Java provides many collection classes, more than what we have time to go through.  It is important to know which one to use to get the best performance out of them.  For the few classes we have seen:   Use  HashMap  if you want to keep a (key, value) pair for lookup later.  Use  HashSet  if you have a collection of elements with no duplicates and order is not important.  Use  ArrayList  if you have a collection of elements with possibly duplicates and order is important, and retriving a specific location is more important than removing elements from the list.  Use  LinkedList  if you have a collection of elements with possibly duplicates and order is important, retriving a specific location is less important than removing elements from the list.   You should understand the reasons above after CS2040.  Further, if you want to check if a given object is contained in the list, then  ArrayList  and  LinkedList  are not good candidates.   HashSet , on the other hand, can quickly check if an item is already contained in the set.  There is unfortunately no standard collection class that supports fast  contain  and allow duplicates.  Maybe CS2040, you can build you own collection class :)",
            "title": "Which Collection Class?"
        },
        {
            "location": "/lec5/index.html#sample-code",
            "text": "Requested by some students, I am dumping the code I used in class here.  They are badly written code (not following style guidelines, no comments, etc) edited live in class to demonstrate the concepts -- not meant to be a model of how code should be written.  Here they are:  The following code was used to demonstrate the overhead of using wrapper class unnecessary.  1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10 class   Dable   { \n   public   static   void   main ( String []   args )   { \n     // Double sum = 0.0; \n     double   sum   =   0.0 ; \n     for   ( int   i   =   0 ;   i   <   Integer . MAX_VALUE ;   i ++) \n     { \n           sum   +=   i ; \n     } \n   }  }    The following code was used to demonstrate sorting of an  ArrayList .  1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34 import   java.util.* ;  class   NameComparator   implements   Comparator < String >   { \n   public   int   compare ( String   s1 ,   String   s2 )   { \n     // return (s1.compareTo(s2)); \n     // return (s2.compareTo(s1)); \n     return   ( s2 . length ()   -   s1 . length ()); \n   }  }  class   SortedList   { \n   public   static   void   main ( String []   args )   { \n     List < String >   names   =   new   ArrayList < String >(); \n\n     names . add ( 0 ,   \"Joffrey\" ); \n     names . add ( 1 ,   \"Cersei\" ); \n     names . add ( 2 ,   \"Meryn\" ); \n     names . add ( 3 ,   \"Walder\" ); \n     names . add ( 4 ,   \"Gregor\" ); \n     names . add ( 5 ,   \"Sandor\" ); \n\n     System . out . println ( \"Initial List\" ); \n     for   ( String   i :   names )   { \n       System . out . println ( i ); \n     } \n\n     names . sort ( new   NameComparator ()); \n\n     System . out . println ( \"Sorted List\" ); \n     for   ( String   i :   names )   { \n       System . out . println ( i ); \n     } \n   }  }    The following was used to demonstrate  HashMap .  1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11 import   java.util.* ;  class   Population   { \n   public   static   void   main ( String []   args )   { \n     Map < String , Integer >   population   =   new   HashMap < String , Integer >(); \n     population . put ( \"Oldtown\" , 500000 ); \n     population . put ( \"Kings Landing\" , 500000 ); \n     population . put ( \"Lannisport\" , 300000 ); \n     System . out . println ( population . get ( \"Lannisport\" )); \n   }  }        If you want to do so, however, it is likely more useful to inherit from the abstract class  AbstractCollection<E>  (which implements most of the basic methods of the interface) rather than implementing the interface  Collection<E>  directly.\u00a0 \u21a9    Later in CS2030, you will see how we significantly reduce the verbosity of this code!  But let's do it the hard way first.\u00a0 \u21a9",
            "title": "Sample Code"
        },
        {
            "location": "/exercise1/index.html",
            "text": "Exercise 1\n\n\nThis is an ungraded, optional exercise.\n\n\nIn the example from Lecture 1, we implemented a class \nCircle\n.  There, we store and pass around two \ndouble\n variables that corresponds to the x-coordinate and y-coordinate of a point.  The code would be neater if we create a second class \nPoint\n that encapsulates the concept of a point on 2D plane and the operations on points.\n\n\nImplement a new class \nPoint\n and modify the class \nCircle\n to use the class \nPoint\n.  Pay attention to what methods and fields (if any) you expose as \npublic\n outside of the abstraction barrier of a \nPoint\n object.\n\n\nYou will need to use \njshell\n from Java 1.9 (or JDK 9) to interact with your new classes.",
            "title": "1. Circles & Points"
        },
        {
            "location": "/exercise1/index.html#exercise-1",
            "text": "This is an ungraded, optional exercise.  In the example from Lecture 1, we implemented a class  Circle .  There, we store and pass around two  double  variables that corresponds to the x-coordinate and y-coordinate of a point.  The code would be neater if we create a second class  Point  that encapsulates the concept of a point on 2D plane and the operations on points.  Implement a new class  Point  and modify the class  Circle  to use the class  Point .  Pay attention to what methods and fields (if any) you expose as  public  outside of the abstraction barrier of a  Point  object.  You will need to use  jshell  from Java 1.9 (or JDK 9) to interact with your new classes.",
            "title": "Exercise 1"
        },
        {
            "location": "/exercise2/index.html",
            "text": "Exercise 2\n\n\nThis is an ungraded, optional exercise.\n\n\nIn the example from Lecture 2, we implemented a class \nCircle\n that implements two interfaces \nGeometricShape\n and \nPrintable\n.  For this exercise,\n\n\n\n\n\n\nImplement another class \nSquare\n that implements the two interfaces.  You may have to extend the class \nPoint\n you wrote for Exercise 1 to implement the methods in Square.\n\n\n\n\n\n\nImplement another class \nPaintedSquare\n that implements the two interfaces and inherits from \nPaintedShape\n.\n\n\n\n\n\n\nImplement the methods \nequals()\n in \nSquare\n, overriding the two methods in the \nObject\n class, so that \nequals()\n semantically compare two \nSquare\n objects.",
            "title": "2. Square & PaintedSquare"
        },
        {
            "location": "/exercise2/index.html#exercise-2",
            "text": "This is an ungraded, optional exercise.  In the example from Lecture 2, we implemented a class  Circle  that implements two interfaces  GeometricShape  and  Printable .  For this exercise,    Implement another class  Square  that implements the two interfaces.  You may have to extend the class  Point  you wrote for Exercise 1 to implement the methods in Square.    Implement another class  PaintedSquare  that implements the two interfaces and inherits from  PaintedShape .    Implement the methods  equals()  in  Square , overriding the two methods in the  Object  class, so that  equals()  semantically compare two  Square  objects.",
            "title": "Exercise 2"
        },
        {
            "location": "/exercise3/index.html",
            "text": "Exercise 3\n\n\nThis is an ungraded, optional exercise.\n\n\nIn Exercise 2, you used inheritance to implement \nPaintedSquare\n.   Redo this implementation using composition instead of inheritance.\n\n\n.\n\n\n.\n\n\n.\n\n\n.\n\n\n.\n\n\n.",
            "title": "3. PaintedSquare Revisited"
        },
        {
            "location": "/exercise3/index.html#exercise-3",
            "text": "This is an ungraded, optional exercise.  In Exercise 2, you used inheritance to implement  PaintedSquare .   Redo this implementation using composition instead of inheritance.  .  .  .  .  .  .",
            "title": "Exercise 3"
        },
        {
            "location": "/exercise4/index.html",
            "text": "Exercise 4\n\n\nIn your lab 1, we assume that the input file is always in the correct format.\n\n\nNow, change \nMaxDiscCover\n so that the \nreadPoints()\n method no longer assume this.  You should use exceptions to handles the possible errors when reading the points from \nSystem.in\n.",
            "title": "4. Exceptions"
        },
        {
            "location": "/exercise4/index.html#exercise-4",
            "text": "In your lab 1, we assume that the input file is always in the correct format.  Now, change  MaxDiscCover  so that the  readPoints()  method no longer assume this.  You should use exceptions to handles the possible errors when reading the points from  System.in .",
            "title": "Exercise 4"
        },
        {
            "location": "/lab1/index.html",
            "text": "Lab 1\n\n\nThis is a warm up, ungraded, lab.  \n\n\nSubmission deadline: 2359, Sunday, September 3, 2017.\n\n\nLearning Objectives\n\n\nAfter completing this lab, students should:\n\n\n\n\nbe more comfortable with the CS2030 laboratory environment, including knowing how to remotely access \ncs2030-i\n, create directory, copy files, edit files, transfer files between \ncs2030-i\n and local computers, run a script, and other \nUNIX commands\n\n\nbe familiar with compiling and running Java programs from the command line\n\n\nbe familiar with the concept of standard input and standard output, how to redirect the content of a file to standard input, and how to print to standard output\n\n\nbe more comfortable with basic Java syntax and semantics, specifically with\n\n\nadding methods into existing classes\n\n\ninvoking the methods of the classes to solve problems\n\n\ndeclaring and using arrays, primitive types, and objects\n\n\nusing if/else and for statements\n\n\nprinting to standard output\n\n\nthe \nthis\n keyword\n\n\n\n\n\n\n\n\n\n\nexperience reading Java API documentation and find out what are the methods available, and what are the arguments and returned types.\n\n\nsee an example of how class \nScanner\n is used\n\n\nappreciate how encapsulation of class \nPoint\n and class \nCircle\n allows one to reason about higher-level tasks without worrying about lower level representation\n\n\nappreciate how encapsulation of the class \nPoints\n allow one to change the internal representation without affecting how the class \nPoint\n is used.\n\n\n\n\nSetup\n\n\nLogin to \ncs2030-i\n, copy the files from \n~cs2030/lab01\n to your local directory under your home \n~/lab01\n.  You should see three java files (\nPoint.java\n, \nCircle.java\n, and \nMaxDiscCover.java\n), and a few data files (\nTESTDATA1.txt\n, \nTESTDATA2.txt\n, ..., \nTESTDATA5.txt\n)\n\n\nRead through the files above.  Although we have seen \nCircles\n and \nPoints\n as examples in class, these classes are slightly different.\n\n\n1. Augment the class Point\n\n\nAugment the class \nPoint\n with the following public methods and constructors.\nYou may find the static methods provided by \njava.lang.Math\n useful.\n\n\n1.1. Constructor for midpoint\n\n\n1\npublic\n \nPoint\n(\nPoint\n \np\n,\n \nPoint\n \nq\n)\n\n\n\n\n\n\n\nGiven two points \np\n and \nq\n, create and return the midpoint of \np\n and \nq\n.\n\n\n1.2 Distance between points\n\n\n1\npublic\n \ndouble\n \ndistanceTo\n(\nPoint\n \nq\n)\n \n\n\n\n\n\n\nYou should have written something like this from your Exercise 1.  This method returns the Euclidean distance of \nthis\n point to the point \nq\n.\n\n\n1.3 Angle between points\n\n\n1\npublic\n \ndouble\n \nangleTo\n(\nPoint\n \nq\n)\n \n\n\n\n\n\n\nThis method returns the angle between the current point and point \nq\n.  In the figure below, it returns the angle \n\\(\\theta\\)\n.  You can compute this using the \natan2()\n function.  For instance, \n\n1\n2\nPoint\n \np\n \n=\n \nnew\n \nPoint\n(\n0\n,\n \n0\n);\n\n\np\n.\nangleTo\n(\nnew\n \nPoint\n(\n1\n,\n \n1\n));\n\n\n\n\n\nshould return\n\n1\n0.7853981633974483\n\n\n\n\nwhich is \n\\(\\pi/4\\)\n.\n\n1\np.angleTo(new Point(1, 0));\n\n\n\n\nshould return \n\n1\n0.0\n\n\n\n\n\n\n\n1.4. Move a point\n\n\n1\npublic\n \nvoid\n \nmove\n(\ndouble\n \ntheta\n,\n \ndouble\n \nd\n)\n\n\n\n\n\n\n\nMove the point by a given distance at direction theta (in radian).  See Figure:\n\n\n\n\nThe new point should have the coordinate (\n\\(x + d\\cos\\theta, y + d\\sin\\theta\\)\n).\n\n\nAfter\n\n1\np.move(p.angleTo(q), p.distanceTo(q));\n\n\n\n\n\np\n should coincide with \nq\n.\n\n\n2. Augment the class Circle\n\n\nAugment the class \nCircle\n with the following methods and constructors:\n\n\n2.1 Constructor\n\n\n1\npublic\n \nCircle\n(\nPoint\n \np\n,\n \nPoint\n \nq\n,\n \ndouble\n \nradius\n,\n \nboolean\n \ncenterOnLeft\n)\n\n\n\n\n\n\n\nThe constructor above takes in two points \np\n and \nq\n, and returns a circle  that passes through both \np\n and \nq\n, with radius \nradius\n.  \n\n\nThere are two such possible circles (see figures below) if distance between \np\n and \nq\n is no greater than 2x\nradius\n1\n.  Imagine if you walk from \np\n to \nq\n, one of the circle will have the center on your left, the other will have the center on your right.  If the parameter \ncenterOnLeft\n is \ntrue\n, then the constructor will return the circle on the left, otherwise it will return the circle on the right.  See figure below.\n\n\n\n\nHint: To find the center \n\\(c\\)\n of the new circle, you can first find the midpoint \n\\(m\\)\n of line \n\\(pq\\)\n, the length of line \n\\(mc\\)\n, and the angle between \n\\(m\\)\n and \n\\(c\\)\n, using the \nPoint\n methods you have written.  We also know that length of \n\\(cq\\)\n is \nradius\n.  See figure below.\n\n\n\n\nThe constructor should return a \nCircle\n with \nDouble.NaN\n as the radius and (0,0) as center if the distance between \np\n and \nq\n is larger than 2x\nradius\n or is zero\n2\n.  Such \nCircle\n objects are invalid, and you may want to add a method in the \nCircle\n class to check for validity.  You can use \nDouble.isNaN\n for check if a double variable is NaN.\n\n\n3. Maximum Disc Coverage\n\n\nWe are now going to use the \nCircle\n class and \nPoint\n class to solve the maximum disc coverage problem.  In this problem, we are given a set of points on a 2D plane, and a unit disc (i.e., a circle of radius 1).  We want to place the disc so that it covers as many points as possible.  What is the maximum number of points that we can cover with the disc at any one time?   \n\n\nWe will use the following simple (non-optimal)  algorithm\n3\n.  First, some observations:\n\n\n\n\nA disc that covers the maximum number of points must pass through at least two points.\n\n\nFor every pair of points that is of no more than distance 2 away from each other, there is at most two unit discs that have their perimeter passing through the two points (you have written a constructor that helps you to find such circles).\n\n\n\n\nSo, the algorithm simply goes through every pair of points, and for each circle that passes through them, count how many points are covered by each circle.\n\n\nThe skeleton of the main class, called \nMaxDiscCover.java\n has been given to you.  This file is placed in the same directory as \nCircle.java\n and \nPoint.java\n.  \n\n\nThe skeleton code reads a set of points from the standard input, in the following format:\n\n\n\n\nThe first line is an integer, indicating the number of points \n\\(n\\)\n (\n\\(n\\)\n > 2) in the file.\n\n\nThe next \n\\(n\\)\n lines contains the \n\\(x\\)\n and \n\\(y\\)\n coordinates of \n\\(n\\)\n points, one point per line.  Each line has two doubles, separated by space.  The first double is the \n\\(x\\)\n coordinate; the second double is the \n\\(y\\)\n coordinate.\n\n\n\n\nYou can assume that the format of the input is always correct and there is always at least two points with distance less than 2 between them.\n\n\nComplete the program by implementing the maximum disc coverage algorithm above, and print the maximum number of points covered to standard output.  You can add additional methods and fields for \nPoint\n and \nCircle\n if needed.\n\n\n1\n2\nooiwt@cs2030-i:~/lab01[xxx]$ java MaxDiscCover < TESTDATA1.txt\n4\n\n\n\n\n(The output \n4\n above is a sample only -- it might not be the correct answer)\n\n\n4. What If\n\n\nSuppose now, hypothetically, we replace Point's implementation with one that represents a point with polar coordinates internally, but has exactly the same public methods and constructors.  How many lines of code in \nMaxDiscCover.java\n and \nCircle.java\n do you need to change?\n\n\nSubmission\n\n\nWhen you are ready to submit your lab, on \ncs2030-i\n, run the script\n\n1\n~cs2030/submit01\n\n\n\n\n\nwhich will copy your the three java files \nMaxDiscCover.java\n, \nPoint.java\n, and \nCircle.java\n (and nothing else) from your \n~/lab01\n directory on \ncs2030-i\n to an internal grading directory.\n\n\nYou can submit multiple times, but only the most recent submission will be graded.\n\n\n\n\n\n\n\n\n\n\nIf the distance between \np\n and \nq\n is exactly 2x\nradius\n, then the two circles are one and the same.\u00a0\n\u21a9\n\n\n\n\n\n\nA cleaner solution is to throw an exception, but you won't learn this until later in class.\u00a0\n\u21a9\n\n\n\n\n\n\nThis is a \n\\(O(n^3)\\)\n algorithm.  Faster algorithm exists.\u00a0\n\u21a9",
            "title": "1. Question"
        },
        {
            "location": "/lab1/index.html#lab-1",
            "text": "This is a warm up, ungraded, lab.    Submission deadline: 2359, Sunday, September 3, 2017.",
            "title": "Lab 1"
        },
        {
            "location": "/lab1/index.html#learning-objectives",
            "text": "After completing this lab, students should:   be more comfortable with the CS2030 laboratory environment, including knowing how to remotely access  cs2030-i , create directory, copy files, edit files, transfer files between  cs2030-i  and local computers, run a script, and other  UNIX commands  be familiar with compiling and running Java programs from the command line  be familiar with the concept of standard input and standard output, how to redirect the content of a file to standard input, and how to print to standard output  be more comfortable with basic Java syntax and semantics, specifically with  adding methods into existing classes  invoking the methods of the classes to solve problems  declaring and using arrays, primitive types, and objects  using if/else and for statements  printing to standard output  the  this  keyword      experience reading Java API documentation and find out what are the methods available, and what are the arguments and returned types.  see an example of how class  Scanner  is used  appreciate how encapsulation of class  Point  and class  Circle  allows one to reason about higher-level tasks without worrying about lower level representation  appreciate how encapsulation of the class  Points  allow one to change the internal representation without affecting how the class  Point  is used.",
            "title": "Learning Objectives"
        },
        {
            "location": "/lab1/index.html#setup",
            "text": "Login to  cs2030-i , copy the files from  ~cs2030/lab01  to your local directory under your home  ~/lab01 .  You should see three java files ( Point.java ,  Circle.java , and  MaxDiscCover.java ), and a few data files ( TESTDATA1.txt ,  TESTDATA2.txt , ...,  TESTDATA5.txt )  Read through the files above.  Although we have seen  Circles  and  Points  as examples in class, these classes are slightly different.",
            "title": "Setup"
        },
        {
            "location": "/lab1/index.html#1-augment-the-class-point",
            "text": "Augment the class  Point  with the following public methods and constructors.\nYou may find the static methods provided by  java.lang.Math  useful.",
            "title": "1. Augment the class Point"
        },
        {
            "location": "/lab1/index.html#11-constructor-for-midpoint",
            "text": "1 public   Point ( Point   p ,   Point   q )    Given two points  p  and  q , create and return the midpoint of  p  and  q .",
            "title": "1.1. Constructor for midpoint"
        },
        {
            "location": "/lab1/index.html#12-distance-between-points",
            "text": "1 public   double   distanceTo ( Point   q )     You should have written something like this from your Exercise 1.  This method returns the Euclidean distance of  this  point to the point  q .",
            "title": "1.2 Distance between points"
        },
        {
            "location": "/lab1/index.html#13-angle-between-points",
            "text": "1 public   double   angleTo ( Point   q )     This method returns the angle between the current point and point  q .  In the figure below, it returns the angle  \\(\\theta\\) .  You can compute this using the  atan2()  function.  For instance,  1\n2 Point   p   =   new   Point ( 0 ,   0 );  p . angleTo ( new   Point ( 1 ,   1 ));   \nshould return 1 0.7853981633974483  \nwhich is  \\(\\pi/4\\) . 1 p.angleTo(new Point(1, 0));  \nshould return  1 0.0",
            "title": "1.3 Angle between points"
        },
        {
            "location": "/lab1/index.html#14-move-a-point",
            "text": "1 public   void   move ( double   theta ,   double   d )    Move the point by a given distance at direction theta (in radian).  See Figure:   The new point should have the coordinate ( \\(x + d\\cos\\theta, y + d\\sin\\theta\\) ).  After 1 p.move(p.angleTo(q), p.distanceTo(q));   p  should coincide with  q .",
            "title": "1.4. Move a point"
        },
        {
            "location": "/lab1/index.html#2-augment-the-class-circle",
            "text": "Augment the class  Circle  with the following methods and constructors:",
            "title": "2. Augment the class Circle"
        },
        {
            "location": "/lab1/index.html#21-constructor",
            "text": "1 public   Circle ( Point   p ,   Point   q ,   double   radius ,   boolean   centerOnLeft )    The constructor above takes in two points  p  and  q , and returns a circle  that passes through both  p  and  q , with radius  radius .    There are two such possible circles (see figures below) if distance between  p  and  q  is no greater than 2x radius 1 .  Imagine if you walk from  p  to  q , one of the circle will have the center on your left, the other will have the center on your right.  If the parameter  centerOnLeft  is  true , then the constructor will return the circle on the left, otherwise it will return the circle on the right.  See figure below.   Hint: To find the center  \\(c\\)  of the new circle, you can first find the midpoint  \\(m\\)  of line  \\(pq\\) , the length of line  \\(mc\\) , and the angle between  \\(m\\)  and  \\(c\\) , using the  Point  methods you have written.  We also know that length of  \\(cq\\)  is  radius .  See figure below.   The constructor should return a  Circle  with  Double.NaN  as the radius and (0,0) as center if the distance between  p  and  q  is larger than 2x radius  or is zero 2 .  Such  Circle  objects are invalid, and you may want to add a method in the  Circle  class to check for validity.  You can use  Double.isNaN  for check if a double variable is NaN.",
            "title": "2.1 Constructor"
        },
        {
            "location": "/lab1/index.html#3-maximum-disc-coverage",
            "text": "We are now going to use the  Circle  class and  Point  class to solve the maximum disc coverage problem.  In this problem, we are given a set of points on a 2D plane, and a unit disc (i.e., a circle of radius 1).  We want to place the disc so that it covers as many points as possible.  What is the maximum number of points that we can cover with the disc at any one time?     We will use the following simple (non-optimal)  algorithm 3 .  First, some observations:   A disc that covers the maximum number of points must pass through at least two points.  For every pair of points that is of no more than distance 2 away from each other, there is at most two unit discs that have their perimeter passing through the two points (you have written a constructor that helps you to find such circles).   So, the algorithm simply goes through every pair of points, and for each circle that passes through them, count how many points are covered by each circle.  The skeleton of the main class, called  MaxDiscCover.java  has been given to you.  This file is placed in the same directory as  Circle.java  and  Point.java .    The skeleton code reads a set of points from the standard input, in the following format:   The first line is an integer, indicating the number of points  \\(n\\)  ( \\(n\\)  > 2) in the file.  The next  \\(n\\)  lines contains the  \\(x\\)  and  \\(y\\)  coordinates of  \\(n\\)  points, one point per line.  Each line has two doubles, separated by space.  The first double is the  \\(x\\)  coordinate; the second double is the  \\(y\\)  coordinate.   You can assume that the format of the input is always correct and there is always at least two points with distance less than 2 between them.  Complete the program by implementing the maximum disc coverage algorithm above, and print the maximum number of points covered to standard output.  You can add additional methods and fields for  Point  and  Circle  if needed.  1\n2 ooiwt@cs2030-i:~/lab01[xxx]$ java MaxDiscCover < TESTDATA1.txt\n4  \n(The output  4  above is a sample only -- it might not be the correct answer)",
            "title": "3. Maximum Disc Coverage"
        },
        {
            "location": "/lab1/index.html#4-what-if",
            "text": "Suppose now, hypothetically, we replace Point's implementation with one that represents a point with polar coordinates internally, but has exactly the same public methods and constructors.  How many lines of code in  MaxDiscCover.java  and  Circle.java  do you need to change?",
            "title": "4. What If"
        },
        {
            "location": "/lab1/index.html#submission",
            "text": "When you are ready to submit your lab, on  cs2030-i , run the script 1 ~cs2030/submit01   which will copy your the three java files  MaxDiscCover.java ,  Point.java , and  Circle.java  (and nothing else) from your  ~/lab01  directory on  cs2030-i  to an internal grading directory.  You can submit multiple times, but only the most recent submission will be graded.      If the distance between  p  and  q  is exactly 2x radius , then the two circles are one and the same.\u00a0 \u21a9    A cleaner solution is to throw an exception, but you won't learn this until later in class.\u00a0 \u21a9    This is a  \\(O(n^3)\\)  algorithm.  Faster algorithm exists.\u00a0 \u21a9",
            "title": "Submission"
        },
        {
            "location": "/lab01-comments/index.html",
            "text": "Lab 1: Comments\n\n\nHere are some common mistakes made, in decreasing order of seriousness.\n\n\nMost Serious Offences\n\n\nDesign: Breaking abstraction barrier\n\n\nSome students took the liberty to change the access modifier of instance fields from \nprivate\n to \npublic\n.\n\n\nIn doing so, you are violating the fundamental principles of object oriented programming and demonstrating that you do not understand the concept and importance of abstraction barriers and encapsulation.\n\n\nDesign: Getter / Setter\n\n\nIf you use getter or setter in your code when you could have easily move the associated tasks to within the encapsulation, you score a major minus in your lab.  Again, using getter and setter to expose the internals is only slightly better than just changing the members to \npublic\n.\n\n\nThere are cases where the use of getters and setters are justified.  For instance, a couple of you use complex equations to determine the center and it involves x and y, instead of using \nmove\n, \nangleTo\n, and \ndistanceTo\n.  One could argue that these solutions heavily rely on the knowledge of x and y.\n\n\nFor all other uses of x and y in the \nCircle\n constructor, such as to calculate gradient, to copy a point, etc, they can all be delegated to the \nPoint\n class.  Remember, we want the \nPoint\n class to be the only one who knows the internal representation of a point: whether Euclidean coords or polar coords are used.\n\n\nE.g.,\n\n1\nPoint\n \np\n \n=\n \nnew\n \nPoint\n(\nq\n.\ngetX\n(),\n \nq\n.\ngetY\n());\n\n\n\n\n\ncan be\n\n1\nPoint\n \np\n \n=\n \nq\n.\ncopy\n();\n\n\n\n\n\nor\n\n1\ndouble\n \ngradient\n \n=\n \n(\np\n.\ngetY\n()-\nq\n.\ngetY\n())/(\np\n.\ngetX\n()-\nq\n.\ngetX\n())\n\n\n\n\n\ncan be\n\n1\ndouble\n \ngradient\n \n=\n \np\n.\ngradientTo\n(\nq\n);\n\n\n\n\n\n\nDesign: Checking for Circle validity\n\n\nAlong the same line of mistakes, some of you do this in \nMaxDiscCover.java\n:\n\n\n1\n    \nif\n \n(\nDouble\n.\nisNaN\n(\ncircle\n.\ngetRadius\n())\n \n{\n \n..\n \n}\n\n\n\n\n\nor\n\n1\n    \nif\n \n(\ncircle\n.\nradiusIsNaN\n())\n \n{\n \n..\n \n}\n\n\n\n\n\n\nSuppose now we change an invalid circle to one that has \n-1\n radius, or one that has a boolean \nisValid\n flag, then this code wouldn't work or has to be renamed.\n\n\nA better way is for \nCircle\n to decide itself whether it is valid or not, by providing a method \nisValid()\n.  Then, \nMaxDiscCover.java\n can just call\n\n1\n    \nif\n \n(\ncircle\n.\nisValid\n())\n \n{\n \n..\n \n}\n\n\n\n\n\nIf Circle decides to change its implementation later, it is none of \nMaxDiscCover\n's business.\n\n\nCorrectness: Object References\n\n\nA few students did the following in \nCircle\n constructor:\n\n\n1\n2\n3\n4\n5\n6\npublic\n \nCircle\n(\nPoint\n \np\n,\n \nPoint\n \nq\n,\n \ndouble\n \nr\n,\n \nboolean\n \ncenterOnLeft\n)\n \n{\n\n    \nPoint\n \nm\n \n=\n \np\n;\n\n    \n:\n\n    \nm\n.\nmove\n(..)\n\n    \n:\n\n\n}\n\n\n\n\n\n\n\nRemember from the figures drawn in class that \nm\n and \np\n are just references to objects.  Now, you are pointing \nm\n and \np\n to the same object.  When you move \nm\n, \np\n is moved as well, and as a result, one input point from the \npoints[]\n array gets moved.\n\n\nPerformance: Double Loops\n\n\nSome of you did this in \nsolve()\n:\n\n\n1\n2\n3\n4\n5\nfor\n \n(\nPoint\n \np\n:\n \npoints\n)\n \n{\n\n    \nfor\n \n(\nPoint\n \nq\n:\n \npoints\n)\n \n{\n\n        \n:\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nWhat happened is that, now, you loop through each pair of points twice, (first with, say, \np\n as \npoints[0]\n, \nq\n as \npoints[1]\n, and later \np\n as \npoints[1]\n, \nq\n as \npoints[0]\n).\n\n\nThis also meant that for each point, you tried to construct a circle through two copies of itself, a wasted effort since the resulting circle is invalid.\n\n\nHere's a better way to iterate through all possible pairs of points:\n\n\n1\n2\n3\n4\n5\n6\n7\nfor\n \n(\nint\n \ni\n \n=\n \n0\n;\n \ni\n \n<\n \npoints\n.\nlength\n;\n \ni\n++)\n \n{\n\n    \nfor\n \n(\nint\n \nj\n \n=\n \ni\n \n+\n \n1\n;\n \nj\n \n<\n \npoints\n.\nlength\n;\n \nj\n++)\n \n{\n\n        \nPoint\n \np\n \n=\n \npoints\n[\ni\n];\n\n        \nPoint\n \nq\n \n=\n \npoints\n[\nj\n];\n\n        \n:\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nStyle: Indentation\n\n\nIt is important to keep your code properly and consistently indented.  If you use a source code editor like \nvim\n (with \nautoindent\n on and \nsmartindent\n on), then there is no reason for you to have crooked indentation.\n\n\nMy favourite example of bad indentation bug: \nApple \ngoto fail\n bug\n\n\nStyle: Naming Convention\n\n\nJava has a certain naming convention for class names, variable names, method names, constant variables, etc.  Please follow them.  At the beginning of the lab, we ask all of those who attended to follow, but there are still some who does not.\n\n\nFrom Lab 3 onwards, we will enforce indentation and naming style.\n\n\nLess Serious Mistakes\n\n\nStyle: \nthis\n\n\nWhen referring to the fields of the current object, I prefer to use \nthis\n reference.  It is redundant, but makes your program much less bug prone and make it more explicit which variable you are referring to.\n\n\nLet's suppose I give you a method of about 100 lines and 10 parameters and variables to read, one of the lines said:\n\n\n1\n    \ncenter\n \n=\n \np\n;\n\n\n\n\n\n\n\nHow can you be absolutely sure that this line is updating a member called \ncenter\n of the object?\n\n\nTo be sure, you have to scan through 100 lines to double check that there is no local variable declared with the same name, and there is no method argument with the same name.\n\n\nNow, let's suppose I give you a method of about 100 lines and 10 parameters and variables to read, one of the lines said:\n\n\n1\n    \nthis\n.\ncenter\n \n=\n \np\n;\n\n\n\n\n\n\n\nHow can you be absolutely sure that this line is updating a member called \ncenter\n of the object?\n\n\nI rest my case :)\n\n\nStyle: Too Many Nested Blocks\n\n\nIn the \nsolve\n method, some of you have FIVE levels of nested blocks: two double loops to go through each pair of points, one to check for circle validity, another loop to go through all points, one to check for containment.\n\n\nThese nested blocks make the code long and hard to read.  One of you have to label the \n{\n and \n}\n to help with bracket matching.\n\n\nAs a guideline, if you have more than two nested blocks, it is time to think about breaking down the method into smaller / shorter methods.  For instance, for every pair of points, find out how many points are in the two circles that pass throught this pair.\n\n\nShorter methods are easier to read, understand, and debug.  So do your future self a favour.\n\n\nStyle: \nif (x == true)\n\n\nx\n can be a variable or a function. Some of you wrote as \nif (x == true)\n in the condition, some wrote it as \nif (x)\n.\n\n\nif (x)\n is more succinct, and if you name \nx\n properly, it is more readable and understandable than \nif (x == true)\n.\n\n\nFor instance,\n\n\n1\nif\n \n(\ncircle\n.\nisValid\n())\n \n{..}\n\n\n\n\n\n\n\nis perfectly clear that we are checking if the circle is valid.\n\n\n1\nif\n \n(\ncircle\n.\nisValid\n()\n \n==\n \ntrue\n))\n \n{..}\n\n\n\n\n\nis redundant.\n\n\nWhat if we call the function \nx\n as something else, say, \ncheckValidity()\n?  First of all, DON'T.  Second, yes, it is then OK to write:\n\n\n1\nif\n \n(\ncircle\n.\ncheckValidity\n()\n \n==\n \ntrue\n))\n \n{..}\n\n\n\n\n\nbut can you tell by reading this line of code, whether \ntrue\n means the circle is valid or not?  So, DON'T.  Keep your code short, english-like, and choose a proper name for your variables and methods.",
            "title": "1. Comments"
        },
        {
            "location": "/lab01-comments/index.html#lab-1-comments",
            "text": "Here are some common mistakes made, in decreasing order of seriousness.",
            "title": "Lab 1: Comments"
        },
        {
            "location": "/lab01-comments/index.html#most-serious-offences",
            "text": "",
            "title": "Most Serious Offences"
        },
        {
            "location": "/lab01-comments/index.html#design-breaking-abstraction-barrier",
            "text": "Some students took the liberty to change the access modifier of instance fields from  private  to  public .  In doing so, you are violating the fundamental principles of object oriented programming and demonstrating that you do not understand the concept and importance of abstraction barriers and encapsulation.",
            "title": "Design: Breaking abstraction barrier"
        },
        {
            "location": "/lab01-comments/index.html#design-getter-setter",
            "text": "If you use getter or setter in your code when you could have easily move the associated tasks to within the encapsulation, you score a major minus in your lab.  Again, using getter and setter to expose the internals is only slightly better than just changing the members to  public .  There are cases where the use of getters and setters are justified.  For instance, a couple of you use complex equations to determine the center and it involves x and y, instead of using  move ,  angleTo , and  distanceTo .  One could argue that these solutions heavily rely on the knowledge of x and y.  For all other uses of x and y in the  Circle  constructor, such as to calculate gradient, to copy a point, etc, they can all be delegated to the  Point  class.  Remember, we want the  Point  class to be the only one who knows the internal representation of a point: whether Euclidean coords or polar coords are used.  E.g., 1 Point   p   =   new   Point ( q . getX (),   q . getY ());   \ncan be 1 Point   p   =   q . copy ();   \nor 1 double   gradient   =   ( p . getY ()- q . getY ())/( p . getX ()- q . getX ())   \ncan be 1 double   gradient   =   p . gradientTo ( q );",
            "title": "Design: Getter / Setter"
        },
        {
            "location": "/lab01-comments/index.html#design-checking-for-circle-validity",
            "text": "Along the same line of mistakes, some of you do this in  MaxDiscCover.java :  1      if   ( Double . isNaN ( circle . getRadius ())   {   ..   }   \nor 1      if   ( circle . radiusIsNaN ())   {   ..   }    Suppose now we change an invalid circle to one that has  -1  radius, or one that has a boolean  isValid  flag, then this code wouldn't work or has to be renamed.  A better way is for  Circle  to decide itself whether it is valid or not, by providing a method  isValid() .  Then,  MaxDiscCover.java  can just call 1      if   ( circle . isValid ())   {   ..   }   \nIf Circle decides to change its implementation later, it is none of  MaxDiscCover 's business.",
            "title": "Design: Checking for Circle validity"
        },
        {
            "location": "/lab01-comments/index.html#correctness-object-references",
            "text": "A few students did the following in  Circle  constructor:  1\n2\n3\n4\n5\n6 public   Circle ( Point   p ,   Point   q ,   double   r ,   boolean   centerOnLeft )   { \n     Point   m   =   p ; \n     : \n     m . move (..) \n     :  }    Remember from the figures drawn in class that  m  and  p  are just references to objects.  Now, you are pointing  m  and  p  to the same object.  When you move  m ,  p  is moved as well, and as a result, one input point from the  points[]  array gets moved.",
            "title": "Correctness: Object References"
        },
        {
            "location": "/lab01-comments/index.html#performance-double-loops",
            "text": "Some of you did this in  solve() :  1\n2\n3\n4\n5 for   ( Point   p :   points )   { \n     for   ( Point   q :   points )   { \n         : \n     }  }    What happened is that, now, you loop through each pair of points twice, (first with, say,  p  as  points[0] ,  q  as  points[1] , and later  p  as  points[1] ,  q  as  points[0] ).  This also meant that for each point, you tried to construct a circle through two copies of itself, a wasted effort since the resulting circle is invalid.  Here's a better way to iterate through all possible pairs of points:  1\n2\n3\n4\n5\n6\n7 for   ( int   i   =   0 ;   i   <   points . length ;   i ++)   { \n     for   ( int   j   =   i   +   1 ;   j   <   points . length ;   j ++)   { \n         Point   p   =   points [ i ]; \n         Point   q   =   points [ j ]; \n         : \n     }  }",
            "title": "Performance: Double Loops"
        },
        {
            "location": "/lab01-comments/index.html#style-indentation",
            "text": "It is important to keep your code properly and consistently indented.  If you use a source code editor like  vim  (with  autoindent  on and  smartindent  on), then there is no reason for you to have crooked indentation.  My favourite example of bad indentation bug:  Apple  goto fail  bug",
            "title": "Style: Indentation"
        },
        {
            "location": "/lab01-comments/index.html#style-naming-convention",
            "text": "Java has a certain naming convention for class names, variable names, method names, constant variables, etc.  Please follow them.  At the beginning of the lab, we ask all of those who attended to follow, but there are still some who does not.  From Lab 3 onwards, we will enforce indentation and naming style.",
            "title": "Style: Naming Convention"
        },
        {
            "location": "/lab01-comments/index.html#less-serious-mistakes",
            "text": "",
            "title": "Less Serious Mistakes"
        },
        {
            "location": "/lab01-comments/index.html#style-this",
            "text": "When referring to the fields of the current object, I prefer to use  this  reference.  It is redundant, but makes your program much less bug prone and make it more explicit which variable you are referring to.  Let's suppose I give you a method of about 100 lines and 10 parameters and variables to read, one of the lines said:  1      center   =   p ;    How can you be absolutely sure that this line is updating a member called  center  of the object?  To be sure, you have to scan through 100 lines to double check that there is no local variable declared with the same name, and there is no method argument with the same name.  Now, let's suppose I give you a method of about 100 lines and 10 parameters and variables to read, one of the lines said:  1      this . center   =   p ;    How can you be absolutely sure that this line is updating a member called  center  of the object?  I rest my case :)",
            "title": "Style: this"
        },
        {
            "location": "/lab01-comments/index.html#style-too-many-nested-blocks",
            "text": "In the  solve  method, some of you have FIVE levels of nested blocks: two double loops to go through each pair of points, one to check for circle validity, another loop to go through all points, one to check for containment.  These nested blocks make the code long and hard to read.  One of you have to label the  {  and  }  to help with bracket matching.  As a guideline, if you have more than two nested blocks, it is time to think about breaking down the method into smaller / shorter methods.  For instance, for every pair of points, find out how many points are in the two circles that pass throught this pair.  Shorter methods are easier to read, understand, and debug.  So do your future self a favour.",
            "title": "Style: Too Many Nested Blocks"
        },
        {
            "location": "/lab01-comments/index.html#style-if-x-true",
            "text": "x  can be a variable or a function. Some of you wrote as  if (x == true)  in the condition, some wrote it as  if (x) .  if (x)  is more succinct, and if you name  x  properly, it is more readable and understandable than  if (x == true) .  For instance,  1 if   ( circle . isValid ())   {..}    is perfectly clear that we are checking if the circle is valid.  1 if   ( circle . isValid ()   ==   true ))   {..}   \nis redundant.  What if we call the function  x  as something else, say,  checkValidity() ?  First of all, DON'T.  Second, yes, it is then OK to write:  1 if   ( circle . checkValidity ()   ==   true ))   {..}   \nbut can you tell by reading this line of code, whether  true  means the circle is valid or not?  So, DON'T.  Keep your code short, english-like, and choose a proper name for your variables and methods.",
            "title": "Style: if (x == true)"
        },
        {
            "location": "/lab2/index.html",
            "text": "Lab 2\n\n\nSubmission deadline: 2359, Sunday, September 10, 2017.\n\n\nPrerequisites\n\n\nAssume that students are already familiar with:\n\n\n\n\nthe \nCS2030 laboratory environment\n\n\nhow to compile and run Java programs\n\n\nfamiliar with standard I/O and I/O redirection\n\n\ncomfortable with Java syntax\n\n\nlooking up Java API documentation\n\n\nunderstand the concepts of encapsulation and using encapsulated objects\n\n\n\n\nLearning Objectives\n\n\nAfter completing this lab, students should:\n\n\n\n\nbe more comfortable with looking at a complex problem and identify data and procedures that should be kept within an abstraction barrier.  In other words, be more comfortable with creating own encapsulated class.\n\n\nbe more comfortable with basic Java syntax and semantics, particularly when creating classes from scratch.\n\n\n\n\nSetup\n\n\nLogin to \ncs2030-i\n, copy the files from \n~cs2030/lab02\n to your local directory under your home \n~/lab02\n.  You should see one java file (\nLabTwo.java\n) and a few data files (\nTESTDATA1.txt\n, \nTESTDATA2.txt\n, ..., \nTESTDATA5.txt\n)\n\n\nTask\n\n\nLabTwo.java\n implements a working discrete event simulator that simulates customers being served by a server.  It is written in procedural style with no encapsulation.  Your task, in this lab, is to rewrite this simulator with OO style, by properly using encapsulation to create abstraction barriers to the various variables and methods.\n\n\nGrading\n\n\nThis lab contributes 4 marks to your final grade (100 marks).\nYou will get 0-3 marks for your design and encapsulation of the classes.\nYou will get 1 mark if you code works correctly (but only if you score at least 1 mark for your design and use of encapsulation\n1\n)\n\n\nDiscrete Event Simulator\n\n\nA discrete event simulator is a software that simulates a system (often modeled after the real world) with events and states.  An event occurs at a particular time, and each event alter the states of the system, and may generate more events.  A discrete event simulator can be used to study many complex real world systems.  The term \ndiscrete\n refers to the fact that, the states remain unchanged between two events, and therefore, the simulator can \njump\n from the time of one event to another, instead of following the clock in real time.  The simulator typically keeps track of some statistics to measure the performance of the system.\n\n\nIn this lab, we start with simulating a specific situation:\n\n\n\n\nWe have a shop with a \nserver\n (a person providing service to customer).\n\n\nThe server can serve one customer at a time.\n\n\nWe assume for now that the server takes constant time to serve a customer.\n  The time taken to serve is called \nservice time\n.\n\n\nWhen a customer arrives:\n\n\nif the server is idle (not serving any customer), then the server serves the customer immediately (no waiting).\n\n\nif the server is serving another customer, then the customer that just arrives waits.\n\n\nif the server is serving one customer, and another customer is waiting, then the customer that just arrives just leave (no waiting) and go elsewhere.  In other words, there is at most one waiting customer.\n\n\n\n\n\n\nWhen the server is done serving a customer:\n\n\nthe served customer leaves.\n\n\nif there is another customer waiting, the server starts serving the waiting customer immediately.\n\n\nif there is no waiting customer, then server becomes idle again.\n\n\n\n\n\n\n\n\nWe are interested in the following.  Given a sequence of customer arrivals (time of each arrival is given):\n\n\n\n\nWhat is the average waiting time for customers that has been served?\n\n\nHow many customers are served?\n\n\nHow many customers left without being served?\n\n\n\n\nIn your Lab 2, you are given a simple discrete event simulator to answer the questions above.  There are two classes: \nSimulator\n and \nEvent\n.\n\n\nClass \nEvent\n\n\nThe event class is written in procedural style, not unlike a \nstruct\n in C.  All members are public, and there is no method.  Each \nEvent\n keeps track of two information: the \ntime\n the event occurs, and \neventType\n, which signifies what type of events is this.  Instead of using time like 9:45pm, we simply and represent time as a double value.\n\n\n1\n2\n3\n4\n  \nstatic\n \nclass\n \nEvent\n \n{\n\n    \npublic\n \ndouble\n \ntime\n;\n \n// The time this event will occur\n\n    \npublic\n \nint\n \neventType\n;\n \n// The type of event, indicates what should happen when an event occurs.\n\n  \n}\n\n\n\n\n\n\n\nWe handle two types of events for this particular scenario: an event of type \nCUSTOMER_ARRIVE\n means that a customer arrives during this event; while an event of type \nCUSTOMER_DONE\n means that the customer is done being served.  \nCUSTOMER_ARRIVE\n events are created based on the given input.  \nCUSTOMER_DONE\n events are created and scheduled to occur sometime into the future when a customer is being served.\n\n\n1\n2\n  \npublic\n \nstatic\n \nfinal\n \nint\n \nCUSTOMER_ARRIVE\n \n=\n \n1\n;\n\n  \npublic\n \nstatic\n \nfinal\n \nint\n \nCUSTOMER_DONE\n \n=\n \n2\n;\n\n\n\n\n\n\n\nClass \nSimulator\n\n\nThe simulator class is again written in procedural style.  All members are public, and there is no method.\n\n\nThe \nSimulator\n class contains two configuration parameters, \nMAX_NUMBER_OF_EVENTS\n indicates the maximum number of events that the simulator can store at one time; \nSERVICE_TIME\n indicates the time the server takes to serve a customer.\n\n1\n2\n    \npublic\n \nint\n \nMAX_NUMBER_OF_EVENTS\n \n=\n \n100\n;\n \n// Maximum number of events\n\n    \npublic\n \ndouble\n \nSERVICE_TIME\n \n=\n \n1.0\n;\n \n// Time spent serving a customer\n\n\n\n\n\n\nThe \nevents\n is an array of \nEvent\n that store all events scheduled for the future in the simulator.\n\n1\n2\n    \npublic\n \nEvent\n[]\n \nevents\n;\n \n// Array of events, order of events not guaranteed.\n\n    \npublic\n \nint\n \nnumOfEvents\n;\n \n// The number of events in the event array.\n\n\n\n\n\n\nThe simulator needs to keep track of three states:\n\n\n\n\nis a customer being served?\n\n\nis a customer waiting?\n\n\nif a customer is waiting, when did he start waiting?\n\n\n\n\nThese states are represented as:\n\n\n1\n2\n3\n    \npublic\n \nboolean\n \ncustomerBeingServed\n;\n \n// is a customer currently being served?\n\n    \npublic\n \nboolean\n \ncustomerWaiting\n;\n \n// is a customer currently waiting?\n\n    \npublic\n \ndouble\n \ntimeStartedWaiting\n;\n \n// the time the current waiting customer started waiting\n\n\n\n\n\n\n\nRemember we are interested in the following statistics:\n\n\n\n\nWhat is the average waiting time for customers that has been served?\n\n\nHow many customers are served?\n\n\nHow many customers left without being served?\n\n\n\n\nwhich can be computing from the following members:\n\n\n1\n2\n3\n    \npublic\n \ndouble\n \ntotalWaitingTime\n;\n \n// total time everyone spent waiting\n\n    \npublic\n \nint\n \ntotalNumOfServedCustomer\n;\n \n// how many customer has waited\n\n    \npublic\n \nint\n \ntotalNumOfLostCustomer\n;\n \n// how many customer has been lost\n\n\n\n\n\n\n\nFinally, for debugging purposes, the simulator assigns unique IDs 1, 2, 3, ... to the customers, in the order of their arrivals.  It then keeps track of the ID of the customer being served (if any) and the customer waiting to be served.\n\n\n1\n2\n3\n    \npublic\n \nint\n \nlastCustomerId\n;\n \n// starts from 0 and increases as customer arrives.\n\n    \npublic\n \nint\n \nservedCustomerId\n;\n \n// id of the customer being served, if any\n\n    \npublic\n \nint\n \nwaitingCustomerId\n;\n \n// id of the customer currently waiting, if any\n\n\n\n\n\n\n\nInteraction between \nSimulator\n and \nEvent\n\n\nWe create a \nSimulator\n by calling the method:\n\n1\n  \nstatic\n \nSimulator\n \ncreateSimulator\n()\n \n{..}\n\n\n\n\n\nand an \nEvent\n by calling the method, specifying \nwhen\n the event will occur, and the \ntype\n of the event.\n\n1\n  \nstatic\n \nEvent\n \ncreateEvent\n(\ndouble\n \nwhen\n,\n \nint\n \ntype\n)\n  \n{..}\n\n\n\n\n\n\nWe can schedule the event \ne\n to be executed by simulator \nsim\n by calling:\n\n1\n  \nstatic\n \nboolean\n \nscheduleEventInSimulator\n(\nEvent\n \ne\n,\n \nSimulator\n \nsim\n)\n \n{..}\n\n\n\n\n\nThis method will return \ntrue\n if the event is scheduled succesfully, \nfalse\n if the simulator run out of space to store the event (i.e., \nMAX_NUMBER_OF_EVENTS\n is reached).\n\n\nWe always execute the events in increasing sequence of their time.  Once the simulator starts running, it repeatedly find the next event with the smallest timestamp (i.e., earliest event), remove it from the list of events, and execute the event.  The simulator stops when there is no more event to run.\n\n\n1\n2\n3\n4\n5\n6\n  \nstatic\n \nvoid\n \nrunSimulator\n(\nSimulator\n \nsim\n)\n \n{\n\n    \nwhile\n \n(\nsim\n.\nnumOfEvents\n \n>\n \n0\n)\n \n{\n\n      \nEvent\n \ne\n \n=\n \ngetNextEarliestEvent\n(\nsim\n);\n\n      \nsimulateEvent\n(\nsim\n,\n \ne\n);\n\n    \n}\n\n  \n}\n\n\n\n\n\n\n\nHere, \ne = getNextEarliestEvent(sim)\n removes and returns the earliest event in the simulator, and \nsimulateEvent(sim, e)\n update the states of the simulator according to the type of the event \ne\n.\n\n\nSimulated System\n\n\nThe logic of the system being simulator (i.e., behavior of customers and server) is implemented in \nsimulateEvent\n.  There are four methods being called from here:\n\n\n\n\nserveCustomer(sim, time, id)\n: called to start serving a customer with ID \nid\n\n\nmakeCustomerWait(sim, time, id)\n: called to make the customer with ID \nid\n wait\n\n\ncustomerLeaves(sim, time, id)\n: called when the customer with ID \nid\n who just arrived leaves immediately (as someone else is waiting)\n\n\nservedWaitingCustomer(sim, time)\n: called to start serving the customer that is currently waiting.\n\n\n\n\nYou should read through \nLabTwo.java\n and clarify if you are not sure about any part of the given code.\n\n\nInput: Arrival Time\n\n\nThe input consists of a sequence of double values, each is the arrival time of a customer (in any order).  We can read from standard input (if no command line argument is given)\n\n1\n2\njava LabTwo\njava LabTwo  < TESTDATA1.txt\n\n\n\n\nor read from a given filename\n\n1\njava LabTwo TESTDATA1\n\n\n\n\n\nGiven an input, the output might not be deterministric, since if two events occur at exactly the same time, we break the ties arbitarily.  For this reason, we will only test your code with input where no two events occur at exactly the same time.\n\n\nYour Task\n\n\nThe given \nLabTwo.java\n is written in C style, no minimal encapsulation.  As you read through the code, you should appreciate how messy and difficult to understand the code is.\n\n\nYour mission, in Lab 2, is to rewrite the code using encapsulation, applying OO paradigm, properly maintain the abstraction barrier when the objects interact.  Here are some rules:\n\n\n\n\nYou can add as many classes as you like.  Each class must be in its own \n.java\n file\n\n\nThe \nmain\n method should remain in a class named \nLabTwo\n.  We must be able to run your code with:\n\n1\n2\njavac *.java\njava LabTwo < TESTDATA1.txt\n\n\n\n\n\nYou must not change the formatting of the \nlast line\n of output (\nSystem.out.printf(\"%.3f %d %d\", ..\")\n).  We rely on it to check for correctness of your logic.\n\n\n\n\nSubmission\n\n\nWhen you are ready to submit your lab, on \ncs2030-i\n, run the script\n\n1\n~cs2030/submit02\n\n\n\n\n\nwhich will copy all files matching \n*.java\n (and nothing else) from your \n~/lab02\n directory on \ncs2030-i\n to an internal grading directory.  We will test compile and test run with a tiny sample input to make sure that your submission is OK.\n\n\nYou can submit multiple times, but only the most recent submission will be graded.\n\n\nExtra Java Stuff\n\n\nYou are exposed to three new Java syntax/class in this Lab:\n\n\n\n\nNested classes: In the code given to you, we define \nSimulator\n and \nEvent\n within the class \nLabTwo\n.  This is called \nnested class\n in Java.  Usually, this is useful if we need to create a class that is only useful to another class.  We can group logically relevant classes together.\n\n\nassert\n keyword: \nassert\n works like in C and Python.  You use \nassert\n to check for conditions that has to be true in your code.  If an assertion fails, the program will bail, informing you what went wrong.  This is useful to catch bugs quickly.  Use this by passing a \n-ea\n (enable assertions) flag when running a Java program e.g. \njava -ea LabTwo TESTDATA1.txt\n\n\nFileReader\n: a useful class for reading a stream of characters from a file.\n\n\n\n\n\n\n\n\n\n\n\n\nThis is so that, if you just take the code we give you and submit as is, you cannot claim that it works so we must have you 1 mark.\u00a0\n\u21a9",
            "title": "2. Question"
        },
        {
            "location": "/lab2/index.html#lab-2",
            "text": "Submission deadline: 2359, Sunday, September 10, 2017.",
            "title": "Lab 2"
        },
        {
            "location": "/lab2/index.html#prerequisites",
            "text": "Assume that students are already familiar with:   the  CS2030 laboratory environment  how to compile and run Java programs  familiar with standard I/O and I/O redirection  comfortable with Java syntax  looking up Java API documentation  understand the concepts of encapsulation and using encapsulated objects",
            "title": "Prerequisites"
        },
        {
            "location": "/lab2/index.html#learning-objectives",
            "text": "After completing this lab, students should:   be more comfortable with looking at a complex problem and identify data and procedures that should be kept within an abstraction barrier.  In other words, be more comfortable with creating own encapsulated class.  be more comfortable with basic Java syntax and semantics, particularly when creating classes from scratch.",
            "title": "Learning Objectives"
        },
        {
            "location": "/lab2/index.html#setup",
            "text": "Login to  cs2030-i , copy the files from  ~cs2030/lab02  to your local directory under your home  ~/lab02 .  You should see one java file ( LabTwo.java ) and a few data files ( TESTDATA1.txt ,  TESTDATA2.txt , ...,  TESTDATA5.txt )",
            "title": "Setup"
        },
        {
            "location": "/lab2/index.html#task",
            "text": "LabTwo.java  implements a working discrete event simulator that simulates customers being served by a server.  It is written in procedural style with no encapsulation.  Your task, in this lab, is to rewrite this simulator with OO style, by properly using encapsulation to create abstraction barriers to the various variables and methods.",
            "title": "Task"
        },
        {
            "location": "/lab2/index.html#grading",
            "text": "This lab contributes 4 marks to your final grade (100 marks).\nYou will get 0-3 marks for your design and encapsulation of the classes.\nYou will get 1 mark if you code works correctly (but only if you score at least 1 mark for your design and use of encapsulation 1 )",
            "title": "Grading"
        },
        {
            "location": "/lab2/index.html#discrete-event-simulator",
            "text": "A discrete event simulator is a software that simulates a system (often modeled after the real world) with events and states.  An event occurs at a particular time, and each event alter the states of the system, and may generate more events.  A discrete event simulator can be used to study many complex real world systems.  The term  discrete  refers to the fact that, the states remain unchanged between two events, and therefore, the simulator can  jump  from the time of one event to another, instead of following the clock in real time.  The simulator typically keeps track of some statistics to measure the performance of the system.  In this lab, we start with simulating a specific situation:   We have a shop with a  server  (a person providing service to customer).  The server can serve one customer at a time.  We assume for now that the server takes constant time to serve a customer.\n  The time taken to serve is called  service time .  When a customer arrives:  if the server is idle (not serving any customer), then the server serves the customer immediately (no waiting).  if the server is serving another customer, then the customer that just arrives waits.  if the server is serving one customer, and another customer is waiting, then the customer that just arrives just leave (no waiting) and go elsewhere.  In other words, there is at most one waiting customer.    When the server is done serving a customer:  the served customer leaves.  if there is another customer waiting, the server starts serving the waiting customer immediately.  if there is no waiting customer, then server becomes idle again.     We are interested in the following.  Given a sequence of customer arrivals (time of each arrival is given):   What is the average waiting time for customers that has been served?  How many customers are served?  How many customers left without being served?   In your Lab 2, you are given a simple discrete event simulator to answer the questions above.  There are two classes:  Simulator  and  Event .",
            "title": "Discrete Event Simulator"
        },
        {
            "location": "/lab2/index.html#class-event",
            "text": "The event class is written in procedural style, not unlike a  struct  in C.  All members are public, and there is no method.  Each  Event  keeps track of two information: the  time  the event occurs, and  eventType , which signifies what type of events is this.  Instead of using time like 9:45pm, we simply and represent time as a double value.  1\n2\n3\n4    static   class   Event   { \n     public   double   time ;   // The time this event will occur \n     public   int   eventType ;   // The type of event, indicates what should happen when an event occurs. \n   }    We handle two types of events for this particular scenario: an event of type  CUSTOMER_ARRIVE  means that a customer arrives during this event; while an event of type  CUSTOMER_DONE  means that the customer is done being served.   CUSTOMER_ARRIVE  events are created based on the given input.   CUSTOMER_DONE  events are created and scheduled to occur sometime into the future when a customer is being served.  1\n2    public   static   final   int   CUSTOMER_ARRIVE   =   1 ; \n   public   static   final   int   CUSTOMER_DONE   =   2 ;",
            "title": "Class Event"
        },
        {
            "location": "/lab2/index.html#class-simulator",
            "text": "The simulator class is again written in procedural style.  All members are public, and there is no method.  The  Simulator  class contains two configuration parameters,  MAX_NUMBER_OF_EVENTS  indicates the maximum number of events that the simulator can store at one time;  SERVICE_TIME  indicates the time the server takes to serve a customer. 1\n2      public   int   MAX_NUMBER_OF_EVENTS   =   100 ;   // Maximum number of events \n     public   double   SERVICE_TIME   =   1.0 ;   // Time spent serving a customer    The  events  is an array of  Event  that store all events scheduled for the future in the simulator. 1\n2      public   Event []   events ;   // Array of events, order of events not guaranteed. \n     public   int   numOfEvents ;   // The number of events in the event array.    The simulator needs to keep track of three states:   is a customer being served?  is a customer waiting?  if a customer is waiting, when did he start waiting?   These states are represented as:  1\n2\n3      public   boolean   customerBeingServed ;   // is a customer currently being served? \n     public   boolean   customerWaiting ;   // is a customer currently waiting? \n     public   double   timeStartedWaiting ;   // the time the current waiting customer started waiting    Remember we are interested in the following statistics:   What is the average waiting time for customers that has been served?  How many customers are served?  How many customers left without being served?   which can be computing from the following members:  1\n2\n3      public   double   totalWaitingTime ;   // total time everyone spent waiting \n     public   int   totalNumOfServedCustomer ;   // how many customer has waited \n     public   int   totalNumOfLostCustomer ;   // how many customer has been lost    Finally, for debugging purposes, the simulator assigns unique IDs 1, 2, 3, ... to the customers, in the order of their arrivals.  It then keeps track of the ID of the customer being served (if any) and the customer waiting to be served.  1\n2\n3      public   int   lastCustomerId ;   // starts from 0 and increases as customer arrives. \n     public   int   servedCustomerId ;   // id of the customer being served, if any \n     public   int   waitingCustomerId ;   // id of the customer currently waiting, if any",
            "title": "Class Simulator"
        },
        {
            "location": "/lab2/index.html#interaction-between-simulator-and-event",
            "text": "We create a  Simulator  by calling the method: 1    static   Simulator   createSimulator ()   {..}   \nand an  Event  by calling the method, specifying  when  the event will occur, and the  type  of the event. 1    static   Event   createEvent ( double   when ,   int   type )    {..}    We can schedule the event  e  to be executed by simulator  sim  by calling: 1    static   boolean   scheduleEventInSimulator ( Event   e ,   Simulator   sim )   {..}   \nThis method will return  true  if the event is scheduled succesfully,  false  if the simulator run out of space to store the event (i.e.,  MAX_NUMBER_OF_EVENTS  is reached).  We always execute the events in increasing sequence of their time.  Once the simulator starts running, it repeatedly find the next event with the smallest timestamp (i.e., earliest event), remove it from the list of events, and execute the event.  The simulator stops when there is no more event to run.  1\n2\n3\n4\n5\n6    static   void   runSimulator ( Simulator   sim )   { \n     while   ( sim . numOfEvents   >   0 )   { \n       Event   e   =   getNextEarliestEvent ( sim ); \n       simulateEvent ( sim ,   e ); \n     } \n   }    Here,  e = getNextEarliestEvent(sim)  removes and returns the earliest event in the simulator, and  simulateEvent(sim, e)  update the states of the simulator according to the type of the event  e .",
            "title": "Interaction between Simulator and Event"
        },
        {
            "location": "/lab2/index.html#simulated-system",
            "text": "The logic of the system being simulator (i.e., behavior of customers and server) is implemented in  simulateEvent .  There are four methods being called from here:   serveCustomer(sim, time, id) : called to start serving a customer with ID  id  makeCustomerWait(sim, time, id) : called to make the customer with ID  id  wait  customerLeaves(sim, time, id) : called when the customer with ID  id  who just arrived leaves immediately (as someone else is waiting)  servedWaitingCustomer(sim, time) : called to start serving the customer that is currently waiting.   You should read through  LabTwo.java  and clarify if you are not sure about any part of the given code.",
            "title": "Simulated System"
        },
        {
            "location": "/lab2/index.html#input-arrival-time",
            "text": "The input consists of a sequence of double values, each is the arrival time of a customer (in any order).  We can read from standard input (if no command line argument is given) 1\n2 java LabTwo\njava LabTwo  < TESTDATA1.txt  \nor read from a given filename 1 java LabTwo TESTDATA1   Given an input, the output might not be deterministric, since if two events occur at exactly the same time, we break the ties arbitarily.  For this reason, we will only test your code with input where no two events occur at exactly the same time.",
            "title": "Input: Arrival Time"
        },
        {
            "location": "/lab2/index.html#your-task",
            "text": "The given  LabTwo.java  is written in C style, no minimal encapsulation.  As you read through the code, you should appreciate how messy and difficult to understand the code is.  Your mission, in Lab 2, is to rewrite the code using encapsulation, applying OO paradigm, properly maintain the abstraction barrier when the objects interact.  Here are some rules:   You can add as many classes as you like.  Each class must be in its own  .java  file  The  main  method should remain in a class named  LabTwo .  We must be able to run your code with: 1\n2 javac *.java\njava LabTwo < TESTDATA1.txt   You must not change the formatting of the  last line  of output ( System.out.printf(\"%.3f %d %d\", ..\") ).  We rely on it to check for correctness of your logic.",
            "title": "Your Task"
        },
        {
            "location": "/lab2/index.html#submission",
            "text": "When you are ready to submit your lab, on  cs2030-i , run the script 1 ~cs2030/submit02   which will copy all files matching  *.java  (and nothing else) from your  ~/lab02  directory on  cs2030-i  to an internal grading directory.  We will test compile and test run with a tiny sample input to make sure that your submission is OK.  You can submit multiple times, but only the most recent submission will be graded.",
            "title": "Submission"
        },
        {
            "location": "/lab2/index.html#extra-java-stuff",
            "text": "You are exposed to three new Java syntax/class in this Lab:   Nested classes: In the code given to you, we define  Simulator  and  Event  within the class  LabTwo .  This is called  nested class  in Java.  Usually, this is useful if we need to create a class that is only useful to another class.  We can group logically relevant classes together.  assert  keyword:  assert  works like in C and Python.  You use  assert  to check for conditions that has to be true in your code.  If an assertion fails, the program will bail, informing you what went wrong.  This is useful to catch bugs quickly.  Use this by passing a  -ea  (enable assertions) flag when running a Java program e.g.  java -ea LabTwo TESTDATA1.txt  FileReader : a useful class for reading a stream of characters from a file.       This is so that, if you just take the code we give you and submit as is, you cannot claim that it works so we must have you 1 mark.\u00a0 \u21a9",
            "title": "Extra Java Stuff"
        },
        {
            "location": "/lab3/index.html",
            "text": "Lab 3\n\n\nSubmission deadline: 2359, Sunday, September 17, 2017.\n\n\nPrerequisites\n\n\nThis lab assumes that students:\n\n\n\n\nhave already attempted Lab 2\n\n\nhave an understanding of the customer/server system being simulated\n\n\n\n\nLearning Objectives\n\n\nAfter completing this lab, students should:\n\n\n\n\nbe familiar with the \nCS2030 Java Coding Style\n and comfortable in following them \n\n\nbe familiar with \njavadoc\n syntax and comfortable with documenting the code with \njavadoc\n \n\n\nbe familiar with generating \njavadoc\n documentation \n\n\nbe comfortable reading a Java Collection Framework documentation and use one of the class provided\n\n\nappreciate the usefulness of Java Collection Framework by seeing how much shorter and cleaner the resulting code\n\n\nbe familiar with random number generation in \njava.lang.Math\n\n\nbe exposed to the concept of pseudo random number generator and seeds\n\n\n\n\nSetup\n\n\nThere is no new skeleton code provided.  You are to build from your Lab 3 solution based on your Lab 2.  To setup Lab 3, do the following.  \n\n\n\n\nLogin to \ncs2030-i\n\n\nCopy \n~/lab02\n to \n~/lab03\n \n\n\nRename \nLabTwo.java\n to \nLabThree.java\n\n\nRename the class \nLabTwo\n to \nLabThree\n\n\nCopy the test data (\nTESTDATA1.txt\n .. \nTESTDATA5.txt\n) from \n~cs2030/lab03\n to \n~/lab03\n\n\n\n\nIf you are still not familiar with how to do the above, please revisit the \nUNIX\n guide.\n\n\nTask\n\n\nFor Lab 3, you will be asked to make two small change to the code:\n\n\n\n\nMake the arrival time and service time random\n\n\nUse \nPriorityQueue<Event>\n instead of \nEvent[]\n to schedule the event.\n\n\n\n\nAs a result of this, you might realize that there is a better way to encapsulate the data and the behavior of the various entities in the program.  In which case, you may want to reorganize your classes, create new classes, etc.  Depending on how \"changeable\" your Lab 2 solution is, you may have ended up with more than two small changes.\n\n\nIn addition, you should edit your code so that:\n\n\n\n\nit follows the \nCS2030 Coding Style\n\n\nit is clearly documented with \njavadoc\n\n\n\n\nGrading\n\n\nThis lab contributes another 4 marks to your final grade (100 marks).\n\n\n\n\n1 marks for coding style\n\n\n1 marks for javadoc\n\n\n1 mark for implementation \nand encapsulation\n of arrival time/service time generation and the priority queue\n\n\n1 mark for correctness\n\n\n\n\nPriority Queuing\n\n\nThe first change you need to do in this assignment is to use one of the Java Collection classes to manage the events.  In \nLabTwo.java\n, we keep all the events in an array, and scanned through it to find the event with the smallest (i.e., earliest) timestamp.  This is not efficient, since scanning through all the events takes time that increases linearly with the number of events\n1\n.  \n\n\nJava Collection provides a class that is perfect for our use: \nPriorityQueue<E>\n.  A \nPriorityQueue\n keeps a collection of elements, the elements are given certain priority.  Elements can be added with \n[add(E e)](https://docs.oracle.com/javase/8/docs/api/java/util/PriorityQueue.html#add-E-)\n method.  To retrieve and remove the elements with highest priority, we use the \n[poll()](https://docs.oracle.com/javase/8/docs/api/java/util/PriorityQueue.html#poll--)\n method, which returns an object of type \nE\n, or \nnull\n is the queue is empty.\n\n\nIn our case, the event with the smallest timestamp have the highest priority.  To tell the \nPriorityQueue<E>\n class how to order the events so that smaller timestamp has higher priority, we use the \nPriorityQueue<E>\n constructor\n that takes in a \nComparator\n object, just like we see in \nLecture 5\n[^3].\n\n\nIf you design is right, you should only change the code in four places: (i) initialize list of events, (ii) schedule an event, (iii) get the next event, (iv) checking if there is still an event.\n\n\n(Hint: You should be able to implement a \nComparator\n without getter \ngetTime()\n)\n\n\nYou should implement this change first, since you can do a sanity check of your correctness against the result of Lab 2 using the test data \nfrom\n Lab 2.\n\n\nRandomized Arrival and Service Time\n\n\nNext, we are going to change how the arrival time and service time is specified, so that we can easily simulate different settings (e.g., a more efficient server with faster service time, more arrivals during weekends, etc).  \n\n\nRandom\n\n\nFirst, an introduction to random number generation.  A random number generator is an entity that spews up one random number after another.  We, however, cannot generate a truly random number algorithmically.  We can only generate a \npseudo\n random number.  A pseudo random number generator can be initialized with a \nseed\n.  A pseudo random number generator, when initialized with the same \nseed\n, always produces the same sequence of (seemingly random) numbers.  \n\n\nJava provides a class \njava.util.Random\n that encapsulates a pseudo random number generator.  We can create a random number generator with a seed:\n\n\n1\nRandom\n \nrng\n \n=\n \nnew\n \nRandom\n(\n1\n);\n\n\n\n\n\n\n\nWe can then call \nrng.nextDouble()\n repeatedly to generate random numbers between 0 and 1.\n\n\nIn the demo below, we see that creating a \nRandom\n object with the same seed of 2 towards the end leads to the same sequence of random doubles being generated.\n\n\n\n\n\nUsing a fixed seed is important for testing, since the execution of the program will be deterministic, even when random numbers are involved.\n\n\nArrival Time\n\n\nIn Lab 2, the arrival time is given in an input text file.  This approach is less flexible and requires another program to generate the input file.  Further, the original code creates \nall\n the arrival events before the simulation starts, and therefore limits the total number of arrivals to the size of the initial array \nevents\n.\n\n\nWe are going to improve this part of the program, by generating the arrival one after another.  To generate this, we need to generate a \nrandom inter-arrival time\n.  The inter-arrival time is usually modeled as a exponential random variable, characterized by a single parameter \n\\(\\lambda\\)\n (\nlambda\n), known as \narrival rate\n. \nMathematically, the inter-arrival time can be generated with \n\\(-\\ln(U)/\\lambda\\)\n, where \n\\(U\\)\n is a random variable between 0 and 1\n2\n.\n\n\n\n\nEvery time an arrival event is processed, it generates another arrival event and schedule it.\n\n\nIf there are still more customer to simulator, we generate the next arrival event with a timestamp of \n\\(T\\)\n + now, where \n\\(T\\)\n is generated with the Java expression: \n\n1\n  \n-\nMath\n.\nlog\n(\nrng\n.\nnextDouble\n())\n \n/\n \nlambda\n\n\n\n\n\n\nWhen we first starts the simulator, we need to generate the first arrival event with timestamp \n\\(T\\)\n, generated with the same expression as above.\n\n\n\n\nYou can adapt the expression above to suit your program.\n\n\nService Time\n\n\nIn Lab 2, the service time is constant, which is not always realistic. We are going to model the service time as a exponential random variable, characterized with a single parameter, \nservice rate\n \n\\(\\mu\\)\n (\nmu\n).  We can generate the service time with the expression \n\\(-\\ln(U)/\\mu\\)\n, where \n\\(U\\)\n is a random variable between 0 and 1.\n\n\n\n\nEvery time a customer is being served, we generate a \"done\" event and schedule it (just like we did it in Lab 2).\n\n\nThe \"done\" event generated will have a timestampt of \n\\(T\\)\n + now, where \n\\(T\\)\n is \nno longer constant \nSERVICE_TIME\n, but instead is generated with the Java expression:\n\n1\n   \n-\nMath\n.\nlog\n(\nrng\n.\nnextDouble\n())\n \n/\n \nmu\n\n\n\n\n\n\n\n\nYou can adapt the expression above to suit your program.\n\n\nNote that \nwe should only have a single random number generator\n in the simulation. (hint: what access modifier should we use?)\n\n\nInput and Output\n\n\nWith this change, the input file should now contain only the \nsimulator parameters\n.  It has four lines:\n\n\n\n\nThe first line is a \nint\n value, indicating the seed to the simulator\n\n\nThe second line is a \ndouble\n value, indicating the service rate \n\\(\\mu\\)\n\n\nThe third line is a \ndouble\n value, indicating the arrival rate \n\\(\\lambda\\)\n\n\nThe forth line is a \nint\n value, indicating the total number of customers to simulate\n\n\n\n\nWe give you five test inputs: \nTESTDATA1.txt\n to \nTESTDATA5.txt\n.  The output we get with these inputs are:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\nooiwt@cs2030-i:~/lab03> java LabThree < TESTDATA1.txt | tail -1\n0.000 1 0\nooiwt@cs2030-i:~/lab03> java LabThree < TESTDATA2.txt | tail -1\n0.924 3 2\nooiwt@cs2030-i:~/lab03> java LabThree < TESTDATA3.txt | tail -1\n0.019 10 0\nooiwt@cs2030-i:~/lab03> java LabThree < TESTDATA4.txt | tail -1\n0.832 3 7\nooiwt@cs2030-i:~/lab03> java LabThree < TESTDATA5.txt | tail -1\n0.530 634 366\n\n\n\n\n\n\nYour Task\n\n\nYour mission, in Lab 3, is update your solution in Lab 2 to:\n- follow the style guideline\n- add \njavadoc\n comments to code (\njavadoc\n should not produce any warning)\n- use \nPriorityQueue<E>\n to manage the events\n- use randomly generated service time and arrival time, specified by a new input file format\n- improve your existing encapsulations, create new encapsultions, etc. if necessary\n\n\n\n\nThe \nmain\n method should remain in a class named \nLabThree\n.  We must be able to run your code with:\n\n1\n2\njavac *.java\njava LabThree < TESTDATA1.txt\n\n\n\n\n\nYou must not change the formatting of the \nlast line\n of output (\nSystem.out.printf(\"%.3f %d %d\", ..\")\n).  We rely on it to check for correctness of your logic.\n\n\n\n\nSubmission\n\n\nWhen you are ready to submit your lab, on \ncs2030-i\n, run the script\n\n1\n~cs2030/submit03\n\n\n\n\n\nwhich will copy all files matching \n*.java\n (and nothing else) from your \n~/lab03\n directory on \ncs2030-i\n to an internal grading directory.  We will test compile and test run with a tiny sample input to make sure that your submission is OK.\n\n\nYou can submit multiple times, but only the most recent submission will be graded.\n\n\n\n\n\n\n\n\n\n\nFor those who are taking CS2040, we say this is \n\\(O(n)\\)\n time.  A heap-based priority queue, on the other hand, takes \n\\(O(log n)\\)\n time.\u00a0\n\u21a9\n\n\n\n\n\n\nIf you are not familiar with exponential distribution and random variable, do not worry, the code is being given to you.  These concepts are covered in ST2334.\u00a0\n\u21a9",
            "title": "3. Question"
        },
        {
            "location": "/lab3/index.html#lab-3",
            "text": "Submission deadline: 2359, Sunday, September 17, 2017.",
            "title": "Lab 3"
        },
        {
            "location": "/lab3/index.html#prerequisites",
            "text": "This lab assumes that students:   have already attempted Lab 2  have an understanding of the customer/server system being simulated",
            "title": "Prerequisites"
        },
        {
            "location": "/lab3/index.html#learning-objectives",
            "text": "After completing this lab, students should:   be familiar with the  CS2030 Java Coding Style  and comfortable in following them   be familiar with  javadoc  syntax and comfortable with documenting the code with  javadoc    be familiar with generating  javadoc  documentation   be comfortable reading a Java Collection Framework documentation and use one of the class provided  appreciate the usefulness of Java Collection Framework by seeing how much shorter and cleaner the resulting code  be familiar with random number generation in  java.lang.Math  be exposed to the concept of pseudo random number generator and seeds",
            "title": "Learning Objectives"
        },
        {
            "location": "/lab3/index.html#setup",
            "text": "There is no new skeleton code provided.  You are to build from your Lab 3 solution based on your Lab 2.  To setup Lab 3, do the following.     Login to  cs2030-i  Copy  ~/lab02  to  ~/lab03    Rename  LabTwo.java  to  LabThree.java  Rename the class  LabTwo  to  LabThree  Copy the test data ( TESTDATA1.txt  ..  TESTDATA5.txt ) from  ~cs2030/lab03  to  ~/lab03   If you are still not familiar with how to do the above, please revisit the  UNIX  guide.",
            "title": "Setup"
        },
        {
            "location": "/lab3/index.html#task",
            "text": "For Lab 3, you will be asked to make two small change to the code:   Make the arrival time and service time random  Use  PriorityQueue<Event>  instead of  Event[]  to schedule the event.   As a result of this, you might realize that there is a better way to encapsulate the data and the behavior of the various entities in the program.  In which case, you may want to reorganize your classes, create new classes, etc.  Depending on how \"changeable\" your Lab 2 solution is, you may have ended up with more than two small changes.  In addition, you should edit your code so that:   it follows the  CS2030 Coding Style  it is clearly documented with  javadoc",
            "title": "Task"
        },
        {
            "location": "/lab3/index.html#grading",
            "text": "This lab contributes another 4 marks to your final grade (100 marks).   1 marks for coding style  1 marks for javadoc  1 mark for implementation  and encapsulation  of arrival time/service time generation and the priority queue  1 mark for correctness",
            "title": "Grading"
        },
        {
            "location": "/lab3/index.html#priority-queuing",
            "text": "The first change you need to do in this assignment is to use one of the Java Collection classes to manage the events.  In  LabTwo.java , we keep all the events in an array, and scanned through it to find the event with the smallest (i.e., earliest) timestamp.  This is not efficient, since scanning through all the events takes time that increases linearly with the number of events 1 .    Java Collection provides a class that is perfect for our use:  PriorityQueue<E> .  A  PriorityQueue  keeps a collection of elements, the elements are given certain priority.  Elements can be added with  [add(E e)](https://docs.oracle.com/javase/8/docs/api/java/util/PriorityQueue.html#add-E-)  method.  To retrieve and remove the elements with highest priority, we use the  [poll()](https://docs.oracle.com/javase/8/docs/api/java/util/PriorityQueue.html#poll--)  method, which returns an object of type  E , or  null  is the queue is empty.  In our case, the event with the smallest timestamp have the highest priority.  To tell the  PriorityQueue<E>  class how to order the events so that smaller timestamp has higher priority, we use the  PriorityQueue<E>  constructor  that takes in a  Comparator  object, just like we see in  Lecture 5 [^3].  If you design is right, you should only change the code in four places: (i) initialize list of events, (ii) schedule an event, (iii) get the next event, (iv) checking if there is still an event.  (Hint: You should be able to implement a  Comparator  without getter  getTime() )  You should implement this change first, since you can do a sanity check of your correctness against the result of Lab 2 using the test data  from  Lab 2.",
            "title": "Priority Queuing"
        },
        {
            "location": "/lab3/index.html#randomized-arrival-and-service-time",
            "text": "Next, we are going to change how the arrival time and service time is specified, so that we can easily simulate different settings (e.g., a more efficient server with faster service time, more arrivals during weekends, etc).",
            "title": "Randomized Arrival and Service Time"
        },
        {
            "location": "/lab3/index.html#random",
            "text": "First, an introduction to random number generation.  A random number generator is an entity that spews up one random number after another.  We, however, cannot generate a truly random number algorithmically.  We can only generate a  pseudo  random number.  A pseudo random number generator can be initialized with a  seed .  A pseudo random number generator, when initialized with the same  seed , always produces the same sequence of (seemingly random) numbers.    Java provides a class  java.util.Random  that encapsulates a pseudo random number generator.  We can create a random number generator with a seed:  1 Random   rng   =   new   Random ( 1 );    We can then call  rng.nextDouble()  repeatedly to generate random numbers between 0 and 1.  In the demo below, we see that creating a  Random  object with the same seed of 2 towards the end leads to the same sequence of random doubles being generated.   Using a fixed seed is important for testing, since the execution of the program will be deterministic, even when random numbers are involved.",
            "title": "Random"
        },
        {
            "location": "/lab3/index.html#arrival-time",
            "text": "In Lab 2, the arrival time is given in an input text file.  This approach is less flexible and requires another program to generate the input file.  Further, the original code creates  all  the arrival events before the simulation starts, and therefore limits the total number of arrivals to the size of the initial array  events .  We are going to improve this part of the program, by generating the arrival one after another.  To generate this, we need to generate a  random inter-arrival time .  The inter-arrival time is usually modeled as a exponential random variable, characterized by a single parameter  \\(\\lambda\\)  ( lambda ), known as  arrival rate . \nMathematically, the inter-arrival time can be generated with  \\(-\\ln(U)/\\lambda\\) , where  \\(U\\)  is a random variable between 0 and 1 2 .   Every time an arrival event is processed, it generates another arrival event and schedule it.  If there are still more customer to simulator, we generate the next arrival event with a timestamp of  \\(T\\)  + now, where  \\(T\\)  is generated with the Java expression:  1    - Math . log ( rng . nextDouble ())   /   lambda    When we first starts the simulator, we need to generate the first arrival event with timestamp  \\(T\\) , generated with the same expression as above.   You can adapt the expression above to suit your program.",
            "title": "Arrival Time"
        },
        {
            "location": "/lab3/index.html#service-time",
            "text": "In Lab 2, the service time is constant, which is not always realistic. We are going to model the service time as a exponential random variable, characterized with a single parameter,  service rate   \\(\\mu\\)  ( mu ).  We can generate the service time with the expression  \\(-\\ln(U)/\\mu\\) , where  \\(U\\)  is a random variable between 0 and 1.   Every time a customer is being served, we generate a \"done\" event and schedule it (just like we did it in Lab 2).  The \"done\" event generated will have a timestampt of  \\(T\\)  + now, where  \\(T\\)  is  no longer constant  SERVICE_TIME , but instead is generated with the Java expression: 1     - Math . log ( rng . nextDouble ())   /   mu     You can adapt the expression above to suit your program.  Note that  we should only have a single random number generator  in the simulation. (hint: what access modifier should we use?)",
            "title": "Service Time"
        },
        {
            "location": "/lab3/index.html#input-and-output",
            "text": "With this change, the input file should now contain only the  simulator parameters .  It has four lines:   The first line is a  int  value, indicating the seed to the simulator  The second line is a  double  value, indicating the service rate  \\(\\mu\\)  The third line is a  double  value, indicating the arrival rate  \\(\\lambda\\)  The forth line is a  int  value, indicating the total number of customers to simulate   We give you five test inputs:  TESTDATA1.txt  to  TESTDATA5.txt .  The output we get with these inputs are:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10 ooiwt@cs2030-i:~/lab03> java LabThree < TESTDATA1.txt | tail -1\n0.000 1 0\nooiwt@cs2030-i:~/lab03> java LabThree < TESTDATA2.txt | tail -1\n0.924 3 2\nooiwt@cs2030-i:~/lab03> java LabThree < TESTDATA3.txt | tail -1\n0.019 10 0\nooiwt@cs2030-i:~/lab03> java LabThree < TESTDATA4.txt | tail -1\n0.832 3 7\nooiwt@cs2030-i:~/lab03> java LabThree < TESTDATA5.txt | tail -1\n0.530 634 366",
            "title": "Input and Output"
        },
        {
            "location": "/lab3/index.html#your-task",
            "text": "Your mission, in Lab 3, is update your solution in Lab 2 to:\n- follow the style guideline\n- add  javadoc  comments to code ( javadoc  should not produce any warning)\n- use  PriorityQueue<E>  to manage the events\n- use randomly generated service time and arrival time, specified by a new input file format\n- improve your existing encapsulations, create new encapsultions, etc. if necessary   The  main  method should remain in a class named  LabThree .  We must be able to run your code with: 1\n2 javac *.java\njava LabThree < TESTDATA1.txt   You must not change the formatting of the  last line  of output ( System.out.printf(\"%.3f %d %d\", ..\") ).  We rely on it to check for correctness of your logic.",
            "title": "Your Task"
        },
        {
            "location": "/lab3/index.html#submission",
            "text": "When you are ready to submit your lab, on  cs2030-i , run the script 1 ~cs2030/submit03   which will copy all files matching  *.java  (and nothing else) from your  ~/lab03  directory on  cs2030-i  to an internal grading directory.  We will test compile and test run with a tiny sample input to make sure that your submission is OK.  You can submit multiple times, but only the most recent submission will be graded.      For those who are taking CS2040, we say this is  \\(O(n)\\)  time.  A heap-based priority queue, on the other hand, takes  \\(O(log n)\\)  time.\u00a0 \u21a9    If you are not familiar with exponential distribution and random variable, do not worry, the code is being given to you.  These concepts are covered in ST2334.\u00a0 \u21a9",
            "title": "Submission"
        },
        {
            "location": "/jdk/index.html",
            "text": "Java: Install/Compile/Run\n\n\nJava Development Kit (JDK)\n\n\nThe Java Development Kit, or JDK, is a development environment for building Java applications.  The environment provides a virtual machine to execute compiled Java code (JVM), a collection of classes and libraries, and a set of tools to support development (including a compiler (\njavac\n), a debugger (\njdb\n), an interactive shell (\njshell\n)) etc.\n\n\nThere are several variations of JDK available.  For instance, \nOpenJDK\n is a free and open source version of JDK.  \nGNU\n offers a compiler in Java (\ngcj\n) and Java core libraries in Gnu classpath.\nEclipse offers its own version of Java compiler\n1\n.  These variations are mostly the same, but for the purpose of this module, we will use the \nofficial Oracle version\n.\n\n\nThere are different editions of Java.  The main ones are Java SE (standard edition), Java EE (enterprise edition), and Java ME (micro edition).  We will be using \nJava SE\n.\n\n\nThe latest version of Java SE is Java 8 (equivalent to version 1.8).\nThis is also the earliest version of Java that will work with this module, as many concepts we will cover are only introduced in Java 8.  \n\n\nTo use \njshell\n, however, you need Java 9, which you can \ndownload and install from here\n.\n\n\nInstalling JDK 9\n\n\nThere are multiple ways to setup JDK on various OS.  The following seems to be the simplest possible way to get started.\n\n\nOn macOS\n\n\nDownload the \n.dmg\n file corresponding to JDK 9 from \nhttp://jdk.java.net/9/\n and double click the \n.dmg\n file.  Follow instruction from there.\n\n\nFor a 6-step description of the above, see \nthe installation instruction from Oracle.\n\n\nOn Ubuntu / Linux Mint / Debian\n\n\nWe are going to use \napt\n, a package management program, in Linux to install JDK.  Run the following in your terminal:\n\n\n1\n2\n3\nsudo add-apt-repository ppa:webupd8team/java\nsudo apt-get update\nsudo apt-get install oracle-java9-installer\n\n\n\n\n\n\nLine 1 above adds a special package repository (also known as Personal Package Archive (PPA)) to \napt\n.  Line 2 instructs \napt\n to download the list of packages available from all repositories configured.  One of this packages should be \noracle-java9-installer\n.  Line 3 installs the \noracle-java9-installer\n.  Note that this install the installer, not Java 9.  After the installer is installed, the installer is executed.  You will be asked questions about license agreements, and then the installer proceeds to download and install Java 9.\n\n\nFor a more detailed instructions, see \nthe guide from the maintainer of the PPA, webupd8.org\n.\n\n\nOn Windows 10\n\n\nFollow the \ninstructions to install Bash on Ubuntu on Windows\n, then install as per the instructions for Ubuntu above.\n\n\nOther Methods\n\n\nOracle publishes an \ninstallation guide\n for JDK 9, including installing it on native Windows (not through Ubuntu emulator).  I find it much more troublesome and complicated.  Unfortunately, if you are using an earlier version of Windows, you will have to follow these instructions.\n\n\nCompiling\n\n\nNow that you've installed Java on your machine, here's an example of how you can compile and run some Java code.\n\n\nJava source files\n\n\nCreate a new Java source file and put it in a new folder (e.g. \nCS2030\n).\n\n\n1\n2\n3\n4\n5\nclass\n \nHelloWorld\n \n{\n\n  \npublic\n \nstatic\n \nvoid\n \nmain\n(\nString\n[]\n \nargs\n)\n \n{\n\n    \nSystem\n.\nout\n.\nprintln\n(\n\"Hello, world!\"\n);\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\nBy convention, the file should be named \nHelloWorld.java\n, following the \nUpperCamelCase\n name of the class. At this point, our \nCS2030\n folder only contains that one file.\n\n\n1\n2\nCS2030 $ ls\nHelloWorld.java\n\n\n\n\n\n\nJava class files\n\n\nWe can go ahead and compile our Java program by running the \njavac HelloWorld.java\n command. This creates the corresponding Java class file, \nHelloWorld.class\n.\n\n\n1\n2\n3\nCS2030 $ javac HelloWorld.java\nCS2030 $ ls\nHelloWorld.class HelloWorld.java\n\n\n\n\n\n\nWe can now execute it with \njava HelloWorld\n. Remember to omit the \n.class\n extension when doing this!\n\n\n1\n2\n3\nCS2030 $ javac HelloWorld.java\nCS2030 $ java HelloWorld\nHello, world!\n\n\n\n\n\n\nSuccess! \ud83c\udf89\n\n\n\n\nWhat actually happens under the hood? Is Java an interpreted or compiled language?\n\n\nThis can get a little mind-boggling at first, but this \ndiagram\n summarizes it quite well.\n\n\n\n\n\n\n\n\n\n\n\n\nSee: \nWhat is the difference between javac and the Eclipse compiler?\n\u00a0\n\u21a9",
            "title": "Java"
        },
        {
            "location": "/jdk/index.html#java-installcompilerun",
            "text": "",
            "title": "Java: Install/Compile/Run"
        },
        {
            "location": "/jdk/index.html#java-development-kit-jdk",
            "text": "The Java Development Kit, or JDK, is a development environment for building Java applications.  The environment provides a virtual machine to execute compiled Java code (JVM), a collection of classes and libraries, and a set of tools to support development (including a compiler ( javac ), a debugger ( jdb ), an interactive shell ( jshell )) etc.  There are several variations of JDK available.  For instance,  OpenJDK  is a free and open source version of JDK.   GNU  offers a compiler in Java ( gcj ) and Java core libraries in Gnu classpath.\nEclipse offers its own version of Java compiler 1 .  These variations are mostly the same, but for the purpose of this module, we will use the  official Oracle version .  There are different editions of Java.  The main ones are Java SE (standard edition), Java EE (enterprise edition), and Java ME (micro edition).  We will be using  Java SE .  The latest version of Java SE is Java 8 (equivalent to version 1.8).\nThis is also the earliest version of Java that will work with this module, as many concepts we will cover are only introduced in Java 8.    To use  jshell , however, you need Java 9, which you can  download and install from here .",
            "title": "Java Development Kit (JDK)"
        },
        {
            "location": "/jdk/index.html#installing-jdk-9",
            "text": "There are multiple ways to setup JDK on various OS.  The following seems to be the simplest possible way to get started.",
            "title": "Installing JDK 9"
        },
        {
            "location": "/jdk/index.html#on-macos",
            "text": "Download the  .dmg  file corresponding to JDK 9 from  http://jdk.java.net/9/  and double click the  .dmg  file.  Follow instruction from there.  For a 6-step description of the above, see  the installation instruction from Oracle.",
            "title": "On macOS"
        },
        {
            "location": "/jdk/index.html#on-ubuntu-linux-mint-debian",
            "text": "We are going to use  apt , a package management program, in Linux to install JDK.  Run the following in your terminal:  1\n2\n3 sudo add-apt-repository ppa:webupd8team/java\nsudo apt-get update\nsudo apt-get install oracle-java9-installer   Line 1 above adds a special package repository (also known as Personal Package Archive (PPA)) to  apt .  Line 2 instructs  apt  to download the list of packages available from all repositories configured.  One of this packages should be  oracle-java9-installer .  Line 3 installs the  oracle-java9-installer .  Note that this install the installer, not Java 9.  After the installer is installed, the installer is executed.  You will be asked questions about license agreements, and then the installer proceeds to download and install Java 9.  For a more detailed instructions, see  the guide from the maintainer of the PPA, webupd8.org .",
            "title": "On Ubuntu / Linux Mint / Debian"
        },
        {
            "location": "/jdk/index.html#on-windows-10",
            "text": "Follow the  instructions to install Bash on Ubuntu on Windows , then install as per the instructions for Ubuntu above.",
            "title": "On Windows 10"
        },
        {
            "location": "/jdk/index.html#other-methods",
            "text": "Oracle publishes an  installation guide  for JDK 9, including installing it on native Windows (not through Ubuntu emulator).  I find it much more troublesome and complicated.  Unfortunately, if you are using an earlier version of Windows, you will have to follow these instructions.",
            "title": "Other Methods"
        },
        {
            "location": "/jdk/index.html#compiling",
            "text": "Now that you've installed Java on your machine, here's an example of how you can compile and run some Java code.",
            "title": "Compiling"
        },
        {
            "location": "/jdk/index.html#java-source-files",
            "text": "Create a new Java source file and put it in a new folder (e.g.  CS2030 ).  1\n2\n3\n4\n5 class   HelloWorld   { \n   public   static   void   main ( String []   args )   { \n     System . out . println ( \"Hello, world!\" ); \n   }  }    By convention, the file should be named  HelloWorld.java , following the  UpperCamelCase  name of the class. At this point, our  CS2030  folder only contains that one file.  1\n2 CS2030 $ ls\nHelloWorld.java",
            "title": "Java source files"
        },
        {
            "location": "/jdk/index.html#java-class-files",
            "text": "We can go ahead and compile our Java program by running the  javac HelloWorld.java  command. This creates the corresponding Java class file,  HelloWorld.class .  1\n2\n3 CS2030 $ javac HelloWorld.java\nCS2030 $ ls\nHelloWorld.class HelloWorld.java   We can now execute it with  java HelloWorld . Remember to omit the  .class  extension when doing this!  1\n2\n3 CS2030 $ javac HelloWorld.java\nCS2030 $ java HelloWorld\nHello, world!   Success! \ud83c\udf89   What actually happens under the hood? Is Java an interpreted or compiled language?  This can get a little mind-boggling at first, but this  diagram  summarizes it quite well.       See:  What is the difference between javac and the Eclipse compiler? \u00a0 \u21a9",
            "title": "Java class files"
        },
        {
            "location": "/javadoc/index.html",
            "text": "Javadoc\n\n\nWhy is documentation important\n\n\nOne of the goals of CS2030 is to move you away from the mindset that you are writing code that you will discard after it is done (e.g., in CS1010 labs) and you are writing code that noone else will read except you.  CS2030 prepares you to work in a software engineering teams in many ways, and one of the ways is to get you to document your code.\n\n\njavadoc\n is a tool used to document Java code.  It automatically generates HTML documentation from the comments in your code.  The \nJava SE 8 API\n that you have seen are generated from \njavadoc\n.\n\n\nHow to comment for javadoc\n\n\njavadoc\n distinguishes between normal comments and comments meant for \njavadoc\n by how we \"fence\" the comments.  A \njavadoc\n comments always starts with \n/**\n (not the double asterisks) and ends with \n*/\n and are always placed \nimmediately\n before a class, an interface, a constructor, a method, or field declaration.\n\n\nExample:\n\n1\n2\n3\n4\n5\n/** \n\n\n * Encapsulates a circle on a 2D plane.  The `Circle` class supports operators \n\n\n * supported includes (i) checking if a point is contained in the circle,\n\n\n * and (ii) moving the circle around to a new position.\n\n\n */\n\n\n\n\n\n\nThe first sentence is the summary sentence.  We should follow some style guideline when writing the summary sentence (see below).\n\n\njavadoc\n comments supports HTML tags.  If you are not familiar with HTML, \nthat is fine.  We will tell you what you need to know below.\n\n\nTags\n\n\njavadoc\n supports tags.  Here are some tags that we would like you to use:\n\n\n\n\n@param <name> <description>\n: describe the parameter \n\n\n@return <description>\n describe the return value\n\n\n@throws <class name> <description>\n describe what the exception \n being thrown and what are the possible reasons\n\n\n\n\nSee Lab 1 and Lab 2 skeleton code for samples.\n\n\nStyle\n\n\n\n\n\n\nIf you want to break you comments into paragraphs, insert one blank line between paragraphs.  Start a new paragraph with HTML tag \n<p>\n with no space after, and ends your paragraph with HTML tag \n</p>\n.\n\n\n\n\n\n\nYou should use the tags \n@param\n \n@return\n and \n@throws\n in that order, and they should never appear without a description.\n\n\n\n\n\n\nThe summary should be short and succint.  It is not a complete sentence, however, but should still be capitalized and ends with a period.  E.g., \n/** Encapsulates a circle on 2D plane. .. */\n\n\n\n\n\n\nYou don't get to write \njavadoc\n for self-explanatory, simple, obvious, methods.  e.g., \ngetX()\n, unless you want to explain what \nx\n means.  \n\n\n\n\n\n\nHow to generate javadoc\n\n\nIn its simplest form, you can generate \njavadoc\n like this:\n\n\n1\njavadoc *.java\n\n\n\n\n\n\nThis will generate the HTML files in your current directory.  \n\n\nTo avoid clutters, I recommend that you specify the output directory, e.g.,\n\n\n1\njavadoc *.java -d docs\n\n\n\n\n\n\nThis will generate the documentations and put it under the \ndocs\n subdirectory.\n\n\njavadoc\n by default generates documents only for public classes, fields, and methods.  To generate documentation for everything, run\n\n1\njavadoc *.java -d docs -private\n\n\n\n\n\nHow to view generate javadoc\n\n\nIf you generate the documentation on your computer, you can view it by opening up the file \nindex.html\n in your browser.\n\n\nIf you generate the documentation on \ncs2030-i.comp.nus.edu.sg\n, then, you can create under your \npublic_html\n directory (your home page, so to say).\n\n\n1\njavadoc -private -d ~/public_html/lab03 *.java\n\n\n\n\n\n\nYou can then view the documents on your computer through the URL\n\n\n1\nhttps://cs2030-i.comp.nus.edu.sg/~<username>/lab03\n\n\n\n\n\n\n(replace \n<username>\n with your username on \ncs2030-i\n.  The content is password protected and is only visible to you.  (If the website said that the certificate is invalid and website is not secure, please ignore the warning for now).\n\n\nSee Also\n\n\n\n\nOracle's \njavadoc\n Manual\n for a detailed \njavadoc\n guide",
            "title": "Javadoc"
        },
        {
            "location": "/javadoc/index.html#javadoc",
            "text": "",
            "title": "Javadoc"
        },
        {
            "location": "/javadoc/index.html#why-is-documentation-important",
            "text": "One of the goals of CS2030 is to move you away from the mindset that you are writing code that you will discard after it is done (e.g., in CS1010 labs) and you are writing code that noone else will read except you.  CS2030 prepares you to work in a software engineering teams in many ways, and one of the ways is to get you to document your code.  javadoc  is a tool used to document Java code.  It automatically generates HTML documentation from the comments in your code.  The  Java SE 8 API  that you have seen are generated from  javadoc .",
            "title": "Why is documentation important"
        },
        {
            "location": "/javadoc/index.html#how-to-comment-for-javadoc",
            "text": "javadoc  distinguishes between normal comments and comments meant for  javadoc  by how we \"fence\" the comments.  A  javadoc  comments always starts with  /**  (not the double asterisks) and ends with  */  and are always placed  immediately  before a class, an interface, a constructor, a method, or field declaration.  Example: 1\n2\n3\n4\n5 /**    * Encapsulates a circle on a 2D plane.  The `Circle` class supports operators    * supported includes (i) checking if a point is contained in the circle,   * and (ii) moving the circle around to a new position.   */    The first sentence is the summary sentence.  We should follow some style guideline when writing the summary sentence (see below).  javadoc  comments supports HTML tags.  If you are not familiar with HTML, \nthat is fine.  We will tell you what you need to know below.",
            "title": "How to comment for javadoc"
        },
        {
            "location": "/javadoc/index.html#tags",
            "text": "javadoc  supports tags.  Here are some tags that we would like you to use:   @param <name> <description> : describe the parameter   @return <description>  describe the return value  @throws <class name> <description>  describe what the exception   being thrown and what are the possible reasons   See Lab 1 and Lab 2 skeleton code for samples.",
            "title": "Tags"
        },
        {
            "location": "/javadoc/index.html#style",
            "text": "If you want to break you comments into paragraphs, insert one blank line between paragraphs.  Start a new paragraph with HTML tag  <p>  with no space after, and ends your paragraph with HTML tag  </p> .    You should use the tags  @param   @return  and  @throws  in that order, and they should never appear without a description.    The summary should be short and succint.  It is not a complete sentence, however, but should still be capitalized and ends with a period.  E.g.,  /** Encapsulates a circle on 2D plane. .. */    You don't get to write  javadoc  for self-explanatory, simple, obvious, methods.  e.g.,  getX() , unless you want to explain what  x  means.",
            "title": "Style"
        },
        {
            "location": "/javadoc/index.html#how-to-generate-javadoc",
            "text": "In its simplest form, you can generate  javadoc  like this:  1 javadoc *.java   This will generate the HTML files in your current directory.    To avoid clutters, I recommend that you specify the output directory, e.g.,  1 javadoc *.java -d docs   This will generate the documentations and put it under the  docs  subdirectory.  javadoc  by default generates documents only for public classes, fields, and methods.  To generate documentation for everything, run 1 javadoc *.java -d docs -private",
            "title": "How to generate javadoc"
        },
        {
            "location": "/javadoc/index.html#how-to-view-generate-javadoc",
            "text": "If you generate the documentation on your computer, you can view it by opening up the file  index.html  in your browser.  If you generate the documentation on  cs2030-i.comp.nus.edu.sg , then, you can create under your  public_html  directory (your home page, so to say).  1 javadoc -private -d ~/public_html/lab03 *.java   You can then view the documents on your computer through the URL  1 https://cs2030-i.comp.nus.edu.sg/~<username>/lab03   (replace  <username>  with your username on  cs2030-i .  The content is password protected and is only visible to you.  (If the website said that the certificate is invalid and website is not secure, please ignore the warning for now).",
            "title": "How to view generate javadoc"
        },
        {
            "location": "/javadoc/index.html#see-also",
            "text": "Oracle's  javadoc  Manual  for a detailed  javadoc  guide",
            "title": "See Also"
        },
        {
            "location": "/unix/index.html",
            "text": "Accessing CS2030 Lab Programming Environment\n\n\nThe Environment\n\n\nThe school has created a VM (virtual machine) for CS2030, with hostname \ncs2030-i.comp.nus.edu.sg\n.  The VM is running CentOS, one of the Linux distributions.\nThis will be the official programming environment for CS2030 for all your lab assignments.\n\n\nI have created your accounts on the VM based on your SoC UNIX account.  You can login with your SoC UNIX username (not your NUSNET username, unless you intentionally set the two to be the same) and password.\n\n\nSoC VPN\n\n\nTHe VM can only be accessed from within the School of Computing networks.  If you want to access it from outside, you need to setup a Virtual Private Network (VPN) (See \ninstruction here\n).  The staff at \nhelpdesk@comp.nus.edu.sg\n or the IT helpdesk in COM1, Level 1, will be able to help with you setting up if needed.\n\n\nSSH\n\n\nFor UNIX-based OS\n\n\nIf you use either macOS, Windows 10 (with bash on Ubuntu), or Linux, you should have the command line \nssh\n installed.  \n\n\nRun:\n\n1\nssh <username>@cs2030-i.comp.nus.edu.sg\n\n\n\n\n\nReplace \n<username>\n with your SoC UNIX username, for instance, I would do:\n\n1\nssh ooiwt@cs2030-i.comp.nus.edu.sg\n\n\n\n\n\nAfter the command above, following the instructions on screen.  The first time you ever connect to \ncs2030-i.comp.nus.edu.sg\n, you will be warned that you are connecting to a previously unknown host.  Said \nyes\n, and you will be prompted with your SoC UNIX password.\n\n\nFor Windows 7 or 8\n\n\nThe desktop computers in Programming Lab 6 (PL6) runs Windows 7.  If you are using these computers, or your own computers with older versions of Windows, you need to use \nXShell 5\n to access the VM.\n\n\nBasic UNIX Commands\n\n\nOnce you logged into the VM, you will be prompted to enter a command with a prompt that looks like this:\n\n1\nhappytan@cs2030-i:~[xxx]$\n\n\n\n\nThis interface is provided by a UNIX shell -- not unlike \njshell\n, this shell sits in a loop and wait for users to enter a command, then it interprets and executes the command.  There are many versions of shells, the default shell for our VM is \nbash\n1\n.\n\n\nThe following are adapted for CS2030 from \nthe instructions created by Aaron Tan\n. Bugs are mine.\n  \n\n\nThe power of UNIX stems from the many commands it offers. The following are a few commonly used commands. This list is by no means exhaustive and you are urged to explore on your own. Note that UNIX commands are case-sensitive.\n\n\nIn the examples below, bold words are commands which you are expected to enter. All commands are to be entered after the UNIX (local or \nsunfire\n or \ncs2030-i\n) prompt of the form\n\n\n1\nhappytan@cs2030-i:~[xxx]$\n\n\n\n\n\n\n~\n indicates that you are currently in your home directory, \nxxx\n is a number indicating the number of commands that have been entered.  The following examples assumes that user \nhappytan\n is logged into cs2030-i; however you can do it on your local UNIX platform too.\n\n\nIt might be good to understand the directory structure in UNIX, a multi-user system. The directory tree is shown below:\n\n\n\n\nEach user has his/her own home directory, which is where he/she will be automatically placed when he/she logs into the system. The above figure shows where the home directory of user \nhappytan\n resides in the directory tree. The user \nhappytan\n may create files or directories in his/her home directory, but not elsewhere unless permission is given.\n\n\nDirectory commands\n\n\n\n\n\n\npwd\n: Print current Working Directory to show you which directory you are currently in\n\n1\n2\nhappytan@cs2030-i:~[xxx]$ pwd\n/home/h/happytan\n\n\n\n\n\n\n\n\n\nls\n: LiSt files in your current directory\n\n1\n2\nhappytan@cs2030-i:~[xxx]$ ls\nhappytan@cs2030-i:~[xxx]$\n\n\n\n\n   If you do not have any regular files in your home directory, as you should when you first login, you should immediately return to the shell prompt.  \n\n\n\n\n\n\n\n\nRule of Silence\nUNIX follows the \nrule of silence\n: programs should not print unnecessary output, to allow other programs and users to easily parse the output from one program.  So, if \nls\n has nothing to list, it will list nothing (as oppose to, say, printing \"This is an empty directory.\")\n\n\n\n\n\n\n\n\n\n\nmkdir\n: MaKe a subDIRectory in current directory\n\n1\n2\n3\n4\n5\nhappytan@cs2030-i:~[xxx]$ mkdir lab01\nhappytan@cs2030-i:~[xxx]$ ls\nlab01\nhappytan@cs2030-i:~[xxx]$ ls -F\nlab01/\n\n\n\n\nHere, you create a directory called \nlab01\n.  Now, when you \nls\n, you can see the directory listed.\nYou may also use \nls -F\n for more information (\n-F\n is one of the many \noptions\n/\nflags\n available for the \nls\n command. To see a complete list of the options, refer to the man pages, i.e., \nman ls\n.)\n\n\nThe slash \n/\n beside the filename tells you that the file is a directory (aka folder in Windows lingo). A normal file does not have a slash beside its name when \"ls -F\" is used.\n\n\nYou may also use the \nls -l\n command (hyphen el, not hyphen one) to display almost all the file information, include the size of the file and the date of modification.\n\n\n\n\n\n\n\n\nCommand history\n\n\nUNIX maintains a history of your previously executed UNIX commands, and you may use the up and down arrows to go through it. Press the up arrow until you find a previously executed UNIX command. You may then press Enter to execute it, or edit the command before executing it. This is handy when you need to repeatedly executed a long UNIX command.\n\n\n\n\n\n\n\n\ncd\n: Change Directory from current directory to another\n\n1\n2\nhappytan@cs2030-i:~[xxx]$ cd lab01\nhappytan@cs2030-i:~/lab01[xxx]$\n\n\n\n\nNote that the prompt changes to \n~/lab01\n to indicate that you are now in the \nlab01\n directory below your \nHOME\n directory.\n\n\nEntering \ncd\n alone brings you back to your \nHOME\n directory, i.e.,. the directory in which you started with when you first logged into the system.\n\n1\n2\nhappytan@cs2030-i:~/lab01[xxx]$ cd\nhappytan@cs2030-i:~[xxx]$\n\n\n\n\n\n\n\n\n\nrmdir\n:  to ReMove a subDIRectory in current directory -- note that a directory must be empty before it can be removed.\n\n1\n2\n3\n4\n5\nhappytan@cs2030-i:~[xxx]$ rmdir lab01\nhappytan@cs2030-i:~[xxx]$ ls -F\nhappytan@cs2030-i:~[xxx]$ mkdir lab01\nhappytan@cs2030-i:~[xxx]$ ls -F\nlab01/\n\n\n\n\n\n\n\n\n\nFile commands\n\n\n\n\ncp\n:  CoPy files\n\n1\n2\n3\nhappytan@cs2030-i:~/lab01[xxx]$ cp ~cs2030/lab01/Circle.java .\nhappytan@cs2030-i:~/lab01[xxx]$ ls\nCircle.java\n\n\n\n\nThe command above copy the files Circle.java from the HOME of user \ncs2030\n, under directory \nlab01\n, to the current directory.\n\n\n\n\nIf you want to copy the whole directory, use \n-r\n flag, where \nr\n stands for recursive copy.\n\n\n1\nhappytan@cs2030-i:~/lab01[xxx]$ cp -r ~cs2030/lab01 .\n\n\n\n\n\n\nThe directory \nlab01\n and everything under it will be copied.\n\n\n\n\nmv\n: MoVe files from one directory to another; can also be used to rename files.\n\n1\n2\n3\nhappytan@cs2030-i:~/lab01[xxx]$ mv Circle.java Test.java\nhappytan@cs2030-i:~/lab01[xxx]$ ls\nTest.java\n\n\n\n\n\n\n\n\n\nFilename completion\n\n\nIf you have a very long file name, you may use UNIX's filename completion feature to reduce typing. For instance, you may type:\n\n1\nhappytan@cs2030-i:~/lab01[xxx]$ mv C\n\n\n\n\nand press the tab key, and UNIX will complete the filename for you if there is only one filename with the prefix \"C\". Otherwise, it will fill up the filename up to point where you need to type in more characters for disambiguation.\n\n\n\n\n\n\nrm\n: ReMove files. Be careful with this command -- files deleted cannot be restored (unless they have been backed up during the normal backup cycle).\n\n1\n2\n3\n4\nhappytan@cs2030-i:~/lab01[xxx]$ rm Test.java\nrm: remove 'Test.java'? y\nhappytan@cs2030-i:~/lab01[xxx]$ ls\nhappytan@cs2030-i:~/lab01[xxx]$\n\n\n\n\n\n\n\nCommand to display text files\n\n\n\n\ncat\n: to string together or display (CATenate) the contents of files onto the screen\n\n1\nhappytan@cs2030-i:~/lab01[xxx]$ cat Circle.java\n\n\n\n\n\nless\n - variant of \ncat\n (includes features to read each page leisurely)\n\n1\nhappytan@cs2030-i:~/lab01[xxx]$ less Circle.java\n\n\n\n\nIn \nless\n, use \n<space>\n to move down one page, \nb\n to move Back up one page, and \nq\n to Quit from \"less\".\n\n\n\n\nAn online help facility is available in UNIX via the \nman\n command (\nman\n stands for MANual). To look for more information about any UNIX command, for example, \nls\n, type \nman ls\n. Type \nman man\n and refer to Man Pages to find out more about the facility. To exit \nman\n, press \nq\n.\n\n\nNow that you are familiar with how the UNIX shell works, I won't show the command prompt any more in the rest of this article.\n\n\nUNIX File Permission\n\n\nIt is important to guide our files properly on a multi-user system where users share the same file system.  UNIX has a simple mechanism to for ensuring that: every file and directory has nine bits of access permission, corresponds to three access operations, read (\nr\n), write (\nw\n), and execute (\nx\n), for four classes of users, the user who owns of the file (\nu\n), users in the same group as the owner (\ng\n), all other users (\no\n), and all users (\na\n) (union of all three classes before)\n\n\nWhen you run \nls -l\n, you will see the permission encoded as strings that look like \n-rw-------\n or \ndrwx--x--x\n besides other file information.   \n\n\n\n\nThe first character indicates if the file is a directory (\nd\n) or not (\n-\n).  \n\n\nThe next three characters are the permission for the owner.  \nrwx\n means that the owner can do all three: reading, writing, and executing, \nrw-\n means that the owner can read and write, but cannot execute.\n\n\nThe next three characters are the permission for the users in the same group.\n\n\nThe last three characters are the permission for the users in the other groups.\n\n\n\n\nTo change permission, we use the \nchmod\n command.  Let's say that we want to remove the read and write permission from all other users in the group.  You can run:\n\n1\nchmod g-rw <file>\n\n\n\n\n\nwhere \n<file>\n is the name of the file whose permission you want to change.  This would change the permission from \n-rw-rw-rw-\n to \n-rw----rw-\n, or from \n-rwxr--r--\n to \n-rwx---r--\n.\n\n\nTo add executable permission to everyone, you can run:\n\n1\nchmod a+x <file>\n\n\n\n\n\nThis would change the permission from \n-rw-rw-rw-\n to \n-rwx--xrwx\n, or from \n-rwxr--r--\n to \n-rwx--xr-x\n, and so on.  You get the idea.\n\n\nAnother way to change the permission is set the permission directly, instead of adding with \n+\n and removing with \n-\n.  To do this, one convenient way is to treat the permission for each class of user as a 3-bit binary number between 0 to 7.  So, \nrwx\n is 7, \nrw-\n is 6, \n-w-\n is 2, \n---\n is 0, etc.  \n\n\nTo set the permission of a file to \n-r--r--r--\n (readable by everyone), run:\n\n1\nchmod 444 <file>\n\n\n\n\n\nTo set the permission to \n-rw-------\n, run:\n\n1\nchmod 600 <file>\n\n\n\n\n\nand so on.\n\n\nIt is important to ensure that your code is not readable and writable by other students, especially for graded lab exercises.\n\n\nSecure Copy (\nscp\n)\n\n\nSecure copy, or \nscp\n, is one way to transfer files from your local computer to \ncs2030-i\n.  If you choose not to use \nemacs\n or \nvim\n2\n and write your code on \ncs2030-i\n, you can write your code on your local computer, and transfer them.  Let's say that you are in the directory with a bunch of java files you want to transfer, and you want them transferred into directory \ntest\n that you have created, do the following:\n\n\n1\nscp *.java happytan@cs2030-i:~/test\n\n\n\n\n\n\n\n\nWarning\n\n\nIf you have files with the same name in the remote directory, the files will be overwritten without warning.  I have lost my code a few times due to \nscp\n.  \n\n\n\n\nThe expression \n*.java\n is a regular expression that means all files with filename ending with \n.java\n.  You can copy specific files as well.  For instance,\n\n\n1\nscp Circle.java Point.java happytan@cs2030-i:~/test\n\n\n\n\n\n\nscp\n supports \n-r\n (recursive copy) as well.\n\n\nSetting up SSH Keys\n\n\nOnce you are comfortable with UNIX, you can set up a pair of public/private keys for authentication.  \n\n\nYou can use\n\n1\nssh-keygen -t rsa\n\n\n\n\n\nto generate a pair of keys on your local computer.  Keep the private key \nid_rsa\n on your local machine in the hidden \n~/.ssh\n directory, and copy the public key \nid_rsa.pub\n to your home directory on VM \ncs2030-i\n.  On \ncs2030-i\n, run\n\n1\ncat id_rsa.pub >> ~/.ssh/authorized_keys\n\n\n\n\n\nMake sure that the permission for \n.ssh\n both on local machine and on VM is set to \n700\n and the files \nid_rsa\n on local machine and \nauthorized_keys\n on remote machine is set to \n600\n.  Once setup, you need not enter your password every time you run \nssh\n or \nscp\n.  \n\n\n\n\n\n\n\n\n\n\nI run \nfish\n on my macOS, as you might have noticed during the in-class demos.  You can use any shell you like, if you know what you are doing.  Otherwise, \nbash\n is a popular one.\u00a0\n\u21a9\n\n\n\n\n\n\nMy personal opinion is that, you should really master one of these two time-tested source code editor if you want a career in software development.\u00a0\n\u21a9",
            "title": "UNIX"
        },
        {
            "location": "/unix/index.html#accessing-cs2030-lab-programming-environment",
            "text": "",
            "title": "Accessing CS2030 Lab Programming Environment"
        },
        {
            "location": "/unix/index.html#the-environment",
            "text": "The school has created a VM (virtual machine) for CS2030, with hostname  cs2030-i.comp.nus.edu.sg .  The VM is running CentOS, one of the Linux distributions.\nThis will be the official programming environment for CS2030 for all your lab assignments.  I have created your accounts on the VM based on your SoC UNIX account.  You can login with your SoC UNIX username (not your NUSNET username, unless you intentionally set the two to be the same) and password.",
            "title": "The Environment"
        },
        {
            "location": "/unix/index.html#soc-vpn",
            "text": "THe VM can only be accessed from within the School of Computing networks.  If you want to access it from outside, you need to setup a Virtual Private Network (VPN) (See  instruction here ).  The staff at  helpdesk@comp.nus.edu.sg  or the IT helpdesk in COM1, Level 1, will be able to help with you setting up if needed.",
            "title": "SoC VPN"
        },
        {
            "location": "/unix/index.html#ssh",
            "text": "",
            "title": "SSH"
        },
        {
            "location": "/unix/index.html#for-unix-based-os",
            "text": "If you use either macOS, Windows 10 (with bash on Ubuntu), or Linux, you should have the command line  ssh  installed.    Run: 1 ssh <username>@cs2030-i.comp.nus.edu.sg   Replace  <username>  with your SoC UNIX username, for instance, I would do: 1 ssh ooiwt@cs2030-i.comp.nus.edu.sg   After the command above, following the instructions on screen.  The first time you ever connect to  cs2030-i.comp.nus.edu.sg , you will be warned that you are connecting to a previously unknown host.  Said  yes , and you will be prompted with your SoC UNIX password.",
            "title": "For UNIX-based OS"
        },
        {
            "location": "/unix/index.html#for-windows-7-or-8",
            "text": "The desktop computers in Programming Lab 6 (PL6) runs Windows 7.  If you are using these computers, or your own computers with older versions of Windows, you need to use  XShell 5  to access the VM.",
            "title": "For Windows 7 or 8"
        },
        {
            "location": "/unix/index.html#basic-unix-commands",
            "text": "Once you logged into the VM, you will be prompted to enter a command with a prompt that looks like this: 1 happytan@cs2030-i:~[xxx]$  \nThis interface is provided by a UNIX shell -- not unlike  jshell , this shell sits in a loop and wait for users to enter a command, then it interprets and executes the command.  There are many versions of shells, the default shell for our VM is  bash 1 .  The following are adapted for CS2030 from  the instructions created by Aaron Tan . Bugs are mine.     The power of UNIX stems from the many commands it offers. The following are a few commonly used commands. This list is by no means exhaustive and you are urged to explore on your own. Note that UNIX commands are case-sensitive.  In the examples below, bold words are commands which you are expected to enter. All commands are to be entered after the UNIX (local or  sunfire  or  cs2030-i ) prompt of the form  1 happytan@cs2030-i:~[xxx]$   ~  indicates that you are currently in your home directory,  xxx  is a number indicating the number of commands that have been entered.  The following examples assumes that user  happytan  is logged into cs2030-i; however you can do it on your local UNIX platform too.  It might be good to understand the directory structure in UNIX, a multi-user system. The directory tree is shown below:   Each user has his/her own home directory, which is where he/she will be automatically placed when he/she logs into the system. The above figure shows where the home directory of user  happytan  resides in the directory tree. The user  happytan  may create files or directories in his/her home directory, but not elsewhere unless permission is given.",
            "title": "Basic UNIX Commands"
        },
        {
            "location": "/unix/index.html#directory-commands",
            "text": "pwd : Print current Working Directory to show you which directory you are currently in 1\n2 happytan@cs2030-i:~[xxx]$ pwd\n/home/h/happytan     ls : LiSt files in your current directory 1\n2 happytan@cs2030-i:~[xxx]$ ls\nhappytan@cs2030-i:~[xxx]$  \n   If you do not have any regular files in your home directory, as you should when you first login, you should immediately return to the shell prompt.       Rule of Silence UNIX follows the  rule of silence : programs should not print unnecessary output, to allow other programs and users to easily parse the output from one program.  So, if  ls  has nothing to list, it will list nothing (as oppose to, say, printing \"This is an empty directory.\")      mkdir : MaKe a subDIRectory in current directory 1\n2\n3\n4\n5 happytan@cs2030-i:~[xxx]$ mkdir lab01\nhappytan@cs2030-i:~[xxx]$ ls\nlab01\nhappytan@cs2030-i:~[xxx]$ ls -F\nlab01/  \nHere, you create a directory called  lab01 .  Now, when you  ls , you can see the directory listed.\nYou may also use  ls -F  for more information ( -F  is one of the many  options / flags  available for the  ls  command. To see a complete list of the options, refer to the man pages, i.e.,  man ls .)  The slash  /  beside the filename tells you that the file is a directory (aka folder in Windows lingo). A normal file does not have a slash beside its name when \"ls -F\" is used.  You may also use the  ls -l  command (hyphen el, not hyphen one) to display almost all the file information, include the size of the file and the date of modification.     Command history  UNIX maintains a history of your previously executed UNIX commands, and you may use the up and down arrows to go through it. Press the up arrow until you find a previously executed UNIX command. You may then press Enter to execute it, or edit the command before executing it. This is handy when you need to repeatedly executed a long UNIX command.     cd : Change Directory from current directory to another 1\n2 happytan@cs2030-i:~[xxx]$ cd lab01\nhappytan@cs2030-i:~/lab01[xxx]$  \nNote that the prompt changes to  ~/lab01  to indicate that you are now in the  lab01  directory below your  HOME  directory.  Entering  cd  alone brings you back to your  HOME  directory, i.e.,. the directory in which you started with when you first logged into the system. 1\n2 happytan@cs2030-i:~/lab01[xxx]$ cd\nhappytan@cs2030-i:~[xxx]$     rmdir :  to ReMove a subDIRectory in current directory -- note that a directory must be empty before it can be removed. 1\n2\n3\n4\n5 happytan@cs2030-i:~[xxx]$ rmdir lab01\nhappytan@cs2030-i:~[xxx]$ ls -F\nhappytan@cs2030-i:~[xxx]$ mkdir lab01\nhappytan@cs2030-i:~[xxx]$ ls -F\nlab01/",
            "title": "Directory commands"
        },
        {
            "location": "/unix/index.html#file-commands",
            "text": "cp :  CoPy files 1\n2\n3 happytan@cs2030-i:~/lab01[xxx]$ cp ~cs2030/lab01/Circle.java .\nhappytan@cs2030-i:~/lab01[xxx]$ ls\nCircle.java  \nThe command above copy the files Circle.java from the HOME of user  cs2030 , under directory  lab01 , to the current directory.   If you want to copy the whole directory, use  -r  flag, where  r  stands for recursive copy.  1 happytan@cs2030-i:~/lab01[xxx]$ cp -r ~cs2030/lab01 .   The directory  lab01  and everything under it will be copied.   mv : MoVe files from one directory to another; can also be used to rename files. 1\n2\n3 happytan@cs2030-i:~/lab01[xxx]$ mv Circle.java Test.java\nhappytan@cs2030-i:~/lab01[xxx]$ ls\nTest.java     Filename completion  If you have a very long file name, you may use UNIX's filename completion feature to reduce typing. For instance, you may type: 1 happytan@cs2030-i:~/lab01[xxx]$ mv C  \nand press the tab key, and UNIX will complete the filename for you if there is only one filename with the prefix \"C\". Otherwise, it will fill up the filename up to point where you need to type in more characters for disambiguation.    rm : ReMove files. Be careful with this command -- files deleted cannot be restored (unless they have been backed up during the normal backup cycle). 1\n2\n3\n4 happytan@cs2030-i:~/lab01[xxx]$ rm Test.java\nrm: remove 'Test.java'? y\nhappytan@cs2030-i:~/lab01[xxx]$ ls\nhappytan@cs2030-i:~/lab01[xxx]$",
            "title": "File commands"
        },
        {
            "location": "/unix/index.html#command-to-display-text-files",
            "text": "cat : to string together or display (CATenate) the contents of files onto the screen 1 happytan@cs2030-i:~/lab01[xxx]$ cat Circle.java   less  - variant of  cat  (includes features to read each page leisurely) 1 happytan@cs2030-i:~/lab01[xxx]$ less Circle.java  \nIn  less , use  <space>  to move down one page,  b  to move Back up one page, and  q  to Quit from \"less\".   An online help facility is available in UNIX via the  man  command ( man  stands for MANual). To look for more information about any UNIX command, for example,  ls , type  man ls . Type  man man  and refer to Man Pages to find out more about the facility. To exit  man , press  q .  Now that you are familiar with how the UNIX shell works, I won't show the command prompt any more in the rest of this article.",
            "title": "Command to display text files"
        },
        {
            "location": "/unix/index.html#unix-file-permission",
            "text": "It is important to guide our files properly on a multi-user system where users share the same file system.  UNIX has a simple mechanism to for ensuring that: every file and directory has nine bits of access permission, corresponds to three access operations, read ( r ), write ( w ), and execute ( x ), for four classes of users, the user who owns of the file ( u ), users in the same group as the owner ( g ), all other users ( o ), and all users ( a ) (union of all three classes before)  When you run  ls -l , you will see the permission encoded as strings that look like  -rw-------  or  drwx--x--x  besides other file information.      The first character indicates if the file is a directory ( d ) or not ( - ).    The next three characters are the permission for the owner.   rwx  means that the owner can do all three: reading, writing, and executing,  rw-  means that the owner can read and write, but cannot execute.  The next three characters are the permission for the users in the same group.  The last three characters are the permission for the users in the other groups.   To change permission, we use the  chmod  command.  Let's say that we want to remove the read and write permission from all other users in the group.  You can run: 1 chmod g-rw <file>   where  <file>  is the name of the file whose permission you want to change.  This would change the permission from  -rw-rw-rw-  to  -rw----rw- , or from  -rwxr--r--  to  -rwx---r-- .  To add executable permission to everyone, you can run: 1 chmod a+x <file>   This would change the permission from  -rw-rw-rw-  to  -rwx--xrwx , or from  -rwxr--r--  to  -rwx--xr-x , and so on.  You get the idea.  Another way to change the permission is set the permission directly, instead of adding with  +  and removing with  - .  To do this, one convenient way is to treat the permission for each class of user as a 3-bit binary number between 0 to 7.  So,  rwx  is 7,  rw-  is 6,  -w-  is 2,  ---  is 0, etc.    To set the permission of a file to  -r--r--r--  (readable by everyone), run: 1 chmod 444 <file>   To set the permission to  -rw------- , run: 1 chmod 600 <file>   and so on.  It is important to ensure that your code is not readable and writable by other students, especially for graded lab exercises.",
            "title": "UNIX File Permission"
        },
        {
            "location": "/unix/index.html#secure-copy-scp",
            "text": "Secure copy, or  scp , is one way to transfer files from your local computer to  cs2030-i .  If you choose not to use  emacs  or  vim 2  and write your code on  cs2030-i , you can write your code on your local computer, and transfer them.  Let's say that you are in the directory with a bunch of java files you want to transfer, and you want them transferred into directory  test  that you have created, do the following:  1 scp *.java happytan@cs2030-i:~/test    Warning  If you have files with the same name in the remote directory, the files will be overwritten without warning.  I have lost my code a few times due to  scp .     The expression  *.java  is a regular expression that means all files with filename ending with  .java .  You can copy specific files as well.  For instance,  1 scp Circle.java Point.java happytan@cs2030-i:~/test   scp  supports  -r  (recursive copy) as well.",
            "title": "Secure Copy (scp)"
        },
        {
            "location": "/unix/index.html#setting-up-ssh-keys",
            "text": "Once you are comfortable with UNIX, you can set up a pair of public/private keys for authentication.    You can use 1 ssh-keygen -t rsa   to generate a pair of keys on your local computer.  Keep the private key  id_rsa  on your local machine in the hidden  ~/.ssh  directory, and copy the public key  id_rsa.pub  to your home directory on VM  cs2030-i .  On  cs2030-i , run 1 cat id_rsa.pub >> ~/.ssh/authorized_keys   Make sure that the permission for  .ssh  both on local machine and on VM is set to  700  and the files  id_rsa  on local machine and  authorized_keys  on remote machine is set to  600 .  Once setup, you need not enter your password every time you run  ssh  or  scp .        I run  fish  on my macOS, as you might have noticed during the in-class demos.  You can use any shell you like, if you know what you are doing.  Otherwise,  bash  is a popular one.\u00a0 \u21a9    My personal opinion is that, you should really master one of these two time-tested source code editor if you want a career in software development.\u00a0 \u21a9",
            "title": "Setting up SSH Keys"
        }
    ]
}